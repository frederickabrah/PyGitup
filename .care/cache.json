{
  "projectPath": "/data/data/com.termux/files/home/PyGitUp",
  "analyzedAt": "2026-02-01T17:49:41.241Z",
  "duration": 11862,
  "files": [
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup.py",
      "relativePath": "pygitup.py",
      "language": "python",
      "size": 175,
      "lines": 9,
      "lastModified": "2025-09-30T15:49:27.000Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/setup.py",
      "relativePath": "setup.py",
      "language": "python",
      "size": 985,
      "lines": 36,
      "lastModified": "2026-02-01T16:13:26.671Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/__init__.py",
      "relativePath": "pygitup/__init__.py",
      "language": "python",
      "size": 22,
      "lines": 2,
      "lastModified": "2026-02-01T16:13:21.619Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
      "relativePath": "pygitup/main.py",
      "language": "python",
      "size": 11890,
      "lines": 240,
      "lastModified": "2026-02-01T16:03:26.923Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/tests/conftest.py",
      "relativePath": "tests/conftest.py",
      "language": "python",
      "size": 144,
      "lines": 6,
      "lastModified": "2025-12-30T00:11:16.000Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
      "relativePath": "tests/test_docs.py",
      "language": "python",
      "size": 2767,
      "lines": 89,
      "lastModified": "2025-12-30T00:02:51.000Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
      "relativePath": "tests/test_main.py",
      "language": "python",
      "size": 7692,
      "lines": 207,
      "lastModified": "2026-01-31T21:42:47.429Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
      "relativePath": "tests/test_module.py",
      "language": "python",
      "size": 1016,
      "lines": 51,
      "lastModified": "2025-09-16T23:59:28.000Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/__init__.py",
      "relativePath": "pygitup/core/__init__.py",
      "language": "python",
      "size": 0,
      "lines": 1,
      "lastModified": "2025-09-30T15:39:33.000Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/args.py",
      "relativePath": "pygitup/core/args.py",
      "language": "python",
      "size": 8976,
      "lines": 151,
      "lastModified": "2026-02-01T15:15:12.003Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
      "relativePath": "pygitup/core/config.py",
      "language": "python",
      "size": 6065,
      "lines": 310,
      "lastModified": "2026-02-01T15:21:10.527Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/__init__.py",
      "relativePath": "pygitup/git/__init__.py",
      "language": "python",
      "size": 0,
      "lines": 1,
      "lastModified": "2025-09-30T15:39:33.000Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/branch.py",
      "relativePath": "pygitup/git/branch.py",
      "language": "python",
      "size": 2434,
      "lines": 57,
      "lastModified": "2026-02-01T09:54:06.269Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/cherry_pick.py",
      "relativePath": "pygitup/git/cherry_pick.py",
      "language": "python",
      "size": 997,
      "lines": 27,
      "lastModified": "2026-02-01T09:54:06.269Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/push.py",
      "relativePath": "pygitup/git/push.py",
      "language": "python",
      "size": 3186,
      "lines": 74,
      "lastModified": "2026-02-01T09:54:06.269Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/stash.py",
      "relativePath": "pygitup/git/stash.py",
      "language": "python",
      "size": 2258,
      "lines": 55,
      "lastModified": "2026-02-01T09:54:06.269Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/tag.py",
      "relativePath": "pygitup/git/tag.py",
      "language": "python",
      "size": 2503,
      "lines": 63,
      "lastModified": "2026-02-01T09:54:06.269Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/__init__.py",
      "relativePath": "pygitup/github/__init__.py",
      "language": "python",
      "size": 0,
      "lines": 1,
      "lastModified": "2025-09-30T15:39:33.000Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/actions.py",
      "relativePath": "pygitup/github/actions.py",
      "language": "python",
      "size": 4123,
      "lines": 84,
      "lastModified": "2026-01-31T23:57:32.179Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
      "relativePath": "pygitup/github/api.py",
      "language": "python",
      "size": 8563,
      "lines": 208,
      "lastModified": "2026-02-01T10:08:13.349Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
      "relativePath": "pygitup/github/gists.py",
      "language": "python",
      "size": 3628,
      "lines": 84,
      "lastModified": "2026-02-01T16:03:00.683Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
      "relativePath": "pygitup/github/pull_requests.py",
      "language": "python",
      "size": 5963,
      "lines": 143,
      "lastModified": "2026-02-01T09:54:06.269Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
      "relativePath": "pygitup/github/releases.py",
      "language": "python",
      "size": 5390,
      "lines": 132,
      "lastModified": "2026-02-01T15:54:18.019Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
      "relativePath": "pygitup/github/repo.py",
      "language": "python",
      "size": 3705,
      "lines": 99,
      "lastModified": "2026-02-01T09:54:06.273Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
      "relativePath": "pygitup/github/repo_info.py",
      "language": "python",
      "size": 9546,
      "lines": 226,
      "lastModified": "2026-02-01T16:07:53.031Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/webhooks.py",
      "relativePath": "pygitup/github/webhooks.py",
      "language": "python",
      "size": 3546,
      "lines": 86,
      "lastModified": "2026-02-01T09:54:06.273Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/__init__.py",
      "relativePath": "pygitup/project/__init__.py",
      "language": "python",
      "size": 0,
      "lines": 1,
      "lastModified": "2025-09-30T15:39:33.000Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
      "relativePath": "pygitup/project/docs.py",
      "language": "python",
      "size": 16550,
      "lines": 377,
      "lastModified": "2026-02-01T09:54:06.273Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
      "relativePath": "pygitup/project/issues.py",
      "language": "python",
      "size": 5801,
      "lines": 130,
      "lastModified": "2026-01-31T23:50:16.543Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
      "relativePath": "pygitup/project/project_ops.py",
      "language": "python",
      "size": 23189,
      "lines": 544,
      "lastModified": "2026-02-01T10:08:13.353Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
      "relativePath": "pygitup/project/templates.py",
      "language": "python",
      "size": 4787,
      "lines": 166,
      "lastModified": "2025-10-04T00:11:04.000Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/__init__.py",
      "relativePath": "pygitup/utils/__init__.py",
      "language": "python",
      "size": 0,
      "lines": 1,
      "lastModified": "2025-09-30T15:39:33.000Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
      "relativePath": "pygitup/utils/ai.py",
      "language": "python",
      "size": 5314,
      "lines": 147,
      "lastModified": "2026-02-01T15:54:04.691Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
      "relativePath": "pygitup/utils/analytics.py",
      "language": "python",
      "size": 5083,
      "lines": 122,
      "lastModified": "2026-02-01T10:30:00.193Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/banner.py",
      "relativePath": "pygitup/utils/banner.py",
      "language": "python",
      "size": 8532,
      "lines": 293,
      "lastModified": "2026-01-31T21:32:17.757Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
      "relativePath": "pygitup/utils/offline.py",
      "language": "python",
      "size": 4976,
      "lines": 146,
      "lastModified": "2026-02-01T09:54:06.273Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/scraper.py",
      "relativePath": "pygitup/utils/scraper.py",
      "language": "python",
      "size": 4919,
      "lines": 113,
      "lastModified": "2026-02-01T16:06:54.351Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
      "relativePath": "pygitup/utils/security.py",
      "language": "python",
      "size": 6067,
      "lines": 158,
      "lastModified": "2026-01-31T23:04:23.053Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
      "relativePath": "pygitup/utils/ui.py",
      "language": "python",
      "size": 9142,
      "lines": 226,
      "lastModified": "2026-02-01T16:08:01.295Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
      "relativePath": "pygitup/utils/update.py",
      "language": "python",
      "size": 3169,
      "lines": 77,
      "lastModified": "2026-02-01T15:43:13.975Z"
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
      "relativePath": "pygitup/utils/validation.py",
      "language": "python",
      "size": 1051,
      "lines": 41,
      "lastModified": "2026-01-31T21:35:58.205Z"
    }
  ],
  "modules": [
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup.py",
      "language": "python",
      "functions": [],
      "classes": [],
      "imports": [
        {
          "source": "sys",
          "specifiers": [
            "sys"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup.py",
          "line": 2
        },
        {
          "source": "pygitup.main",
          "specifiers": [
            "main"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup.py",
          "line": 3
        }
      ],
      "exports": [],
      "complexity": 1,
      "lines": 9
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/setup.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/setup.py",
      "language": "python",
      "functions": [],
      "classes": [],
      "imports": [
        {
          "source": "setuptools",
          "specifiers": [
            "setup",
            "find_packages"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/setup.py",
          "line": 1
        }
      ],
      "exports": [],
      "complexity": 1,
      "lines": 36
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/__init__.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/__init__.py",
      "language": "python",
      "functions": [],
      "classes": [],
      "imports": [],
      "exports": [],
      "complexity": 1,
      "lines": 2
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
      "language": "python",
      "functions": [
        {
          "id": "cad67e0dcece",
          "name": "main",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "startLine": 28,
          "endLine": 240,
          "lineCount": 213,
          "parameters": [],
          "calls": [
            "main",
            "show_banner",
            "check_for_updates",
            "create_parser",
            "parse_args",
            "load_config",
            "get",
            "print_info",
            "configuration_wizard",
            "get_github_username",
            "get_github_token",
            "process_offline_queue",
            "audit",
            "Intelligence",
            "Accounts",
            "display_menu",
            "max",
            "keys",
            "isdigit",
            "input",
            "choice",
            "print_error",
            "upload_project_directory",
            "upload_single_file",
            "upload_batch_files",
            "create_project_from_template",
            "create_release_tag",
            "update_multiple_repos",
            "scan_todos",
            "queue_offline_commit",
            "request_code_review",
            "smart_push",
            "generate_documentation",
            "generate_analytics",
            "manage_branches",
            "manage_stashes",
            "manage_tags",
            "cherry_pick_commit",
            "manage_gists",
            "manage_webhooks",
            "manage_actions",
            "manage_pull_requests",
            "run_audit",
            "manage_repo_visibility",
            "get_detailed_repo_info",
            "delete_repository",
            "manage_bulk_repositories",
            "migrate_repository",
            "parse_github_url",
            "get_fork_intelligence",
            "ai_commit_workflow",
            "print_header",
            "list_profiles",
            "get_active_profile_path",
            "basename",
            "replace",
            "set_active_profile",
            "print_success",
            "exit",
            "system"
          ],
          "calledBy": [],
          "complexity": 71,
          "isExported": false,
          "isAsync": false,
          "docstring": "Main function to orchestrate the process.",
          "body": "\ndef main():\n    \"\"\"Main function to orchestrate the process.\"\"\"\n    try:\n        show_banner()\n        check_for_updates()\n\n        # Parse command line arguments\n        parser = create_parser()\n        args = parser.parse_args()\n        \n        # Load configuration\n        config = load_config(args.config)\n        \n        # Auto-Setup Wizard if credentials missing\n        if not config[\"github\"].get(\"username\") or not config[\"github\"].get(\"token\"):\n            print_info(\"No existing credentials found. Starting stealth setup...\")\n            configuration_wizard()\n            # Reload after setup\n            config = load_config(args.config)\n\n        # Get credentials\n        github_username = get_github_username(config)\n        github_token = get_github_token(config)\n        \n        # Process offline queue if not in queue processing mode\n        if args.mode != \"process-queue\":\n            process_offline_queue(github_username, github_token, config)\n        \n        # Persistent loop for interactive mode\n        is_interactive = not args.mode\n        \n        while True:\n            # Determine mode\n            mode = args.mode\n            if not mode:\n                menu_options = {\n                    '1': (\"Upload/update a whole project directory\", \"project\"),\n                    '2': (\"Upload/update a single file\", \"file\"),\n                    '3': (\"Batch upload multiple files\", \"batch\"),\n                    '4': (\"Create project from template\", \"template\"),\n                    '5': (\"Create GitHub release\", \"release\"),\n                    '6': (\"Update file in multiple repositories\", \"multi-repo\"),\n                    '7': (\"Scan for TODOs and create issues\", \"scan-todos\"),\n                    '8': (\"Queue commit for offline\", \"offline-queue\"),\n                    '9': (\"Process offline commit queue\", \"process-queue\"),\n                    '10': (\"Request code review\", \"request-review\"),\n                    '11': (\"Smart push with commit squashing\", \"smart-push\"),\n                    '12': (\"Generate documentation\", \"generate-docs\"),\n                    '13': (\"Generate collaboration analytics\", \"analytics\"),\n                    '14': (\"Run the configuration wizard\", \"configure\"),\n                    '15': (\"Manage branches\", \"branch\"),\n                    '16': (\"Manage stashes\", \"stash\"),\n                    '17': (\"Manage tags\", \"tag\"),\n                    '18': (\"Cherry-pick a commit\", \"cherry-pick\"),\n                    '19': (\"Manage Gists\", \"gist\"),\n                    '20': (\"Manage Webhooks\", \"webhook\"),\n                    '21': (\"Manage GitHub Actions\", \"actions\"),\n                    '22': (\"Manage Pull Requests\", \"pr\"),\n                    '23': (\"Run security audit (Local + GitHub)\", \"audit\"),\n                    '24': (\"Change repository visibility\", \"visibility\"),\n                    '25': (\"Get repository info from URL\", \"repo-info\"),\n                    '26': (\"Delete GitHub repository\", \"delete-repo\"),\n                    '27': (\"Bulk Repository Management & Health\", \"bulk-mgmt\"),\n                    '28': (\"Migrate/Mirror Repository from any source\", \"migrate\"),\n                    '29': (\"Network & Fork Intelligence (OSINT)\", \"fork-intel\"),\n                    '30': (\"AI-Powered Semantic Commit\", \"ai-commit\"),\n                    '31': (\"Manage Accounts (Switch/Add/List)\", \"accounts\"),\n                    '0': (\"Exit PyGitUp\", \"exit\")\n                }\n\n                display_menu(menu_options)\n                max_choice = max([int(k) for k in menu_options.keys() if k.isdigit()])\n                choice = input(f\"\\nüëâ Enter your choice (0-{max_choice}): \")\n                \n                if choice == '0':\n                    print_info(\"Goodbye! üöÄ\")\n                    break\n\n                selected_option = menu_options.get(choice)\n                if not selected_option:\n                    print_error(\"Invalid choice. Try again.\")\n                    continue\n                mode = selected_option[1]\n\n            # Execute the corresponding function based on the mode\n            if mode == \"project\":\n                upload_project_directory(github_username, github_token, config, args)\n            elif mode == \"file\":\n                upload_single_file(github_username, github_token, config, args)\n            elif mode == \"batch\":\n                upload_batch_files(github_username, github_token, config, args)\n            elif mode == \"template\":\n                create_project_from_template(github_username, github_token, config, args)\n            elif mode == \"release\":\n                create_release_tag(github_username, github_token, config, args)\n            elif mode == \"multi-repo\":\n                update_multiple_repos(github_username, github_token, config, args)\n            elif mode == \"scan-todos\":\n                scan_todos(github_username, github_token, config, args)\n            elif mode == \"offline-queue\":\n                queue_offline_commit(config, args)\n            elif mode == \"process-queue\":\n                process_offline_queue(github_username, github_token, config, args)\n            elif mode == \"request-review\":\n                request_code_review(github_username, github_token, config, args)\n            elif mode == \"smart-push\":\n                smart_push(github_username, github_token, config, args)\n            elif mode == \"generate-docs\":\n                generate_documentation(github_username, github_token, config, args)\n            elif mode == \"analytics\":\n                generate_analytics(github_username, github_token, config, args)\n            elif mode == \"configure\":\n                configuration_wizard()\n                # Reload config after wizard\n                config = load_config(args.config)\n                github_username = get_github_username(config)\n                github_token = get_github_token(config)\n            elif mode == \"branch\":\n                manage_branches(args)\n            elif mode == \"stash\":\n                manage_stashes(args)\n            elif mode == \"tag\":\n                manage_tags(args)\n            elif mode == \"cherry-pick\":\n                cherry_pick_commit(args)\n            elif mode == \"gist\":\n                manage_gists(args, github_username, github_token)\n            elif mode == \"webhook\":\n                manage_webhooks(args, github_username, github_token)\n            elif mode == \"actions\":\n                manage_actions(args, github_username, github_token)\n            elif mode == \"pr\":\n                manage_pull_requests(args, github_username, github_token)\n            elif mode == \"audit\":\n                repo_to_audit = args.repo if args and hasattr(args, 'repo') and args.repo else input(\"Enter repo name for GitHub security scan: \")\n                run_audit(github_username, repo_to_audit, github_token)\n            elif mode == \"visibility\":\n                manage_repo_visibility(args, github_username, github_token)\n            elif mode == \"repo-info\":\n                get_detailed_repo_info(args, github_token)\n            elif mode == \"delete-repo\":\n                delete_repository(args, github_username, github_token)\n            elif mode == \"bulk-mgmt\":\n                manage_bulk_repositories(github_token)\n            elif mode == \"migrate\":\n                migrate_repository(github_username, github_token, config, args)\n            elif mode == \"fork-intel\":\n                url = args.url if args and hasattr(args, 'url') and args.url else input(\"Enter repository URL: \")\n                owner, repo_name = parse_github_url(url)\n                if owner and repo_name:\n                    get_fork_intelligence(owner, repo_name, github_token)\n                else:\n                    print_error(\"Invalid repository URL.\")\n            elif mode == \"ai-commit\":\n                ai_commit_workflow(github_username, github_token, config)\n            elif mode == \"accounts\":\n                print_header(\"Account & Profile Manager\")\n                profiles = list_profiles()\n                active_path = get_active_profile_path()\n                active_name = os.path.basename(active_path).replace(\".yaml\", \"\")\n\n                print_info(f\"Current Active Profile: [bold green]{active_name}[/bold green]\")\n                print(\"\\nAvailable Profiles:\")\n                for p in profiles:\n                    marker = \"‚ûú \" if p == active_name else \"  \"\n                    print(f\"{marker}{p}\")\n                \n                print(\"\\n[bold]Options:[/bold]\")\n                print(\"1: Switch Profile\")\n                print(\"2: Add New Account\")\n                print(\"3: Back\")\n                \n                acc_choice = input(\"\\nüëâ Choice: \")\n                if acc_choice == '1':\n                    target = input(\"Enter profile name to switch to: \")\n                    success, msg = set_active_profile(target)\n                    if success:\n                        print_success(msg)\n                        # Reload everything\n                        config = load_config(args.config)\n                        github_username = get_github_username(config)\n                        github_token = get_github_token(config)\n                    else:\n                        print_error(msg)\n                elif acc_choice == '2':\n                    configuration_wizard()\n                    config = load_config(args.config)\n                    github_username = get_github_username(config)\n                    github_token = get_github_token(config)\n            else:\n                print_error(\"Invalid mode selected.\")\n                if not is_interactive: sys.exit(1)\n\n            print_success(\"Operation complete.\")\n            \n            # If we were in CLI mode, exit loop after one operation\n            if not is_interactive:\n                break\n            \n            input(\"\\n‚å®Ô∏è  Press Enter to return to the menu...\")\n            # Clear screen for next iteration\n            import os\n            os.system('cls' if os.name == 'nt' else 'clear')\n            show_banner()\n    except KeyboardInterrupt:\n        print(\"\\n\")\n        print_info(\"PyGitUp interrupted by user. Exiting...\")\n        sys.exit(0)\n    except Exception as e:\n        print_error(f\"A critical error occurred: {e}\")\n        print_info(\"Please report this bug at: https://github.com/frederickabrah/PyGitup/issues\")\n        sys.exit(1)"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "sys",
          "specifiers": [
            "sys"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 1
        },
        {
          "source": ".core.args",
          "specifiers": [
            "create_parser"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 3
        },
        {
          "source": ".core.config",
          "specifiers": [
            "load_config",
            "get_github_username",
            "get_github_token",
            "configuration_wizard",
            "list_profiles",
            "set_active_profile",
            "get_active_profile_path"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 4
        },
        {
          "source": ".project.project_ops",
          "specifiers": [
            "upload_project_directory",
            "upload_single_file",
            "upload_batch_files",
            "update_multiple_repos",
            "manage_bulk_repositories",
            "migrate_repository"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 5
        },
        {
          "source": ".project.templates",
          "specifiers": [
            "create_project_from_template"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 6
        },
        {
          "source": ".github.releases",
          "specifiers": [
            "create_release_tag"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 7
        },
        {
          "source": ".project.issues",
          "specifiers": [
            "scan_todos"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 8
        },
        {
          "source": ".utils.offline",
          "specifiers": [
            "queue_offline_commit",
            "process_offline_queue"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 9
        },
        {
          "source": ".github.pull_requests",
          "specifiers": [
            "manage_pull_requests",
            "request_code_review"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 10
        },
        {
          "source": ".git.push",
          "specifiers": [
            "smart_push"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 11
        },
        {
          "source": ".project.docs",
          "specifiers": [
            "generate_documentation"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 12
        },
        {
          "source": ".utils.analytics",
          "specifiers": [
            "generate_analytics"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 13
        },
        {
          "source": ".utils.ai",
          "specifiers": [
            "ai_commit_workflow"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 14
        },
        {
          "source": ".git.branch",
          "specifiers": [
            "manage_branches"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 15
        },
        {
          "source": ".git.stash",
          "specifiers": [
            "manage_stashes"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 16
        },
        {
          "source": ".git.tag",
          "specifiers": [
            "manage_tags"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 17
        },
        {
          "source": ".git.cherry_pick",
          "specifiers": [
            "cherry_pick_commit"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 18
        },
        {
          "source": ".github.gists",
          "specifiers": [
            "manage_gists"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 19
        },
        {
          "source": ".github.webhooks",
          "specifiers": [
            "manage_webhooks"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 20
        },
        {
          "source": ".github.actions",
          "specifiers": [
            "manage_actions"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 21
        },
        {
          "source": ".utils.security",
          "specifiers": [
            "run_audit"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 22
        },
        {
          "source": ".github.repo",
          "specifiers": [
            "manage_repo_visibility",
            "delete_repository"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 23
        },
        {
          "source": ".github.repo_info",
          "specifiers": [
            "get_detailed_repo_info",
            "get_fork_intelligence",
            "parse_github_url"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 24
        },
        {
          "source": ".utils.banner",
          "specifiers": [
            "show_banner"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 25
        },
        {
          "source": ".utils.ui",
          "specifiers": [
            "display_menu",
            "print_error",
            "print_success",
            "print_info"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 26
        },
        {
          "source": ".utils.update",
          "specifiers": [
            "check_for_updates"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
          "line": 27
        }
      ],
      "exports": [],
      "complexity": 71,
      "lines": 240
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/tests/conftest.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/tests/conftest.py",
      "language": "python",
      "functions": [],
      "classes": [],
      "imports": [
        {
          "source": "sys",
          "specifiers": [
            "sys"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/conftest.py",
          "line": 1
        },
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/conftest.py",
          "line": 2
        }
      ],
      "exports": [],
      "complexity": 1,
      "lines": 6
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
      "language": "python",
      "functions": [
        {
          "id": "8d703f997e66",
          "name": "__init__",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
          "startLine": 18,
          "endLine": 24,
          "lineCount": 7,
          "parameters": [
            "name"
          ],
          "calls": [
            "__init__"
          ],
          "calledBy": [],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "body": "    def __init__(self, name):\n        \\\"\\\"\\\"\n        The constructor for MyClass.\n        :param name: The name of the instance.\n        \\\"\\\"\\\"\n        self.name = name\n"
        },
        {
          "id": "3c1a6af0a676",
          "name": "my_method",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
          "startLine": 24,
          "endLine": 32,
          "lineCount": 9,
          "parameters": [
            "value"
          ],
          "calls": [
            "my_method"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n    def my_method(self, value):\n        \\\"\\\"\\\"\n        A sample method within MyClass.\n        :param value: A value to process.\n        :return: A processed value.\n        \\\"\\\"\\\"\n        return value * 2\n"
        },
        {
          "id": "319deeaf08b2",
          "name": "my_function",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
          "startLine": 32,
          "endLine": 40,
          "lineCount": 9,
          "parameters": [
            "arg1",
            "arg2"
          ],
          "calls": [
            "my_function"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\ndef my_function(arg1, arg2='default'):\n    \\\"\\\"\\\"\n    A sample function outside any class.\n    :param arg1: The first argument.\n    :param arg2: The second argument with a default.\n    \\\"\\\"\\\"\n    return arg1 + arg2\n"
        },
        {
          "id": "cdf0160ec029",
          "name": "test_extract_python_docs_module_docstring",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
          "startLine": 50,
          "endLine": 54,
          "lineCount": 5,
          "parameters": [],
          "calls": [
            "test_extract_python_docs_module_docstring",
            "extract_python_docs",
            "strip"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\ndef test_extract_python_docs_module_docstring():\n    docs = extract_python_docs(SAMPLE_PYTHON_CODE, \"sample.py\")\n    assert docs['module_docstring'].strip() == \"This is a module docstring.\\nIt explains the purpose of the module.\"\n"
        },
        {
          "id": "c50e2b3c1ae7",
          "name": "test_extract_python_docs_functions",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
          "startLine": 54,
          "endLine": 63,
          "lineCount": 10,
          "parameters": [],
          "calls": [
            "test_extract_python_docs_functions",
            "extract_python_docs",
            "next"
          ],
          "calledBy": [],
          "complexity": 3,
          "isExported": false,
          "isAsync": false,
          "body": "\ndef test_extract_python_docs_functions():\n    docs = extract_python_docs(SAMPLE_PYTHON_CODE, \"sample.py\")\n    \n    # Test my_function\n    func = next((f for f in docs['functions'] if f['name'] == 'my_function'), None)\n    assert func is not None\n    assert func['params'] == 'arg1, arg2'\n    assert \"A sample function outside any class.\" in func['docstring']\n"
        },
        {
          "id": "c2cd9c47dd19",
          "name": "test_extract_python_docs_classes",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
          "startLine": 63,
          "endLine": 88,
          "lineCount": 26,
          "parameters": [],
          "calls": [
            "test_extract_python_docs_classes",
            "extract_python_docs",
            "next"
          ],
          "calledBy": [],
          "complexity": 10,
          "isExported": false,
          "isAsync": false,
          "body": "\ndef test_extract_python_docs_classes():\n    docs = extract_python_docs(SAMPLE_PYTHON_CODE, \"sample.py\")\n    \n    # Test MyClass\n    cls = next((c for c in docs['classes'] if c['name'] == 'MyClass'), None)\n    assert cls is not None\n    assert cls['parent'] == 'object'\n    assert \"A sample class to demonstrate AST parsing.\" in cls['docstring']\n    \n    # Test MyClass methods\n    init_method = next((m for m in cls['methods'] if m['name'] == '__init__'), None)\n    assert init_method is not None\n    assert init_method['params'] == 'self, name'\n    assert \"The constructor for MyClass.\" in init_method['docstring']\n\n    my_method = next((m for m in cls['methods'] if m['name'] == 'my_method'), None)\n    assert my_method is not None\n    assert my_method['params'] == 'self, value'\n    assert \"A sample method within MyClass.\" in my_method['docstring']\n\n    # Test AnotherClass\n    another_cls = next((c for c in docs['classes'] if c['name'] == 'AnotherClass'), None)\n    assert another_cls is not None\n    assert another_cls['parent'] == 'object' # Default parent\n    assert \"Another class with no explicit base.\" in another_cls['docstring']"
        }
      ],
      "classes": [
        {
          "id": "321a2ce9fd8f",
          "name": "MyClass",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
          "startLine": 13,
          "endLine": 32,
          "methods": [
            "__init__",
            "my_method"
          ],
          "properties": [
            "name"
          ],
          "parents": [],
          "isExported": false
        },
        {
          "id": "d4bc0c0d59fb",
          "name": "AnotherClass",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
          "startLine": 40,
          "endLine": 46,
          "methods": [],
          "properties": [],
          "parents": [],
          "isExported": false
        }
      ],
      "imports": [
        {
          "source": "pytest",
          "specifiers": [
            "pytest"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
          "line": 2
        },
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
          "line": 12
        },
        {
          "source": "pygitup.project.docs",
          "specifiers": [
            "extract_python_docs"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
          "line": 3
        }
      ],
      "exports": [],
      "complexity": 3,
      "lines": 89
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
      "language": "python",
      "functions": [
        {
          "id": "c187ab92c4f2",
          "name": "test_create_parser",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "startLine": 19,
          "endLine": 22,
          "lineCount": 4,
          "parameters": [],
          "calls": [
            "test_create_parser",
            "create_parser",
            "assertIsInstance"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "    def test_create_parser(self):\n        parser = create_parser()\n        self.assertIsInstance(parser, argparse.ArgumentParser)\n"
        },
        {
          "id": "900ceb8b2016",
          "name": "test_load_config_default",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "startLine": 22,
          "endLine": 27,
          "lineCount": 6,
          "parameters": [],
          "calls": [
            "test_load_config_default",
            "load_config",
            "assertEqual"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n    def test_load_config_default(self):\n        # Test loading default config when no file exists\n        config = load_config(\"non_existent_file.yaml\")\n        self.assertEqual(config, DEFAULT_CONFIG)\n"
        },
        {
          "id": "d58b10bba610",
          "name": "test_load_config_custom",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "startLine": 27,
          "endLine": 55,
          "lineCount": 29,
          "parameters": [],
          "calls": [
            "test_load_config_custom",
            "open",
            "dump",
            "load_config",
            "assertEqual",
            "remove"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n    def test_load_config_custom(self):\n        # Create a dummy config file\n        custom_config_data = {\n            \"defaults\": {\n                \"commit_message\": \"Test commit message\",\n                \"branch\": \"develop\"\n            },\n            \"github\": {\n                \"username\": \"testuser\"\n            }\n        }\n        with open(\"test_config.yaml\", \"w\") as f:\n            yaml.dump(custom_config_data, f)\n\n        # Test loading the custom config\n        config = load_config(\"test_config.yaml\")\n\n        # Check that the custom values are loaded\n        self.assertEqual(config[\"defaults\"][\"commit_message\"], \"Test commit message\")\n        self.assertEqual(config[\"defaults\"][\"branch\"], \"develop\")\n        self.assertEqual(config[\"github\"][\"username\"], \"testuser\")\n\n        # Check that the other values are the defaults\n        self.assertEqual(config[\"batch\"][\"max_files\"], DEFAULT_CONFIG[\"batch\"][\"max_files\"])\n\n        # Clean up the dummy config file\n        os.remove(\"test_config.yaml\")\n"
        },
        {
          "id": "918666a425f8",
          "name": "test_get_github_token_from_file",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "startLine": 55,
          "endLine": 71,
          "lineCount": 17,
          "parameters": [],
          "calls": [
            "test_get_github_token_from_file",
            "open",
            "write",
            "get_github_token",
            "assertEqual",
            "remove"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n    def test_get_github_token_from_file(self):\n        # Create a dummy token file\n        with open(\"test_token.txt\", \"w\") as f:\n            f.write(\"test_token_from_file\")\n\n        config = {\n            \"github\": {\n                \"token_file\": \"test_token.txt\"\n            }\n        }\n        token = get_github_token(config)\n        self.assertEqual(token, \"test_token_from_file\")\n\n        # Clean up the dummy token file\n        os.remove(\"test_token.txt\")\n"
        },
        {
          "id": "86b1d0cf1c48",
          "name": "test_get_github_token_from_env",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "startLine": 71,
          "endLine": 86,
          "lineCount": 16,
          "parameters": [],
          "calls": [
            "test_get_github_token_from_env",
            "get_github_token",
            "assertEqual"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n    def test_get_github_token_from_env(self):\n        # Set an environment variable\n        os.environ[\"GITHUB_TOKEN\"] = \"test_token_from_env\"\n\n        config = {\n            \"github\": {\n                \"token_file\": \"\"\n            }\n        }\n        token = get_github_token(config)\n        self.assertEqual(token, \"test_token_from_env\")\n\n        # Unset the environment variable\n        del os.environ[\"GITHUB_TOKEN\"]\n"
        },
        {
          "id": "a4a0df0df6d3",
          "name": "test_get_github_username_from_config",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "startLine": 86,
          "endLine": 95,
          "lineCount": 10,
          "parameters": [],
          "calls": [
            "test_get_github_username_from_config",
            "get_github_username",
            "assertEqual"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n    def test_get_github_username_from_config(self):\n        config = {\n            \"github\": {\n                \"username\": \"testuser_from_config\"\n            }\n        }\n        username = get_github_username(config)\n        self.assertEqual(username, \"testuser_from_config\")\n"
        },
        {
          "id": "f12bbe815d45",
          "name": "test_get_github_username_from_env",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "startLine": 95,
          "endLine": 110,
          "lineCount": 16,
          "parameters": [],
          "calls": [
            "test_get_github_username_from_env",
            "get_github_username",
            "assertEqual"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n    def test_get_github_username_from_env(self):\n        # Set an environment variable\n        os.environ[\"GITHUB_USERNAME\"] = \"testuser_from_env\"\n\n        config = {\n            \"github\": {\n                \"username\": \"\"\n            }\n        }\n        username = get_github_username(config)\n        self.assertEqual(username, \"testuser_from_env\")\n\n        # Unset the environment variable\n        del os.environ[\"GITHUB_USERNAME\"]\n"
        },
        {
          "id": "cd26c0773f45",
          "name": "test_get_repo_info",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "startLine": 112,
          "endLine": 131,
          "lineCount": 20,
          "parameters": [
            "mock_request"
          ],
          "calls": [
            "test_get_repo_info",
            "Mock",
            "get_repo_info",
            "assert_called_once_with",
            "assertEqual"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "    def test_get_repo_info(self, mock_request):\n        # Set up the mock response\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.json.return_value = {\"name\": \"test-repo\", \"description\": \"A test repo\"}\n        mock_request.return_value = mock_response\n\n        # Call the function\n        response = get_repo_info(\"testuser\", \"test-repo\", \"test_token\")\n\n        # Assert that requests.request was called correctly\n        mock_request.assert_called_once_with(\n            \"GET\",\n            \"https://api.github.com/repos/testuser/test-repo\",\n            headers={\"Authorization\": \"token test_token\", \"Accept\": \"application/vnd.github.v3+json\"}\n        )\n\n        # Assert that the function returns the mock response\n        self.assertEqual(response, mock_response)\n"
        },
        {
          "id": "ea310d7744bd",
          "name": "test_create_repo",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "startLine": 133,
          "endLine": 153,
          "lineCount": 21,
          "parameters": [
            "mock_request"
          ],
          "calls": [
            "test_create_repo",
            "Mock",
            "create_repo",
            "assert_called_once_with",
            "assertEqual"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "    def test_create_repo(self, mock_request):\n        # Set up the mock response\n        mock_response = Mock()\n        mock_response.status_code = 201\n        mock_response.json.return_value = {\"name\": \"test-repo\", \"html_url\": \"https://github.com/testuser/test-repo\"}\n        mock_request.return_value = mock_response\n\n        # Call the function\n        response = create_repo(\"testuser\", \"test-repo\", \"test_token\", description=\"A test repo\", private=True)\n\n        # Assert that requests.request was called correctly\n        mock_request.assert_called_once_with(\n            \"POST\",\n            \"https://api.github.com/user/repos\",\n            headers={\"Authorization\": \"token test_token\", \"Accept\": \"application/vnd.github.v3+json\"},\n            json={\"name\": \"test-repo\", \"description\": \"A test repo\", \"private\": True}\n        )\n\n        # Assert that the function returns the mock response\n        self.assertEqual(response, mock_response)\n"
        },
        {
          "id": "56eb7f277de9",
          "name": "test_update_file",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "startLine": 155,
          "endLine": 177,
          "lineCount": 23,
          "parameters": [
            "mock_request"
          ],
          "calls": [
            "test_update_file",
            "Mock",
            "update_file",
            "b64encode",
            "decode",
            "assert_called_once_with",
            "assertEqual"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "    def test_update_file(self, mock_request):\n        # Set up the mock response\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.json.return_value = {\"commit\": {\"sha\": \"12345\"}}\n        mock_request.return_value = mock_response\n\n        # Call the function\n        content = b\"Hello, World!\"\n        response = update_file(\"testuser\", \"test-repo\", \"hello.txt\", content, \"test_token\", \"Update hello.txt\", sha=\"abcde\")\n\n        # Assert that requests.request was called correctly\n        encoded_content = base64.b64encode(content).decode('utf-8')\n        mock_request.assert_called_once_with(\n            \"PUT\",\n            \"https://api.github.com/repos/testuser/test-repo/contents/hello.txt\",\n            headers={\"Authorization\": \"token test_token\", \"Accept\": \"application/vnd.github.v3+json\"},\n            json={\"message\": \"Update hello.txt\", \"content\": encoded_content, \"sha\": \"abcde\"}\n        )\n\n        # Assert that the function returns the mock response\n        self.assertEqual(response, mock_response)\n"
        },
        {
          "id": "2e314dc6c749",
          "name": "test_generate_changelog",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "startLine": 179,
          "endLine": 205,
          "lineCount": 27,
          "parameters": [
            "mock_get_commit_history"
          ],
          "calls": [
            "test_generate_changelog",
            "Mock",
            "generate_changelog",
            "feature",
            "bug",
            "assertEqual"
          ],
          "calledBy": [],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "body": "    def test_generate_changelog(self, mock_get_commit_history):\n        # Set up the mock response\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.json.return_value = [\n            {\n                \"commit\": {\n                    \"message\": \"feat: Add new feature\",\n                    \"author\": {\"name\": \"Test User\", \"date\": \"2025-09-27T10:00:00Z\"}\n                }\n            },\n            {\n                \"commit\": {\n                    \"message\": \"fix: Fix a bug\",\n                    \"author\": {\"name\": \"Test User\", \"date\": \"2025-09-26T10:00:00Z\"}\n                }\n            }\n        ]\n        mock_get_commit_history.return_value = mock_response\n\n        # Call the function\n        changelog = generate_changelog(\"testuser\", \"test-repo\", \"test_token\", \"v1.0.0\")\n\n        # Assert that the changelog is correct\n        expected_changelog = \"## Changelog for v1.0.0\\n\\n- feat: Add new feature (Test User on 2025-09-27)\\n- fix: Fix a bug (Test User on 2025-09-26)\\n\"\n        self.assertEqual(changelog, expected_changelog)\n"
        }
      ],
      "classes": [
        {
          "id": "a50d898502e6",
          "name": "TestPygitup",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "startLine": 17,
          "endLine": 205,
          "methods": [
            "test_create_parser",
            "test_load_config_default",
            "test_load_config_custom",
            "test_get_github_token_from_file",
            "test_get_github_token_from_env",
            "test_get_github_username_from_config",
            "test_get_github_username_from_env",
            "test_get_repo_info",
            "test_create_repo",
            "test_update_file",
            "test_generate_changelog"
          ],
          "properties": [],
          "parents": [
            "unittest.TestCase"
          ],
          "isExported": false
        }
      ],
      "imports": [
        {
          "source": "unittest",
          "specifiers": [
            "unittest"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "line": 1
        },
        {
          "source": "argparse",
          "specifiers": [
            "argparse"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "line": 2
        },
        {
          "source": "sys",
          "specifiers": [
            "sys"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "line": 3
        },
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "line": 4
        },
        {
          "source": "yaml",
          "specifiers": [
            "yaml"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "line": 5
        },
        {
          "source": "base64",
          "specifiers": [
            "base64"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "line": 6
        },
        {
          "source": "unittest.mock",
          "specifiers": [
            "patch",
            "Mock"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "line": 7
        },
        {
          "source": "pygitup.core.args",
          "specifiers": [
            "create_parser"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "line": 13
        },
        {
          "source": "pygitup.core.config",
          "specifiers": [
            "load_config",
            "DEFAULT_CONFIG",
            "get_github_token",
            "get_github_username"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "line": 14
        },
        {
          "source": "pygitup.github.api",
          "specifiers": [
            "get_repo_info",
            "create_repo",
            "update_file"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "line": 15
        },
        {
          "source": "pygitup.github.releases",
          "specifiers": [
            "generate_changelog"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
          "line": 16
        }
      ],
      "exports": [],
      "complexity": 1,
      "lines": 207
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
      "language": "python",
      "functions": [
        {
          "id": "ffdece382d71",
          "name": "hello_world",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
          "startLine": 5,
          "endLine": 17,
          "lineCount": 13,
          "parameters": [
            "name"
          ],
          "calls": [
            "hello_world",
            "name"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Print a greeting to the specified name.\n    \n    Args:\n        name (str): The name to greet\n        \n    Returns:\n        None",
          "body": "\ndef hello_world(name):\n    \"\"\"\n    Print a greeting to the specified name.\n    \n    Args:\n        name (str): The name to greet\n        \n    Returns:\n        None\n    \"\"\"\n    print(f\"Hello, {name}!\")\n"
        },
        {
          "id": "8e386020b8b3",
          "name": "add_numbers",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
          "startLine": 17,
          "endLine": 30,
          "lineCount": 14,
          "parameters": [
            "a",
            "b"
          ],
          "calls": [
            "add_numbers",
            "a",
            "b"
          ],
          "calledBy": [],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Add two numbers together.\n    \n    Args:\n        a (int): First number\n        b (int): Second number\n        \n    Returns:\n        int: The sum of a and b",
          "body": "\ndef add_numbers(a, b):\n    \"\"\"\n    Add two numbers together.\n    \n    Args:\n        a (int): First number\n        b (int): Second number\n        \n    Returns:\n        int: The sum of a and b\n    \"\"\"\n    return a + b\n"
        },
        {
          "id": "2d2da2377db8",
          "name": "__init__",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
          "startLine": 35,
          "endLine": 36,
          "lineCount": 2,
          "parameters": [],
          "calls": [
            "__init__"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "    \n    def __init__(self):"
        },
        {
          "id": "843942cc1c44",
          "name": "multiply",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
          "startLine": 39,
          "endLine": 40,
          "lineCount": 2,
          "parameters": [
            "x",
            "y"
          ],
          "calls": [
            "multiply"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "    \n    def multiply(self, x, y):"
        }
      ],
      "classes": [
        {
          "id": "da721a7f9c8c",
          "name": "Calculator",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
          "startLine": 30,
          "endLine": 51,
          "methods": [
            "__init__",
            "multiply"
          ],
          "properties": [],
          "parents": [],
          "isExported": false
        }
      ],
      "imports": [],
      "exports": [],
      "complexity": 1,
      "lines": 51
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/__init__.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/__init__.py",
      "language": "python",
      "functions": [],
      "classes": [],
      "imports": [],
      "exports": [],
      "complexity": 1,
      "lines": 1
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/args.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/args.py",
      "language": "python",
      "functions": [
        {
          "id": "8ecc4f2a4045",
          "name": "create_parser",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/args.py",
          "startLine": 3,
          "endLine": 9,
          "lineCount": 7,
          "parameters": [],
          "calls": [
            "create_parser",
            "ArgumentParser"
          ],
          "calledBy": [
            "cad67e0dcece",
            "c187ab92c4f2"
          ],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Create and configure the argument parser.",
          "body": "\ndef create_parser():\n    \"\"\"Create and configure the argument parser.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"PyGitUp - Effortless GitHub Uploads\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\""
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "argparse",
          "specifiers": [
            "argparse"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/args.py",
          "line": 2
        }
      ],
      "exports": [],
      "complexity": 2,
      "lines": 151
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
      "language": "python",
      "functions": [
        {
          "id": "d65e9cd040cc",
          "name": "get_config_dir",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
          "startLine": 44,
          "endLine": 64,
          "lineCount": 21,
          "parameters": [],
          "calls": [
            "get_config_dir",
            "expanduser",
            "join",
            "exists",
            "makedirs"
          ],
          "calledBy": [],
          "complexity": 3,
          "isExported": false,
          "isAsync": false,
          "docstring": "Returns the platform-specific hidden directory for PyGitUp config.",
          "body": "\ndef get_config_dir():\n\n    \"\"\"Returns the platform-specific hidden directory for PyGitUp config.\"\"\"\n\n    home = os.path.expanduser(\"~\")\n\n    config_dir = os.path.join(home, \".pygitup_config\")\n\n    profiles_dir = os.path.join(config_dir, \"profiles\")\n\n    \n\n    if not os.path.exists(profiles_dir):\n\n        os.makedirs(profiles_dir, exist_ok=True)\n\n    return config_dir\n\n\n"
        },
        {
          "id": "f3bb89e569dd",
          "name": "get_active_profile_path",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
          "startLine": 62,
          "endLine": 64,
          "lineCount": 3,
          "parameters": [],
          "calls": [],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n\n"
        },
        {
          "id": "2b972eff3796",
          "name": "set_active_profile",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
          "startLine": 94,
          "endLine": 96,
          "lineCount": 3,
          "parameters": [
            "profile_name"
          ],
          "calls": [],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n\n"
        },
        {
          "id": "470391cb22b0",
          "name": "list_profiles",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
          "startLine": 126,
          "endLine": 128,
          "lineCount": 3,
          "parameters": [],
          "calls": [],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n\n"
        },
        {
          "id": "76fd775187dc",
          "name": "load_config",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
          "startLine": 136,
          "endLine": 138,
          "lineCount": 3,
          "parameters": [
            "config_path"
          ],
          "calls": [],
          "calledBy": [
            "cad67e0dcece",
            "900ceb8b2016",
            "d58b10bba610"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n\n"
        },
        {
          "id": "4c6a9058fc9b",
          "name": "get_github_token",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
          "startLine": 178,
          "endLine": 180,
          "lineCount": 3,
          "parameters": [
            "config"
          ],
          "calls": [],
          "calledBy": [
            "cad67e0dcece",
            "918666a425f8",
            "86b1d0cf1c48"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n\n"
        },
        {
          "id": "a647d0933dd8",
          "name": "get_github_username",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
          "startLine": 222,
          "endLine": 224,
          "lineCount": 3,
          "parameters": [
            "config"
          ],
          "calls": [],
          "calledBy": [
            "cad67e0dcece",
            "a4a0df0df6d3",
            "f12bbe815d45",
            "09ae5dd659db"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n\n"
        },
        {
          "id": "4c3d0e0cf92c",
          "name": "configuration_wizard",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
          "startLine": 244,
          "endLine": 246,
          "lineCount": 3,
          "parameters": [
            "profile_name"
          ],
          "calls": [],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\n\n"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
          "line": 2
        },
        {
          "source": "yaml",
          "specifiers": [
            "yaml"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
          "line": 3
        },
        {
          "source": "getpass",
          "specifiers": [
            "getpass"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
          "line": 4
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header",
            "print_warning"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
          "line": 5
        }
      ],
      "exports": [],
      "complexity": 1,
      "lines": 310
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/__init__.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/__init__.py",
      "language": "python",
      "functions": [],
      "classes": [],
      "imports": [],
      "exports": [],
      "complexity": 1,
      "lines": 1
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/branch.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/branch.py",
      "language": "python",
      "functions": [
        {
          "id": "c5fcd19ff943",
          "name": "manage_branches",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/branch.py",
          "startLine": 4,
          "endLine": 57,
          "lineCount": 54,
          "parameters": [
            "args"
          ],
          "calls": [
            "manage_branches",
            "print_header",
            "List",
            "prompt",
            "Text",
            "print_info",
            "run",
            "print_error",
            "print_success"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 18,
          "isExported": false,
          "isAsync": false,
          "docstring": "Handle branch management operations with styled output.",
          "body": "\ndef manage_branches(args):\n    \"\"\"Handle branch management operations with styled output.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    branch_name = args.branch_name if hasattr(args, 'branch_name') and args.branch_name else None\n\n    if not action:\n        print_header(\"Branch Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What branch operation would you like to perform?\",\n                choices=[\"list\", \"create\", \"delete\", \"switch\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if action in [\"create\", \"delete\", \"switch\"]:\n            branch_questions = [\n                inquirer.Text(\"branch_name\", message=f\"Enter the name of the branch to {action}\")\n            ]\n            branch_answers = inquirer.prompt(branch_questions)\n            branch_name = branch_answers[\"branch_name\"]\n\n    try:\n        if action == \"list\":\n            print_info(\"Listing all local branches:\")\n            subprocess.run([\"git\", \"branch\"], check=True)\n        elif action == \"create\":\n            if not branch_name:\n                print_error(\"Branch name is required.\")\n                return\n            print_info(f\"Creating new branch: {branch_name}\")\n            subprocess.run([\"git\", \"branch\", branch_name], check=True)\n            print_success(f\"Branch '{branch_name}' created.\")\n        elif action == \"delete\":\n            if not branch_name:\n                print_error(\"Branch name is required.\")\n                return\n            print_info(f\"Deleting branch: {branch_name}\")\n            subprocess.run([\"git\", \"branch\", \"-d\", branch_name], check=True)\n            print_success(f\"Branch '{branch_name}' deleted.\")\n        elif action == \"switch\":\n            if not branch_name:\n                print_error(\"Branch name is required.\")\n                return\n            print_info(f\"Switching to branch: {branch_name}\")\n            subprocess.run([\"git\", \"checkout\", branch_name], check=True)\n            print_success(f\"Switched to branch '{branch_name}'.\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "subprocess",
          "specifiers": [
            "subprocess"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/branch.py",
          "line": 1
        },
        {
          "source": "inquirer",
          "specifiers": [
            "inquirer"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/branch.py",
          "line": 2
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/branch.py",
          "line": 3
        }
      ],
      "exports": [],
      "complexity": 18,
      "lines": 57
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/cherry_pick.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/cherry_pick.py",
      "language": "python",
      "functions": [
        {
          "id": "78e970b9d9ad",
          "name": "cherry_pick_commit",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/cherry_pick.py",
          "startLine": 4,
          "endLine": 27,
          "lineCount": 24,
          "parameters": [
            "args"
          ],
          "calls": [
            "cherry_pick_commit",
            "print_header",
            "Text",
            "prompt",
            "print_error",
            "print_info",
            "run",
            "print_success"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 5,
          "isExported": false,
          "isAsync": false,
          "docstring": "Cherry-pick a commit with styled output.",
          "body": "\ndef cherry_pick_commit(args):\n    \"\"\"Cherry-pick a commit with styled output.\"\"\"\n    commit_hash = args.commit_hash\n    if not commit_hash:\n        print_header(\"Cherry-Pick Commit\")\n        questions = [\n            inquirer.Text(\"commit_hash\", message=\"Enter the hash of the commit to cherry-pick\")\n        ]\n        answers = inquirer.prompt(questions)\n        commit_hash = answers[\"commit_hash\"]\n\n    if not commit_hash:\n        print_error(\"No commit hash provided. Exiting.\")\n        return\n\n    try:\n        print_info(f\"Cherry-picking commit: {commit_hash}\")\n        subprocess.run([\"git\", \"cherry-pick\", commit_hash], check=True)\n        print_success(f\"Successfully cherry-picked {commit_hash}\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "subprocess",
          "specifiers": [
            "subprocess"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/cherry_pick.py",
          "line": 1
        },
        {
          "source": "inquirer",
          "specifiers": [
            "inquirer"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/cherry_pick.py",
          "line": 2
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/cherry_pick.py",
          "line": 3
        }
      ],
      "exports": [],
      "complexity": 5,
      "lines": 27
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/push.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/push.py",
      "language": "python",
      "functions": [
        {
          "id": "f1f948b57bf3",
          "name": "smart_push",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/push.py",
          "startLine": 3,
          "endLine": 74,
          "lineCount": 72,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "smart_push",
            "print_info",
            "input",
            "split",
            "squash",
            "run",
            "strip",
            "lower",
            "append",
            "print_success",
            "join",
            "print_warning",
            "print_error"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 20,
          "isExported": false,
          "isAsync": false,
          "docstring": "Smart push that squashes meaningless commits with styled output.",
          "body": "\ndef smart_push(github_username, github_token, config, args=None):\n    \"\"\"Smart push that squashes meaningless commits with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would perform a smart push with commit squashing.\")\n        return\n\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n\n    # Get squash patterns\n    if args and args.squash_pattern:\n        patterns = args.squash_pattern.split(\",\")\n    else:\n        patterns_input = input(\"Enter commit message patterns to squash (comma-separated): \")\n        patterns = patterns_input.split(\",\") if patterns_input else [\"typo\", \"fix\", \"update\"]\n\n    print_info(f\"Smart pushing to {repo_name} with squash patterns: {patterns}\")\n\n    try:\n        # Get the last 10 commits\n        log_result = subprocess.run([\"git\", \"log\", \"--oneline\", \"-n\", \"10\"], capture_output=True, text=True, check=True)\n        commits = log_result.stdout.strip().split(\"\\n\")\n\n        # Identify commits to squash\n        commits_to_squash = []\n        for commit in commits:\n            parts = commit.split(\" \", 1)\n            if len(parts) < 2: continue\n            commit_hash, commit_message = parts\n            for pattern in patterns:\n                if pattern.lower() in commit_message.lower():\n                    commits_to_squash.append(commit_hash)\n                    break\n\n        if not commits_to_squash:\n            print_info(\"No commits to squash. Pushing normally.\")\n            subprocess.run([\"git\", \"push\"], check=True)\n            print_success(\"Pushed to GitHub.\")\n            return\n\n        print_info(f\"Found {len(commits_to_squash)} commits to squash: {commits_to_squash}\")\n\n        # The parent of the oldest commit to be squashed\n        squash_base = f\"{commits_to_squash[-1]}~\"\n\n        # Get the messages of the commits being squashed for the new commit message\n        squashed_messages = []\n        for commit_hash in reversed(commits_to_squash):\n            msg = subprocess.run([\"git\", \"log\", \"--format=%B\", \"-n\", \"1\", commit_hash], capture_output=True, text=True, check=True).stdout.strip()\n            squashed_messages.append(msg)\n\n        new_commit_message = f\"Squashed {len(squashed_messages)} commits\\n\\n\" + \"\\n\".join(f\"- {msg}\" for msg in squashed_messages)\n\n        print_info(f\"Resetting to {squash_base} and preparing to squash.\")\n        subprocess.run([\"git\", \"reset\", \"--soft\", squash_base], check=True)\n\n        print_info(\"Creating new squashed commit.\")\n        subprocess.run([\"git\", \"commit\", \"-m\", new_commit_message], check=True)\n\n        print_warning(\"Force-pushing the new history. This will overwrite the remote history.\")\n        subprocess.run([\"git\", \"push\", \"--force-with-lease\"], check=True)\n\n        print_success(\"Smart push complete.\")\n\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "subprocess",
          "specifiers": [
            "subprocess"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/push.py",
          "line": 1
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header",
            "print_warning"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/push.py",
          "line": 2
        }
      ],
      "exports": [],
      "complexity": 20,
      "lines": 74
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/stash.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/stash.py",
      "language": "python",
      "functions": [
        {
          "id": "c655144f401e",
          "name": "manage_stashes",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/stash.py",
          "startLine": 4,
          "endLine": 55,
          "lineCount": 52,
          "parameters": [
            "args"
          ],
          "calls": [
            "manage_stashes",
            "print_header",
            "List",
            "prompt",
            "Text",
            "append",
            "print_info",
            "run",
            "print_success",
            "print_error"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 19,
          "isExported": false,
          "isAsync": false,
          "docstring": "Handle stash management operations with styled output.",
          "body": "\ndef manage_stashes(args):\n    \"\"\"Handle stash management operations with styled output.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    message = args.message if hasattr(args, 'message') and args.message else None\n\n    if not action:\n        print_header(\"Stash Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What stash operation would you like to perform?\",\n                choices=[\"save\", \"list\", \"apply\", \"pop\", \"drop\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if action == \"save\":\n            stash_questions = [\n                inquirer.Text(\"message\", message=\"Enter an optional message for the stash\")\n            ]\n            stash_answers = inquirer.prompt(stash_questions)\n            message = stash_answers[\"message\"]\n\n    try:\n        if action == \"save\":\n            command = [\"git\", \"stash\", \"save\"]\n            if message:\n                command.append(message)\n            print_info(\"Saving current changes to a new stash.\")\n            subprocess.run(command, check=True)\n            print_success(\"Changes stashed.\")\n        elif action == \"list\":\n            print_info(\"Listing all stashes:\")\n            subprocess.run([\"git\", \"stash\", \"list\"], check=True)\n        elif action == \"apply\":\n            print_info(\"Applying the latest stash.\")\n            subprocess.run([\"git\", \"stash\", \"apply\"], check=True)\n            print_success(\"Stash applied.\")\n        elif action == \"pop\":\n            print_info(\"Applying the latest stash and dropping it from the list.\")\n            subprocess.run([\"git\", \"stash\", \"pop\"], check=True)\n            print_success(\"Stash popped.\")\n        elif action == \"drop\":\n            print_info(\"Dropping the latest stash.\")\n            subprocess.run([\"git\", \"stash\", \"drop\"], check=True)\n            print_success(\"Stash dropped.\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "subprocess",
          "specifiers": [
            "subprocess"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/stash.py",
          "line": 1
        },
        {
          "source": "inquirer",
          "specifiers": [
            "inquirer"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/stash.py",
          "line": 2
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/stash.py",
          "line": 3
        }
      ],
      "exports": [],
      "complexity": 19,
      "lines": 55
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/tag.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/tag.py",
      "language": "python",
      "functions": [
        {
          "id": "ebb909c21ccf",
          "name": "manage_tags",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/tag.py",
          "startLine": 4,
          "endLine": 63,
          "lineCount": 60,
          "parameters": [
            "args"
          ],
          "calls": [
            "manage_tags",
            "print_header",
            "List",
            "prompt",
            "Text",
            "print_info",
            "run",
            "print_error",
            "extend",
            "append",
            "print_success"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 22,
          "isExported": false,
          "isAsync": false,
          "docstring": "Handle tag management operations with styled output.",
          "body": "\ndef manage_tags(args):\n    \"\"\"Handle tag management operations with styled output.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    tag_name = args.tag_name if hasattr(args, 'tag_name') and args.tag_name else None\n    message = args.message if hasattr(args, 'message') and args.message else None\n\n    if not action:\n        print_header(\"Tag Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What tag operation would you like to perform?\",\n                choices=[\"list\", \"create\", \"delete\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if action in [\"create\", \"delete\"]:\n            tag_questions = [\n                inquirer.Text(\"tag_name\", message=f\"Enter the name of the tag to {action}\")\n            ]\n            tag_answers = inquirer.prompt(tag_questions)\n            tag_name = tag_answers[\"tag_name\"]\n\n        if action == \"create\":\n            message_questions = [\n                inquirer.Text(\"message\", message=\"Enter an optional annotation message for the tag\")\n            ]\n            message_answers = inquirer.prompt(message_questions)\n            message = message_answers[\"message\"]\n\n    try:\n        if action == \"list\":\n            print_info(\"Listing all tags:\")\n            subprocess.run([\"git\", \"tag\"], check=True)\n        elif action == \"create\":\n            if not tag_name:\n                print_error(\"Tag name is required.\")\n                return\n            command = [\"git\", \"tag\"]\n            if message:\n                command.extend([\"-a\", tag_name, \"-m\", message])\n            else:\n                command.append(tag_name)\n            print_info(f\"Creating new tag: {tag_name}\")\n            subprocess.run(command, check=True)\n            print_success(f\"Tag '{tag_name}' created.\")\n        elif action == \"delete\":\n            if not tag_name:\n                print_error(\"Tag name is required.\")\n                return\n            print_info(f\"Deleting tag: {tag_name}\")\n            subprocess.run([\"git\", \"tag\", \"-d\", tag_name], check=True)\n            print_success(f\"Tag '{tag_name}' deleted.\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "subprocess",
          "specifiers": [
            "subprocess"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/tag.py",
          "line": 1
        },
        {
          "source": "inquirer",
          "specifiers": [
            "inquirer"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/tag.py",
          "line": 2
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/tag.py",
          "line": 3
        }
      ],
      "exports": [],
      "complexity": 22,
      "lines": 63
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/__init__.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/__init__.py",
      "language": "python",
      "functions": [],
      "classes": [],
      "imports": [],
      "exports": [],
      "complexity": 1,
      "lines": 1
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/actions.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/actions.py",
      "language": "python",
      "functions": [
        {
          "id": "cae9e9daf651",
          "name": "manage_actions",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/actions.py",
          "startLine": 4,
          "endLine": 84,
          "lineCount": 81,
          "parameters": [
            "args",
            "github_username",
            "github_token"
          ],
          "calls": [
            "manage_actions",
            "print_header",
            "List",
            "prompt",
            "Text",
            "github_request",
            "json",
            "get",
            "print_error",
            "input",
            "ref",
            "print_success",
            "print_info",
            "fromisoformat",
            "replace",
            "divmod",
            "total_seconds",
            "Rate",
            "lower",
            "toggle_workflow_api"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 26,
          "isExported": false,
          "isAsync": false,
          "docstring": "Advanced GitHub Actions Control Center.",
          "body": "\ndef manage_actions(args, github_username, github_token):\n    \"\"\"Advanced GitHub Actions Control Center.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n\n    if not action:\n        print_header(\"CI/CD Control Center\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"Select an Actions operation\",\n                choices=[\"Trigger Workflow\", \"Monitor Status & Metrics\", \"Enable Workflow\", \"Disable Workflow\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n    if not repo_name:\n        repo_name = inquirer.prompt([inquirer.Text(\"repo\", message=\"Enter the repository name\")])[\"repo\"]\n\n    base_url = f\"https://api.github.com/repos/{github_username}/{repo_name}/actions\"\n\n    try:\n        if action == \"Trigger Workflow\":\n            # List workflows first to let user choose\n            w_resp = github_request(\"GET\", f\"{base_url}/workflows\", github_token)\n            workflows = w_resp.json().get(\"workflows\", [])\n            if not workflows:\n                print_error(\"No workflows found.\")\n                return\n            \n            choices = [(w['name'], w['id']) for w in workflows]\n            w_choice = inquirer.prompt([inquirer.List(\"w\", message=\"Select workflow to trigger\", choices=choices)])[\"w\"]\n            ref = input(\"Enter ref (branch/tag) [main]: \") or \"main\"\n            \n            trigger_url = f\"{base_url}/workflows/{w_choice}/dispatches\"\n            github_request(\"POST\", trigger_url, github_token, json={\"ref\": ref})\n            print_success(f\"Successfully triggered workflow run on {ref}\")\n\n        elif action == \"Monitor Status & Metrics\":\n            print_info(f\"Fetching execution metrics for {repo_name}...\")\n            run_resp = github_request(\"GET\", f\"{base_url}/runs\", github_token, params={\"per_page\": 10})\n            runs = run_resp.json().get(\"workflow_runs\", [])\n            \n            if not runs:\n                print_info(\"No recent runs found.\")\n                return\n\n            print(\"\\n[bold]Recent Workflow Runs & Metrics:[/bold]\")\n            success_count = 0\n            from datetime import datetime\n            for run in runs:\n                status_icon = \"üü¢\" if run['conclusion'] == \"success\" else \"üî¥\" if run['conclusion'] == \"failure\" else \"‚è≥\"\n                if run['conclusion'] == \"success\": success_count += 1\n                \n                duration_str = \"N/A\"\n                if run.get('updated_at') and run.get('run_started_at'):\n                    start = datetime.fromisoformat(run['run_started_at'].replace('Z', '+00:00'))\n                    end = datetime.fromisoformat(run['updated_at'].replace('Z', '+00:00'))\n                    diff = end - start\n                    minutes, seconds = divmod(diff.total_seconds(), 60)\n                    duration_str = f\"{int(minutes)}m {int(seconds)}s\"\n\n                print(f\"{status_icon} ID: {run['id']} | {run['name']} | Time: {duration_str} | Result: {run['conclusion']}\")\n            \n            success_rate = (success_count / len(runs)) * 100\n            print(f\"\\n[bold cyan]Success Rate (Last 10): {success_rate:.0f}%[/bold cyan]\")\n\n        elif \"Workflow\" in action:\n            enable = \"Enable\" in action\n            w_resp = github_request(\"GET\", f\"{base_url}/workflows\", github_token)\n            workflows = w_resp.json().get(\"workflows\", [])\n            choices = [(w['name'], w['id']) for w in workflows]\n            w_choice = inquirer.prompt([inquirer.List(\"w\", message=f\"Select workflow to {action.lower()}\", choices=choices)])[\"w\"]\n            \n            toggle_workflow_api(github_username, repo_name, github_token, w_choice, enable=enable)\n            print_success(f\"Workflow {action.lower()}d successfully.\")\n\n    except Exception as e:\n        print_error(f\"Actions operation failed: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "inquirer",
          "specifiers": [
            "inquirer"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/actions.py",
          "line": 1
        },
        {
          "source": ".api",
          "specifiers": [
            "github_request",
            "toggle_workflow_api"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/actions.py",
          "line": 2
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/actions.py",
          "line": 3
        }
      ],
      "exports": [],
      "complexity": 26,
      "lines": 84
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
      "language": "python",
      "functions": [
        {
          "id": "ae53fa12588e",
          "name": "get_github_headers",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 4,
          "endLine": 11,
          "lineCount": 8,
          "parameters": [
            "token"
          ],
          "calls": [
            "get_github_headers"
          ],
          "calledBy": [
            "04ec89b8dcdb"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Create standard GitHub API headers.",
          "body": "\ndef get_github_headers(token):\n    \"\"\"Create standard GitHub API headers.\"\"\"\n    return {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n"
        },
        {
          "id": "04ec89b8dcdb",
          "name": "github_request",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 11,
          "endLine": 36,
          "lineCount": 26,
          "parameters": [
            "method",
            "url",
            "token",
            "**kwargs"
          ],
          "calls": [
            "github_request",
            "get_github_headers",
            "update",
            "pop",
            "request",
            "get",
            "time",
            "max",
            "sleep"
          ],
          "calledBy": [
            "cae9e9daf651",
            "22799e5e935b",
            "729bde7aebfc",
            "59cce6cbf9ef",
            "f288fcba775c",
            "a05438a21c94",
            "ed46502e03e4",
            "9f5b6b9d7027",
            "304c2f42440f",
            "0be2041124b1",
            "2940e06f8c6f",
            "e598644894fc",
            "1a4cd86312dd",
            "8af97186e8e2",
            "f21215245cf7",
            "cc1f5fc47297",
            "851ca2aa04d6",
            "7aba7221be60",
            "2cc012b3cc34",
            "c05b776fcc1c",
            "4b3f28ce9e27",
            "4350d6620c0f",
            "6e8a9abe9285",
            "3007556417ad",
            "bfb968263df8",
            "f16e5c44fb5b",
            "596d2eb4e17c",
            "8037213f9b0d",
            "72913908c45b",
            "9ec31c3178f8",
            "f5e6adf207a0",
            "1d0f56ea40c1",
            "be40efbe3e80"
          ],
          "complexity": 8,
          "isExported": false,
          "isAsync": false,
          "docstring": "Centralized GitHub API request handler with rate-limiting support.",
          "body": "\ndef github_request(method, url, token, **kwargs):\n    \"\"\"Centralized GitHub API request handler with rate-limiting support.\"\"\"\n    headers = get_github_headers(token)\n    if 'headers' in kwargs:\n        headers.update(kwargs.pop('headers'))\n    \n    while True:\n        try:\n            response = requests.request(method, url, headers=headers, **kwargs)\n            \n            # Handle rate limiting\n            if response.status_code == 403 and 'X-RateLimit-Remaining' in response.headers:\n                remaining = int(response.headers.get('X-RateLimit-Remaining', 1))\n                if remaining == 0:\n                    reset_time = int(response.headers.get('X-RateLimit-Reset', time.time() + 60))\n                    sleep_duration = max(reset_time - time.time() + 1, 1)\n                    print(f\"\\n[!] Rate limit reached. Sleeping for {sleep_duration:.0f}s until reset...\")\n                    time.sleep(sleep_duration)\n                    continue\n            \n            return response\n        except requests.exceptions.RequestException as e:\n            print(f\"Request failed: {e}\")\n            raise\n"
        },
        {
          "id": "22799e5e935b",
          "name": "graphql_request",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 36,
          "endLine": 43,
          "lineCount": 8,
          "parameters": [
            "query",
            "variables",
            "token"
          ],
          "calls": [
            "graphql_request",
            "GraphQL",
            "github_request"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Execute a GitHub GraphQL (v4) API request with rate-limiting support.",
          "body": "\ndef graphql_request(query, variables, token):\n    \"\"\"Execute a GitHub GraphQL (v4) API request with rate-limiting support.\"\"\"\n    url = \"https://api.github.com/graphql\"\n    payload = {\"query\": query, \"variables\": variables}\n    # GraphQL always uses POST\n    return github_request(\"POST\", url, token, json=payload)\n"
        },
        {
          "id": "729bde7aebfc",
          "name": "get_repo_info",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 43,
          "endLine": 48,
          "lineCount": 6,
          "parameters": [
            "username",
            "repo_name",
            "token"
          ],
          "calls": [
            "get_repo_info",
            "github_request"
          ],
          "calledBy": [
            "cd26c0773f45",
            "f5e6adf207a0",
            "4ac56e6829e2"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get repository information.",
          "body": "\ndef get_repo_info(username, repo_name, token):\n    \"\"\"Get repository information.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}\"\n    return github_request(\"GET\", url, token)\n"
        },
        {
          "id": "59cce6cbf9ef",
          "name": "create_repo",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 48,
          "endLine": 58,
          "lineCount": 11,
          "parameters": [
            "username",
            "repo_name",
            "token",
            "description",
            "private"
          ],
          "calls": [
            "create_repo",
            "github_request"
          ],
          "calledBy": [
            "ea310d7744bd",
            "4ac56e6829e2",
            "3831ab37da60"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Create a new GitHub repository.",
          "body": "\ndef create_repo(username, repo_name, token, description=\"\", private=False):\n    \"\"\"Create a new GitHub repository.\"\"\"\n    url = \"https://api.github.com/user/repos\"\n    data = {\n        \"name\": repo_name,\n        \"description\": description,\n        \"private\": private\n    }\n    return github_request(\"POST\", url, token, json=data)\n"
        },
        {
          "id": "f288fcba775c",
          "name": "get_file_info",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 58,
          "endLine": 63,
          "lineCount": 6,
          "parameters": [
            "username",
            "repo_name",
            "file_path",
            "token"
          ],
          "calls": [
            "get_file_info",
            "github_request"
          ],
          "calledBy": [
            "b9152e2e05f3",
            "8aecc87cfbd7",
            "44098917418d"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get information about a file in a repository.",
          "body": "\ndef get_file_info(username, repo_name, file_path, token):\n    \"\"\"Get information about a file in a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/contents/{file_path}\"\n    return github_request(\"GET\", url, token)\n"
        },
        {
          "id": "a05438a21c94",
          "name": "update_file",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 63,
          "endLine": 75,
          "lineCount": 13,
          "parameters": [
            "username",
            "repo_name",
            "file_path",
            "content",
            "token",
            "message",
            "sha"
          ],
          "calls": [
            "update_file",
            "b64encode",
            "decode",
            "github_request"
          ],
          "calledBy": [
            "56eb7f277de9",
            "b9152e2e05f3",
            "8aecc87cfbd7",
            "44098917418d",
            "3831ab37da60",
            "d4cc0e31330b"
          ],
          "complexity": 3,
          "isExported": false,
          "isAsync": false,
          "docstring": "Update or create a file in a repository.",
          "body": "\ndef update_file(username, repo_name, file_path, content, token, message, sha=None):\n    \"\"\"Update or create a file in a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/contents/{file_path}\"\n    encoded_content = base64.b64encode(content).decode('utf-8')\n    data = {\n        \"message\": message,\n        \"content\": encoded_content\n    }\n    if sha:\n        data[\"sha\"] = sha\n    return github_request(\"PUT\", url, token, json=data)\n"
        },
        {
          "id": "ed46502e03e4",
          "name": "get_commit_history",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 75,
          "endLine": 83,
          "lineCount": 9,
          "parameters": [
            "username",
            "repo_name",
            "token",
            "path"
          ],
          "calls": [
            "get_commit_history",
            "github_request"
          ],
          "calledBy": [
            "51e6ef2a0fbb",
            "ed9e81d9ba4e",
            "6dcebe2d9f75"
          ],
          "complexity": 4,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get commit history for a repository or specific file.",
          "body": "\ndef get_commit_history(username, repo_name, token, path=None):\n    \"\"\"Get commit history for a repository or specific file.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/commits\"\n    params = {}\n    if path:\n        params[\"path\"] = path\n    return github_request(\"GET\", url, token, params=params)\n"
        },
        {
          "id": "9f5b6b9d7027",
          "name": "create_release",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 83,
          "endLine": 95,
          "lineCount": 13,
          "parameters": [
            "username",
            "repo_name",
            "token",
            "tag_name",
            "name",
            "body"
          ],
          "calls": [
            "create_release",
            "github_request"
          ],
          "calledBy": [
            "ea6606b7620d"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Create a new GitHub release.",
          "body": "\ndef create_release(username, repo_name, token, tag_name, name, body=\"\"):\n    \"\"\"Create a new GitHub release.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/releases\"\n    data = {\n        \"tag_name\": tag_name,\n        \"name\": name,\n        \"body\": body,\n        \"draft\": False,\n        \"prerelease\": False\n    }\n    return github_request(\"POST\", url, token, json=data)\n"
        },
        {
          "id": "304c2f42440f",
          "name": "create_issue",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 95,
          "endLine": 106,
          "lineCount": 12,
          "parameters": [
            "username",
            "repo_name",
            "token",
            "title",
            "body",
            "assignees"
          ],
          "calls": [
            "create_issue",
            "github_request"
          ],
          "calledBy": [
            "65c5d1c696bf"
          ],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Create a new GitHub issue.",
          "body": "\ndef create_issue(username, repo_name, token, title, body=\"\", assignees=None):\n    \"\"\"Create a new GitHub issue.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/issues\"\n    data = {\n        \"title\": title,\n        \"body\": body\n    }\n    if assignees:\n        data[\"assignees\"] = assignees\n    return github_request(\"POST\", url, token, json=data)\n"
        },
        {
          "id": "0be2041124b1",
          "name": "get_pull_requests",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 106,
          "endLine": 112,
          "lineCount": 7,
          "parameters": [
            "username",
            "repo_name",
            "token",
            "state"
          ],
          "calls": [
            "get_pull_requests",
            "github_request"
          ],
          "calledBy": [],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get pull requests for a repository.",
          "body": "\ndef get_pull_requests(username, repo_name, token, state=\"open\"):\n    \"\"\"Get pull requests for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/pulls\"\n    params = {\"state\": state}\n    return github_request(\"GET\", url, token, params=params)\n"
        },
        {
          "id": "2940e06f8c6f",
          "name": "create_pull_request",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 112,
          "endLine": 123,
          "lineCount": 12,
          "parameters": [
            "username",
            "repo_name",
            "token",
            "title",
            "head",
            "base",
            "body"
          ],
          "calls": [
            "create_pull_request",
            "github_request"
          ],
          "calledBy": [
            "dd4bb98c5440"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Create a new pull request.",
          "body": "\ndef create_pull_request(username, repo_name, token, title, head, base, body=\"\"):\n    \"\"\"Create a new pull request.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/pulls\"\n    data = {\n        \"title\": title,\n        \"head\": head,\n        \"base\": base,\n        \"body\": body\n    }\n    return github_request(\"POST\", url, token, json=data)\n"
        },
        {
          "id": "e598644894fc",
          "name": "get_contributors",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 123,
          "endLine": 128,
          "lineCount": 6,
          "parameters": [
            "username",
            "repo_name",
            "token"
          ],
          "calls": [
            "get_contributors",
            "github_request"
          ],
          "calledBy": [
            "6dcebe2d9f75",
            "be40efbe3e80"
          ],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get contributors for a repository.",
          "body": "\ndef get_contributors(username, repo_name, token):\n    \"\"\"Get contributors for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/contributors\"\n    return github_request(\"GET\", url, token)\n"
        },
        {
          "id": "1a4cd86312dd",
          "name": "get_issues",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 128,
          "endLine": 134,
          "lineCount": 7,
          "parameters": [
            "username",
            "repo_name",
            "token",
            "state"
          ],
          "calls": [
            "get_issues",
            "github_request"
          ],
          "calledBy": [
            "6dcebe2d9f75",
            "65c5d1c696bf",
            "be40efbe3e80"
          ],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get issues for a repository.",
          "body": "\ndef get_issues(username, repo_name, token, state=\"all\"):\n    \"\"\"Get issues for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/issues\"\n    params = {\"state\": state}\n    return github_request(\"GET\", url, token, params=params)\n"
        },
        {
          "id": "8af97186e8e2",
          "name": "get_repo_forks",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 134,
          "endLine": 139,
          "lineCount": 6,
          "parameters": [
            "owner",
            "repo",
            "token"
          ],
          "calls": [
            "get_repo_forks",
            "github_request"
          ],
          "calledBy": [
            "9ec31c3178f8"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Fetch all forks of a repository.",
          "body": "\ndef get_repo_forks(owner, repo, token):\n    \"\"\"Fetch all forks of a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{owner}/{repo}/forks\"\n    return github_request(\"GET\", url, token, params={\"per_page\": 100})\n"
        },
        {
          "id": "f21215245cf7",
          "name": "compare_commits",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 139,
          "endLine": 144,
          "lineCount": 6,
          "parameters": [
            "owner",
            "repo",
            "base",
            "head",
            "token"
          ],
          "calls": [
            "compare_commits",
            "github_request"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Compare two commits/branches/refs.",
          "body": "\ndef compare_commits(owner, repo, base, head, token):\n    \"\"\"Compare two commits/branches/refs.\"\"\"\n    url = f\"https://api.github.com/repos/{owner}/{repo}/compare/{base}...{head}\"\n    return github_request(\"GET\", url, token)\n"
        },
        {
          "id": "cc1f5fc47297",
          "name": "get_repo_languages",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 144,
          "endLine": 149,
          "lineCount": 6,
          "parameters": [
            "username",
            "repo_name",
            "token"
          ],
          "calls": [
            "get_repo_languages",
            "github_request"
          ],
          "calledBy": [
            "f5e6adf207a0"
          ],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get detailed language breakdown for a repository.",
          "body": "\ndef get_repo_languages(username, repo_name, token):\n    \"\"\"Get detailed language breakdown for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/languages\"\n    return github_request(\"GET\", url, token)\n"
        },
        {
          "id": "851ca2aa04d6",
          "name": "get_community_profile",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 149,
          "endLine": 155,
          "lineCount": 7,
          "parameters": [
            "username",
            "repo_name",
            "token"
          ],
          "calls": [
            "get_community_profile",
            "metrics",
            "github_request"
          ],
          "calledBy": [
            "f5e6adf207a0"
          ],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get community health metrics (presence of README, LICENSE, etc).",
          "body": "\ndef get_community_profile(username, repo_name, token):\n    \"\"\"Get community health metrics (presence of README, LICENSE, etc).\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/community/profile\"\n    # This endpoint uses a different preview header for some data\n    return github_request(\"GET\", url, token)\n"
        },
        {
          "id": "7aba7221be60",
          "name": "get_latest_release",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 155,
          "endLine": 160,
          "lineCount": 6,
          "parameters": [
            "username",
            "repo_name",
            "token"
          ],
          "calls": [
            "get_latest_release",
            "github_request"
          ],
          "calledBy": [
            "f5e6adf207a0"
          ],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get the latest release for a repository.",
          "body": "\ndef get_latest_release(username, repo_name, token):\n    \"\"\"Get the latest release for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/releases/latest\"\n    return github_request(\"GET\", url, token)\n"
        },
        {
          "id": "2cc012b3cc34",
          "name": "get_repo_contents",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 160,
          "endLine": 165,
          "lineCount": 6,
          "parameters": [
            "username",
            "repo_name",
            "token",
            "path"
          ],
          "calls": [
            "get_repo_contents",
            "github_request"
          ],
          "calledBy": [
            "09b2167e8bce"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get repository contents recursively.",
          "body": "\ndef get_repo_contents(username, repo_name, token, path=\"\"):\n    \"\"\"Get repository contents recursively.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/contents/{path}\"\n    return github_request(\"GET\", url, token)\n"
        },
        {
          "id": "c05b776fcc1c",
          "name": "search_user_by_email",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 165,
          "endLine": 170,
          "lineCount": 6,
          "parameters": [
            "email",
            "token"
          ],
          "calls": [
            "search_user_by_email",
            "github_request"
          ],
          "calledBy": [
            "65c5d1c696bf"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Find a GitHub user by their email address.",
          "body": "\ndef search_user_by_email(email, token):\n    \"\"\"Find a GitHub user by their email address.\"\"\"\n    url = f\"https://api.github.com/search/users\"\n    return github_request(\"GET\", url, token, params={\"q\": f\"{email} in:email\"})\n"
        },
        {
          "id": "4b3f28ce9e27",
          "name": "get_user_repos",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 170,
          "endLine": 175,
          "lineCount": 6,
          "parameters": [
            "token"
          ],
          "calls": [
            "get_user_repos",
            "github_request"
          ],
          "calledBy": [
            "1f4213d37548"
          ],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "List all repositories for the authenticated user.",
          "body": "\ndef get_user_repos(token):\n    \"\"\"List all repositories for the authenticated user.\"\"\"\n    url = \"https://api.github.com/user/repos\"\n    return github_request(\"GET\", url, token, params={\"per_page\": 100})\n"
        },
        {
          "id": "4350d6620c0f",
          "name": "update_repo_visibility",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 175,
          "endLine": 181,
          "lineCount": 7,
          "parameters": [
            "username",
            "repo_name",
            "token",
            "private"
          ],
          "calls": [
            "update_repo_visibility",
            "github_request"
          ],
          "calledBy": [
            "e638d8d1a537"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Update the visibility of a repository.",
          "body": "\ndef update_repo_visibility(username, repo_name, token, private):\n    \"\"\"Update the visibility of a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}\"\n    data = {\"private\": private}\n    return github_request(\"PATCH\", url, token, json=data)\n"
        },
        {
          "id": "6e8a9abe9285",
          "name": "delete_repo_api",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 181,
          "endLine": 186,
          "lineCount": 6,
          "parameters": [
            "username",
            "repo_name",
            "token"
          ],
          "calls": [
            "delete_repo_api",
            "github_request"
          ],
          "calledBy": [
            "9863eda17987"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Delete a GitHub repository.",
          "body": "\ndef delete_repo_api(username, repo_name, token):\n    \"\"\"Delete a GitHub repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}\"\n    return github_request(\"DELETE\", url, token)\n"
        },
        {
          "id": "3007556417ad",
          "name": "get_workflow_run_logs",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 188,
          "endLine": 193,
          "lineCount": 6,
          "parameters": [
            "username",
            "repo_name",
            "token",
            "run_id"
          ],
          "calls": [
            "get_workflow_run_logs",
            "github_request"
          ],
          "calledBy": [],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Download logs for a specific workflow run.",
          "body": "\ndef get_workflow_run_logs(username, repo_name, token, run_id):\n    \"\"\"Download logs for a specific workflow run.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/actions/runs/{run_id}/logs\"\n    return github_request(\"GET\", url, token)\n"
        },
        {
          "id": "bfb968263df8",
          "name": "toggle_workflow_api",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 193,
          "endLine": 199,
          "lineCount": 7,
          "parameters": [
            "username",
            "repo_name",
            "token",
            "workflow_id",
            "enable"
          ],
          "calls": [
            "toggle_workflow_api",
            "github_request"
          ],
          "calledBy": [
            "cae9e9daf651"
          ],
          "complexity": 4,
          "isExported": false,
          "isAsync": false,
          "docstring": "Enable or disable a specific workflow.",
          "body": "\ndef toggle_workflow_api(username, repo_name, token, workflow_id, enable=True):\n    \"\"\"Enable or disable a specific workflow.\"\"\"\n    status = \"enable\" if enable else \"disable\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/actions/workflows/{workflow_id}/{status}\"\n    return github_request(\"PUT\", url, token)\n"
        },
        {
          "id": "f16e5c44fb5b",
          "name": "get_dependabot_alerts",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 199,
          "endLine": 204,
          "lineCount": 6,
          "parameters": [
            "username",
            "repo_name",
            "token"
          ],
          "calls": [
            "get_dependabot_alerts",
            "github_request"
          ],
          "calledBy": [
            "8957cebef9b3"
          ],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Fetch Dependabot alerts for a repository.",
          "body": "\ndef get_dependabot_alerts(username, repo_name, token):\n    \"\"\"Fetch Dependabot alerts for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/dependabot/alerts\"\n    return github_request(\"GET\", url, token)\n"
        },
        {
          "id": "596d2eb4e17c",
          "name": "get_secret_scanning_alerts",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "startLine": 204,
          "endLine": 208,
          "lineCount": 5,
          "parameters": [
            "username",
            "repo_name",
            "token"
          ],
          "calls": [
            "get_secret_scanning_alerts",
            "github_request"
          ],
          "calledBy": [
            "8957cebef9b3"
          ],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Fetch Secret Scanning alerts for a repository.",
          "body": "\ndef get_secret_scanning_alerts(username, repo_name, token):\n    \"\"\"Fetch Secret Scanning alerts for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/secret-scanning/alerts\"\n    return github_request(\"GET\", url, token)"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "requests",
          "specifiers": [
            "requests"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "line": 1
        },
        {
          "source": "base64",
          "specifiers": [
            "base64"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "line": 2
        },
        {
          "source": "time",
          "specifiers": [
            "time"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
          "line": 3
        }
      ],
      "exports": [],
      "complexity": 2,
      "lines": 208
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
      "language": "python",
      "functions": [
        {
          "id": "8037213f9b0d",
          "name": "manage_gists",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
          "startLine": 5,
          "endLine": 84,
          "lineCount": 80,
          "parameters": [
            "args",
            "github_username",
            "github_token"
          ],
          "calls": [
            "manage_gists",
            "print_header",
            "List",
            "prompt",
            "print_info",
            "Text",
            "Confirm",
            "check_is_sensitive",
            "print_warning",
            "input",
            "lower",
            "github_request",
            "raise_for_status",
            "json",
            "print_success",
            "print_error"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 32,
          "isExported": false,
          "isAsync": false,
          "docstring": "Handle Gist management operations with rate-limiting support.",
          "body": "\ndef manage_gists(args, github_username, github_token):\n    \"\"\"Handle Gist management operations with rate-limiting support.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    filename = args.filename if hasattr(args, 'filename') and args.filename else None\n    content = args.content if hasattr(args, 'content') and args.content else None\n    description = args.description if hasattr(args, 'description') and args.description else None\n    public = args.public if hasattr(args, 'public') and args.public else False\n\n    if not action:\n        print_header(\"Gist Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What Gist operation would you like to perform?\",\n                choices=[\"create\", \"list\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        if not answers:\n            print_info(\"Operation cancelled.\")\n            return\n        action = answers[\"action\"]\n\n        if action == \"create\":\n            gist_questions = [\n                inquirer.Text(\"filename\", message=\"Enter the filename for the Gist\"),\n                inquirer.Text(\"content\", message=\"Enter the content of the Gist\"),\n                inquirer.Text(\"description\", message=\"Enter an optional description for the Gist\"),\n                inquirer.Confirm(\"public\", message=\"Make the Gist public?\", default=False),\n            ]\n            gist_answers = inquirer.prompt(gist_questions)\n            if not gist_answers:\n                print_info(\"Operation cancelled.\")\n                return\n            filename = gist_answers[\"filename\"]\n            content = gist_answers[\"content\"]\n            description = gist_answers[\"description\"]\n            public = gist_answers[\"public\"]\n\n    try:\n        if action == \"create\":\n            # Security check for Gist content/filename\n            if check_is_sensitive(filename):\n                print_warning(f\"'{filename}' appears to be a sensitive filename pattern.\")\n                confirm = input(\"Are you sure you want to create this Gist? (y/n): \").lower()\n                if confirm != 'y':\n                    print_info(\"Gist creation cancelled.\")\n                    return\n\n            data = {\n                \"description\": description or \"\",\n                \"public\": public,\n                \"files\": {\n                    filename: {\n                        \"content\": content\n                    }\n                }\n            }\n            response = github_request(\"POST\", \"https://api.github.com/gists\", github_token, json=data)\n            response.raise_for_status()\n            gist_data = response.json()\n            print_success(\"Gist created successfully!\")\n            print_info(f\"View it here: {gist_data['html_url']}\")\n\n        elif action == \"list\":\n            url = f\"https://api.github.com/users/{github_username}/gists\"\n            response = github_request(\"GET\", url, github_token)\n            response.raise_for_status()\n            gists = response.json()\n            if gists:\n                print_info(\"Your Gists:\")\n                for gist in gists:\n                    gist_desc = gist['description'] or \"No description\"\n                    print(f\"- {gist['html_url']} ({gist_desc})\")\n            else:\n                print_info(\"You don't have any Gists.\")\n\n    except Exception as e:\n        print_error(f\"Gist operation failed: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "inquirer",
          "specifiers": [
            "inquirer"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
          "line": 1
        },
        {
          "source": ".api",
          "specifiers": [
            "github_request"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
          "line": 2
        },
        {
          "source": "..utils.security",
          "specifiers": [
            "check_is_sensitive"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
          "line": 3
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header",
            "print_warning"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
          "line": 4
        }
      ],
      "exports": [],
      "complexity": 32,
      "lines": 84
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
      "language": "python",
      "functions": [
        {
          "id": "72913908c45b",
          "name": "manage_pull_requests",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
          "startLine": 7,
          "endLine": 70,
          "lineCount": 64,
          "parameters": [
            "args",
            "github_username",
            "github_token"
          ],
          "calls": [
            "manage_pull_requests",
            "print_header",
            "List",
            "prompt",
            "Text",
            "print_error",
            "github_request",
            "raise_for_status",
            "print_success"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 23,
          "isExported": false,
          "isAsync": false,
          "docstring": "Handle pull request management operations with rate-limiting support.",
          "body": "\ndef manage_pull_requests(args, github_username, github_token):\n    \"\"\"Handle pull request management operations with rate-limiting support.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n    pr_number = args.pr_number if hasattr(args, 'pr_number') and args.pr_number else None\n    comment = args.comment if hasattr(args, 'comment') and args.comment else None\n\n    if not action:\n        print_header(\"Pull Request Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What pull request operation would you like to perform?\",\n                choices=[\"merge\", \"close\", \"comment\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if not repo_name:\n            repo_questions = [inquirer.Text(\"repo\", message=\"Enter the repository name\")]\n            repo_answers = inquirer.prompt(repo_questions)\n            repo_name = repo_answers[\"repo\"]\n\n        pr_number_questions = [inquirer.Text(\"pr_number\", message=\"Enter the pull request number\")]\n        pr_number_answers = inquirer.prompt(pr_number_questions)\n        pr_number = int(pr_number_answers[\"pr_number\"])\n\n        if action == \"comment\":\n            comment_questions = [inquirer.Text(\"comment\", message=\"Enter your comment\")]\n            comment_answers = inquirer.prompt(comment_questions)\n            comment = comment_answers[\"comment\"]\n\n    if not repo_name or not pr_number:\n        print_error(\"Repository name and pull request number are required.\")\n        return\n\n    base_url = f\"https://api.github.com/repos/{github_username}/{repo_name}\"\n\n    try:\n        if action == \"merge\":\n            url = f\"{base_url}/pulls/{pr_number}/merge\"\n            response = github_request(\"PUT\", url, github_token)\n            response.raise_for_status()\n            print_success(\"Pull request merged successfully!\")\n\n        elif action == \"close\":\n            url = f\"{base_url}/pulls/{pr_number}\"\n            data = {\"state\": \"closed\"}\n            response = github_request(\"PATCH\", url, github_token, json=data)\n            response.raise_for_status()\n            print_success(\"Pull request closed successfully!\")\n\n        elif action == \"comment\":\n            url = f\"{base_url}/issues/{pr_number}/comments\"\n            data = {\"body\": comment}\n            response = github_request(\"POST\", url, github_token, json=data)\n            response.raise_for_status()\n            print_success(\"Comment added successfully!\")\n\n    except Exception as e:\n        print_error(f\"Pull request operation failed: {e}\")\n"
        },
        {
          "id": "dd4bb98c5440",
          "name": "request_code_review",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
          "startLine": 70,
          "endLine": 143,
          "lineCount": 74,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "request_code_review",
            "print_info",
            "prompt",
            "Text",
            "time",
            "run",
            "split",
            "input",
            "review",
            "join",
            "reviewers",
            "create_pull_request",
            "json",
            "print_success",
            "print_error"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 28,
          "isExported": false,
          "isAsync": false,
          "docstring": "Request code reviews for specific files.",
          "body": "\ndef request_code_review(github_username, github_token, config, args=None):\n    \"\"\"Request code reviews for specific files.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would request a code review.\")\n        return\n\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = inquirer.prompt([inquirer.Text(\"repo\", message=\"Enter the repository name\")])[\"repo\"]\n\n    # Create a new branch for the review\n    branch_name = f\"review-{int(time.time())}\"\n\n    try:\n        # Create and switch to the new branch\n        subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n        print_info(f\"Created and switched to new branch: {branch_name}\")\n\n        if args and args.files:\n            files = args.files.split(\",\")\n        else:\n            files_input = input(\"Enter files to review (comma-separated): \")\n            files = files_input.split(\",\") if files_input else []\n\n        if files:\n            # Add the specified files to the branch\n            subprocess.run([\"git\", \"add\"] + files, check=True)\n            print_info(f\"Added files to the branch: {files}\")\n\n            # Commit the changes\n            commit_message = f\"Code review request for: {', '.join(files)}\"\n            subprocess.run([\"git\", \"commit\", \"-m\", commit_message], check=True)\n            print_info(\"Committed changes to the branch.\")\n\n        # Push the new branch to GitHub\n        subprocess.run([\"git\", \"push\", \"-u\", \"origin\", branch_name], check=True)\n        print_info(\"Pushed the new branch to GitHub.\")\n\n        reviewers = []\n        if args and args.reviewers:\n            reviewers = args.reviewers.split(\",\")\n        else:\n            reviewers_input = input(\"Enter reviewers (comma-separated GitHub usernames): \")\n            reviewers = reviewers_input.split(\",\") if reviewers_input else []\n\n        # Create a pull request\n        pr_title = f\"Code Review Request: {', '.join(files) if files else 'General Review'}\"\n        pr_body = f\"This PR is requesting code review for the following files:\\n\"\n        for file in files:\n            pr_body += f\"- {file}\\n\"\n\n        if reviewers:\n            pr_body += f\"\\nRequested reviewers: {', '.join(reviewers)}\"\n\n        response = create_pull_request(github_username, repo_name, github_token, pr_title, branch_name, \"main\", pr_body)\n\n        if response.status_code == 201:\n            pr_data = response.json()\n            print_success(\"\\nPull request created successfully!\")\n            print_info(f\"View it here: {pr_data['html_url']}\")\n        else:\n            print_error(f\"\\nError creating pull request: {response.status_code} - {response.text}\")\n\n    except subprocess.CalledProcessError as e:\n        print_error(f\"An error occurred while running a git command: {e}\")\n    except Exception as e:\n        print_error(f\"An error occurred: {e}\")\n    finally:\n        # Switch back to the main branch\n        subprocess.run([\"git\", \"checkout\", \"main\"], check=True)\n        print_info(\"Switched back to the main branch.\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "inquirer",
          "specifiers": [
            "inquirer"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
          "line": 1
        },
        {
          "source": "subprocess",
          "specifiers": [
            "subprocess"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
          "line": 2
        },
        {
          "source": "time",
          "specifiers": [
            "time"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
          "line": 3
        },
        {
          "source": ".api",
          "specifiers": [
            "github_request",
            "create_pull_request"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
          "line": 5
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
          "line": 6
        }
      ],
      "exports": [],
      "complexity": 26,
      "lines": 143
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
      "language": "python",
      "functions": [
        {
          "id": "daedf59a9872",
          "name": "open_editor",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
          "startLine": 7,
          "endLine": 23,
          "lineCount": 17,
          "parameters": [
            "initial_content"
          ],
          "calls": [
            "open_editor",
            "get",
            "NamedTemporaryFile",
            "write",
            "run",
            "open",
            "read",
            "strip",
            "exists",
            "remove"
          ],
          "calledBy": [
            "51e6ef2a0fbb"
          ],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Opens the system default editor to edit release notes.",
          "body": "\ndef open_editor(initial_content=\"\"):\n    \"\"\"Opens the system default editor to edit release notes.\"\"\"\n    editor = os.environ.get('EDITOR', 'nano')\n    with tempfile.NamedTemporaryFile(suffix=\".md\", mode='w+', delete=False) as tf:\n        tf.write(initial_content)\n        temp_path = tf.name\n    \n    try:\n        subprocess.run([editor, temp_path], check=True)\n        with open(temp_path, 'r') as f:\n            content = f.read()\n        return content.strip()\n    finally:\n        if os.path.exists(temp_path):\n            os.remove(temp_path)\n"
        },
        {
          "id": "51e6ef2a0fbb",
          "name": "get_release_input",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
          "startLine": 23,
          "endLine": 78,
          "lineCount": 56,
          "parameters": [
            "config",
            "args",
            "github_username",
            "github_token"
          ],
          "calls": [
            "get_release_input",
            "input",
            "tag",
            "name",
            "Changelog",
            "Editor",
            "print_info",
            "get_commit_history",
            "get",
            "generate_ai_release_notes",
            "json",
            "lower",
            "open_editor",
            "print_error",
            "generate_changelog"
          ],
          "calledBy": [
            "ea6606b7620d"
          ],
          "complexity": 20,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get release input from user or arguments with AI support.",
          "body": "\ndef get_release_input(config, args, github_username, github_token):\n    \"\"\"Get release input from user or arguments with AI support.\"\"\"\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    if args and args.version:\n        version = args.version\n    else:\n        version = input(\"Enter version tag (e.g., v1.0.0): \")\n    \n    if args and args.name:\n        name = args.name\n    else:\n        default_name = f\"Release {version}\"\n        name_input = input(f\"Enter release name (default: {default_name}): \")\n        name = name_input if name_input else default_name\n    \n    # Release Notes Logic\n    changelog = \"\"\n    print(\"\\n[bold]Release Notes Options:[/bold]\")\n    print(\"1: [cyan]AI-Generated Summary[/cyan]\")\n    print(\"2: [green]Auto-Changelog (Commit list)[/green]\")\n    print(\"3: [yellow]Manual Editor (Nano/Vim)[/yellow]\")\n    print(\"4: [white]Skip / Basic prompt[/white]\")\n    \n    note_choice = input(\"\\nüëâ Choice: \")\n    \n    if note_choice == '1':\n        print_info(\"ü§ñ AI is analyzing your project history...\")\n        resp = get_commit_history(github_username, repo_name, github_token)\n        if resp.status_code == 200:\n            ai_key = config[\"github\"].get(\"ai_api_key\")\n            changelog = generate_ai_release_notes(ai_key, repo_name, resp.json())\n            # Let user tweak the AI's output\n            if changelog:\n                confirm = input(\"AI notes generated. Edit them before publishing? (y/n): \").lower()\n                if confirm == 'y':\n                    changelog = open_editor(changelog)\n        else:\n            print_error(\"Failed to fetch history for AI.\")\n            \n    elif note_choice == '2':\n        changelog = generate_changelog(github_username, repo_name, github_token, version)\n    elif note_choice == '3':\n        changelog = open_editor(\"# Release Notes for \" + version + \"\\n\\n\")\n    else:\n        if args and args.message:\n            changelog = args.message\n        else:\n            changelog = input(\"Enter release notes: \")\n    \n    return repo_name, version, name, changelog\n"
        },
        {
          "id": "ed9e81d9ba4e",
          "name": "generate_changelog",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
          "startLine": 78,
          "endLine": 96,
          "lineCount": 19,
          "parameters": [
            "username",
            "repo_name",
            "token",
            "version"
          ],
          "calls": [
            "generate_changelog",
            "get_commit_history",
            "json",
            "split"
          ],
          "calledBy": [
            "2e314dc6c749",
            "51e6ef2a0fbb"
          ],
          "complexity": 5,
          "isExported": false,
          "isAsync": false,
          "docstring": "Generate a changelog from commit history.",
          "body": "\ndef generate_changelog(username, repo_name, token, version):\n    \"\"\"Generate a changelog from commit history.\"\"\"\n    try:\n        response = get_commit_history(username, repo_name, token)\n        if response.status_code == 200:\n            commits = response.json()\n            changelog = f\"## Changelog for {version}\\n\\n\"\n            for commit in commits[:20]:  # Last 20 commits\n                message = commit['commit']['message'].split('\\n')[0]\n                author = commit['commit']['author']['name']\n                date = commit['commit']['author']['date'][:10]\n                changelog += f\"- {message} ({author} on {date})\\n\"\n            return changelog\n        else:\n            return \"Changelog generation failed.\"\n    except Exception as e:\n        return f\"Changelog generation failed: {e}\"\n"
        },
        {
          "id": "ea6606b7620d",
          "name": "create_release_tag",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
          "startLine": 96,
          "endLine": 131,
          "lineCount": 36,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "create_release_tag",
            "print_info",
            "get_release_input",
            "print_header",
            "isdir",
            "run",
            "print_success",
            "print_warning",
            "create_release",
            "json",
            "print_error"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 9,
          "isExported": false,
          "isAsync": false,
          "docstring": "Create a new GitHub release with styled output.",
          "body": "\ndef create_release_tag(github_username, github_token, config, args=None):\n    \"\"\"Create a new GitHub release with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        repo_name, version, name, changelog = get_release_input(config, args, github_username, github_token)\n        print_info(f\"Would create release {version} for {repo_name}.\")\n        return\n\n    print_header(\"Create GitHub Release\")\n    repo_name, version, name, changelog = get_release_input(config, args, github_username, github_token)\n    \n    print_info(f\"Creating release {version} for {repo_name}...\")\n    \n    # 1. Automated Local Tagging\n    try:\n        # Check if we are in the target repo\n        if os.path.isdir(\".git\"):\n            print_info(\"Local Git repository detected. Synchronizing tags...\")\n            # Create tag\n            subprocess.run([\"git\", \"tag\", \"-a\", version, \"-m\", name], capture_output=True)\n            # Push tag\n            subprocess.run([\"git\", \"push\", \"origin\", version], capture_output=True)\n            print_success(f\"Local tag '{version}' pushed to origin.\")\n    except Exception as e:\n        print_warning(f\"Local tagging skipped/failed: {e}\")\n\n    # 2. GitHub API Release\n    response = create_release(github_username, repo_name, github_token, version, name, changelog)\n    \n    if response.status_code == 201:\n        release_data = response.json()\n        print_success(f\"Release created successfully!\")\n        print_info(f\"View release at: {release_data['html_url']}\")\n    else:\n        print_error(f\"Error creating release: {response.status_code} - {response.text}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
          "line": 1
        },
        {
          "source": "subprocess",
          "specifiers": [
            "subprocess"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
          "line": 2
        },
        {
          "source": "tempfile",
          "specifiers": [
            "tempfile"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
          "line": 3
        },
        {
          "source": ".api",
          "specifiers": [
            "create_release",
            "get_commit_history"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
          "line": 4
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header",
            "print_warning"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
          "line": 5
        },
        {
          "source": "..utils.ai",
          "specifiers": [
            "generate_ai_release_notes"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
          "line": 6
        }
      ],
      "exports": [],
      "complexity": 9,
      "lines": 132
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
      "language": "python",
      "functions": [
        {
          "id": "e638d8d1a537",
          "name": "manage_repo_visibility",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
          "startLine": 5,
          "endLine": 61,
          "lineCount": 57,
          "parameters": [
            "args",
            "github_username",
            "github_token"
          ],
          "calls": [
            "manage_repo_visibility",
            "print_header",
            "append",
            "Text",
            "List",
            "prompt",
            "print_error",
            "print_info",
            "update_repo_visibility",
            "print_success"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 23,
          "isExported": false,
          "isAsync": false,
          "docstring": "Handle repository visibility changes with styled output.",
          "body": "\ndef manage_repo_visibility(args, github_username, github_token):\n    \"\"\"Handle repository visibility changes with styled output.\"\"\"\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n    \n    # Determine desired state from args\n    target_private = None\n    if hasattr(args, 'private') and args.private:\n        target_private = True\n    elif hasattr(args, 'public') and args.public:\n        target_private = False\n\n    # Interactive mode if info is missing\n    if (not repo_name or target_private is None):\n        print_header(\"Repository Visibility\")\n        questions = []\n        if not repo_name:\n            questions.append(inquirer.Text(\"repo\", message=\"Enter the repository name\"))\n        \n        if target_private is None:\n            questions.append(inquirer.List(\n                \"visibility\",\n                message=\"Select new visibility\",\n                choices=[\"Private\", \"Public\"],\n            ))\n            \n        answers = inquirer.prompt(questions)\n        \n        if not repo_name:\n            repo_name = answers[\"repo\"]\n        \n        if target_private is None:\n            target_private = answers[\"visibility\"] == \"Private\"\n\n    if not repo_name:\n        print_error(\"Repository name is required.\")\n        return\n\n    if target_private is None:\n        print_error(\"You must specify --private or --public, or select an option.\")\n        return\n\n    visibility_str = \"PRIVATE\" if target_private else \"PUBLIC\"\n    print_info(f\"Changing visibility of '{repo_name}' to {visibility_str}...\")\n\n    try:\n        response = update_repo_visibility(github_username, repo_name, github_token, target_private)\n        \n        if response.status_code == 200:\n            print_success(f\"Successfully changed '{repo_name}' to {visibility_str}.\")\n        else:\n            print_error(f\"Failed to change visibility: {response.status_code} - {response.text}\")\n            print_info(\"Note: You need admin access to the repository to change its visibility.\")\n            \n    except Exception as e:\n        print_error(f\"An error occurred: {e}\")\n"
        },
        {
          "id": "9863eda17987",
          "name": "delete_repository",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
          "startLine": 61,
          "endLine": 98,
          "lineCount": 38,
          "parameters": [
            "args",
            "github_username",
            "github_token"
          ],
          "calls": [
            "delete_repository",
            "print_header",
            "Text",
            "prompt",
            "print_error",
            "input",
            "print_warning",
            "print_info",
            "delete_repo_api",
            "print_success"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 11,
          "isExported": false,
          "isAsync": false,
          "docstring": "Delete a GitHub repository with safety confirmation and styled output.",
          "body": "\ndef delete_repository(args, github_username, github_token):\n    \"\"\"Delete a GitHub repository with safety confirmation and styled output.\"\"\"\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n\n    if not repo_name:\n        print_header(\"Delete Repository\")\n        questions = [inquirer.Text(\"repo\", message=\"Enter the name of the repository to DELETE\")]\n        answers = inquirer.prompt(questions)\n        repo_name = answers[\"repo\"]\n\n    if not repo_name:\n        print_error(\"Repository name is required.\")\n        return\n\n    print(\"\\n\" + \"!\" * 50)\n    print_error(f\"DANGER: You are about to PERMANENTLY DELETE '{repo_name}'\")\n    print(\"!\" * 50 + \"\\n\")\n    \n    confirmation = input(f\"To confirm, type '{repo_name}': \")\n    \n    if confirmation != repo_name:\n        print_warning(\"Verification failed. Repository deletion cancelled.\")\n        return\n\n    print_info(f\"Deleting repository '{repo_name}'...\")\n    \n    try:\n        response = delete_repo_api(github_username, repo_name, github_token)\n        \n        if response.status_code == 204:\n            print_success(f\"Successfully deleted repository '{repo_name}'.\")\n        else:\n            print_error(f\"Failed to delete repository: {response.status_code} - {response.text}\")\n            print_info(\"Note: You need 'delete_repo' scope in your token or admin access.\")\n            \n    except Exception as e:\n        print_error(f\"An error occurred: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "inquirer",
          "specifiers": [
            "inquirer"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
          "line": 2
        },
        {
          "source": ".api",
          "specifiers": [
            "update_repo_visibility",
            "delete_repo_api"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
          "line": 3
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header",
            "print_warning"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
          "line": 4
        }
      ],
      "exports": [],
      "complexity": 17,
      "lines": 99
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
      "language": "python",
      "functions": [
        {
          "id": "9ec31c3178f8",
          "name": "get_fork_intelligence",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
          "startLine": 6,
          "endLine": 61,
          "lineCount": 56,
          "parameters": [
            "owner",
            "repo",
            "token"
          ],
          "calls": [
            "get_fork_intelligence",
            "print_header",
            "print_info",
            "get_repo_forks",
            "print_error",
            "json",
            "github_request",
            "get",
            "print_success",
            "print_warning",
            "forks"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 16,
          "isExported": false,
          "isAsync": false,
          "docstring": "Deep scan of the Forks Network to find hidden community improvements.",
          "body": "\ndef get_fork_intelligence(owner, repo, token):\n    \"\"\"Deep scan of the Forks Network to find hidden community improvements.\"\"\"\n    print_header(\"Network & Fork Intelligence\")\n    print_info(f\"Scanning community forks for {owner}/{repo}...\")\n    \n    try:\n        forks_resp = get_repo_forks(owner, repo, token)\n        if forks_resp.status_code != 200:\n            print_error(\"Failed to fetch forks list.\")\n            return\n            \n        forks = forks_resp.json()\n        if not forks:\n            print_info(\"No forks found for this repository.\")\n            return\n            \n        print_info(f\"Analyzing {len(forks)} forks for unique activity...\")\n        \n        found_unique = False\n        for fork in forks:\n            f_owner = fork['owner']['login']\n            f_name = fork['name']\n            f_default_branch = fork['default_branch']\n            \n            print(f\"  üîç Checking @{f_owner}/{f_name} [{f_default_branch}]...\")\n            \n            # Compare the fork's default branch against the upstream's default branch\n            compare_url = f\"https://api.github.com/repos/{owner}/{repo}/compare/{owner}:{f_default_branch}...{f_owner}:{f_default_branch}\"\n            compare_resp = github_request(\"GET\", compare_url, token)\n            \n            if compare_resp.status_code == 200:\n                data = compare_resp.json()\n                ahead = data.get('ahead_by', 0)\n                behind = data.get('behind_by', 0)\n                \n                status = \"Synced\"\n                if ahead > 0 and behind > 0: status = \"Diverged\"\n                elif ahead > 0: status = \"Ahead\"\n                elif behind > 0: status = \"Behind\"\n                \n                print(f\"     ‚îî‚îÄ Status: {status} | Ahead: {ahead} | Behind: {behind}\")\n                \n                if ahead > 0:\n                    found_unique = True\n                    print_success(f\"     üåü Discovery: Unique code found in @{f_owner}!\")\n                    print(f\"        View Diff: {data.get('html_url')}\")\n            else:\n                print_warning(f\"     ‚ö†Ô∏è  Could not compare: {compare_resp.status_code}\")\n        \n        if not found_unique:\n            print_info(\"No unique community work detected in forks (all forks are in-sync or behind).\")\n            \n    except Exception as e:\n        print_error(f\"Fork intelligence scan failed: {e}\")\n"
        },
        {
          "id": "ac5fff938bb6",
          "name": "parse_github_url",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
          "startLine": 61,
          "endLine": 75,
          "lineCount": 15,
          "parameters": [
            "url"
          ],
          "calls": [
            "parse_github_url",
            "urlparse",
            "strip",
            "split"
          ],
          "calledBy": [
            "cad67e0dcece",
            "f5e6adf207a0"
          ],
          "complexity": 5,
          "isExported": false,
          "isAsync": false,
          "docstring": "Extract owner and repo name from a GitHub URL.",
          "body": "\ndef parse_github_url(url):\n    \"\"\"Extract owner and repo name from a GitHub URL.\"\"\"\n    try:\n        parsed = urlparse(url)\n        # Handle cases like https://github.com/owner/repo or github.com/owner/repo\n        path = parsed.path\n             \n        parts = path.strip(\"/\").split(\"/\")\n        if len(parts) >= 2:\n            return parts[0], parts[1]\n    except Exception:\n        pass\n    return None, None\n"
        },
        {
          "id": "6dcebe2d9f75",
          "name": "get_repo_health_metrics",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
          "startLine": 75,
          "endLine": 122,
          "lineCount": 48,
          "parameters": [
            "username",
            "repo_name",
            "token"
          ],
          "calls": [
            "get_repo_health_metrics",
            "get_commit_history",
            "json",
            "commits",
            "fromisoformat",
            "replace",
            "total_seconds",
            "round",
            "sum",
            "get_issues",
            "get_contributors"
          ],
          "calledBy": [
            "f5e6adf207a0"
          ],
          "complexity": 13,
          "isExported": false,
          "isAsync": false,
          "docstring": "Calculate repository health metrics.",
          "body": "\ndef get_repo_health_metrics(username, repo_name, token):\n    \"\"\"Calculate repository health metrics.\"\"\"\n    metrics = {}\n\n    # Get recent commits\n    try:\n        commits_response = get_commit_history(username, repo_name, token)\n        if commits_response.status_code == 200:\n            commits = commits_response.json()\n            metrics['recent_commits'] = len(commits)\n            if commits:\n                # Calculate median time between commits (Sophisticated Velocity Math)\n                from datetime import datetime\n                dates = [datetime.fromisoformat(c['commit']['author']['date'].replace('Z', '+00:00')) \n                         for c in commits[:20]] # Last 20 commits\n                if len(dates) > 1:\n                    time_diffs = sorted([(dates[i] - dates[i+1]).total_seconds() / 86400 for i in range(len(dates)-1)])\n                    # Use median to avoid outlier skew\n                    median_days = time_diffs[len(time_diffs)//2]\n                    metrics['development_velocity_days'] = round(median_days, 2)\n                    \n                    # Burst detection: comparing last 3 to last 20\n                    recent_burst = sum(time_diffs[:3]) / 3\n                    metrics['activity_status'] = \"Active/Bursting\" if recent_burst < median_days else \"Stable\"\n    except Exception:\n        pass\n\n    # Get closed issues\n    try:\n        issues_response = get_issues(username, repo_name, token, state='closed')\n        if issues_response.status_code == 200:\n            closed_issues = issues_response.json()\n            metrics['closed_issues'] = len(closed_issues)\n    except Exception:\n        pass\n\n    # Get contributors\n    try:\n        contrib_response = get_contributors(username, repo_name, token)\n        if contrib_response.status_code == 200:\n            contributors = contrib_response.json()\n            metrics['contributors_count'] = len(contributors)\n    except Exception:\n        pass\n\n    return metrics\n"
        },
        {
          "id": "f5e6adf207a0",
          "name": "get_detailed_repo_info",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
          "startLine": 122,
          "endLine": 226,
          "lineCount": 105,
          "parameters": [
            "args",
            "github_token"
          ],
          "calls": [
            "get_detailed_repo_info",
            "Text",
            "prompt",
            "parse_github_url",
            "print_error",
            "get_repo_info",
            "print_warning",
            "scrape_repo_info",
            "display_repo_info",
            "json",
            "get",
            "get_repo_languages",
            "get_community_profile",
            "get_latest_release",
            "analytics",
            "github_request",
            "get_repo_health_metrics",
            "display_traffic_trends"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 30,
          "isExported": false,
          "isAsync": false,
          "docstring": "Fetch and display comprehensive repository information with insights.",
          "body": "\ndef get_detailed_repo_info(args, github_token):\n    \"\"\"Fetch and display comprehensive repository information with insights.\"\"\"\n    url = args.url if hasattr(args, 'url') and args.url else None\n\n    if not url:\n        questions = [\n            inquirer.Text(\"url\", message=\"Enter the GitHub repository URL\")\n        ]\n        answers = inquirer.prompt(questions)\n        url = answers[\"url\"]\n\n    owner, repo_name = parse_github_url(url)\n    \n    if not owner or not repo_name:\n        print_error(\"Error: Could not parse repository owner and name from the URL.\")\n        print(\"Please ensure the URL is in the format: https://github.com/owner/repo\")\n        return\n\n    print(f\"\\nFetching comprehensive report for '{owner}/{repo_name}'...\")\n    \n    try:\n        # Get basic repo info\n        repo_response = get_repo_info(owner, repo_name, github_token)\n        if repo_response.status_code != 200:\n            print_warning(f\"API Error: {repo_response.status_code} - {repo_response.text}\")\n            print_warning(\"Attempting to fallback to HTML scraping...\")\n            \n            scraped_data = scrape_repo_info(url)\n            if scraped_data:\n                display_repo_info(scraped_data)\n                return\n            else:\n                print_error(\"Failed to fetch repository data via API and Scraping.\")\n                return\n\n        repo_data = repo_response.json()\n\n        # Hybrid Intelligence: Scrape data that API hides\n        try:\n            full_url = f\"https://github.com/{owner}/{repo_name}\"\n            scraped_intel = scrape_repo_info(full_url)\n            if scraped_intel:\n                repo_data['used_by'] = scraped_intel.get('used_by')\n                repo_data['is_sponsored'] = scraped_intel.get('is_sponsored')\n                repo_data['topics'] = scraped_intel.get('topics', [])\n                repo_data['social_preview'] = scraped_intel.get('social_preview')\n        except Exception:\n            pass\n\n        # OSINT Upgrade: Fetch deep metadata\n        try:\n            # Languages\n            lang_resp = get_repo_languages(owner, repo_name, github_token)\n            if lang_resp.status_code == 200:\n                repo_data['osint_languages'] = lang_resp.json()\n            \n            # Community Profile\n            comm_resp = get_community_profile(owner, repo_name, github_token)\n            if comm_resp.status_code == 200:\n                repo_data['osint_community'] = comm_resp.json()\n            \n            # Latest Release\n            rel_resp = get_latest_release(owner, repo_name, github_token)\n            if rel_resp.status_code == 200:\n                repo_data['osint_release'] = rel_resp.json()\n        except Exception:\n            pass\n\n        # Add traffic analytics (requires push access)\n        traffic_data = {}\n        try:\n            # Clones data\n            clones_response = github_request(\"GET\", f\"https://api.github.com/repos/{owner}/{repo_name}/traffic/clones\", github_token)\n            if clones_response.status_code == 200:\n                traffic_data['clones'] = clones_response.json()\n\n            # Views data\n            views_response = github_request(\"GET\", f\"https://api.github.com/repos/{owner}/{repo_name}/traffic/views\", github_token)\n            if views_response.status_code == 200:\n                traffic_data['views'] = views_response.json()\n\n            # Referrers data\n            referrers_response = github_request(\"GET\", f\"https://api.github.com/repos/{owner}/{repo_name}/traffic/popular/referrers\", github_token)\n            if referrers_response.status_code == 200:\n                traffic_data['referrers'] = referrers_response.json()\n\n            if traffic_data:\n                repo_data['traffic'] = traffic_data\n        except Exception as e:\n            # Silently fail for traffic data if permissions are missing, or log warning\n            pass\n\n        # Add health metrics\n        health_metrics = get_repo_health_metrics(owner, repo_name, github_token)\n        repo_data['health'] = health_metrics\n        \n        # Display comprehensive report\n        display_repo_info(repo_data)\n        \n        if 'traffic' in repo_data and repo_data['traffic']:\n            display_traffic_trends(repo_data['traffic'])\n\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "inquirer",
          "specifiers": [
            "inquirer"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
          "line": 1
        },
        {
          "source": "urllib.parse",
          "specifiers": [
            "urlparse"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
          "line": 2
        },
        {
          "source": ".api",
          "specifiers": [
            "get_repo_info",
            "github_request",
            "get_commit_history",
            "get_issues",
            "get_contributors",
            "get_repo_languages",
            "get_community_profile",
            "get_latest_release",
            "get_repo_forks",
            "compare_commits"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
          "line": 3
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "display_repo_info",
            "display_traffic_trends",
            "print_error",
            "print_warning",
            "print_info",
            "print_header",
            "print_success"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
          "line": 4
        },
        {
          "source": "..utils.scraper",
          "specifiers": [
            "scrape_repo_info"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
          "line": 5
        }
      ],
      "exports": [],
      "complexity": 16,
      "lines": 226
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/webhooks.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/webhooks.py",
      "language": "python",
      "functions": [
        {
          "id": "1d0f56ea40c1",
          "name": "manage_webhooks",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/webhooks.py",
          "startLine": 4,
          "endLine": 86,
          "lineCount": 83,
          "parameters": [
            "args",
            "github_username",
            "github_token"
          ],
          "calls": [
            "manage_webhooks",
            "print_header",
            "List",
            "prompt",
            "Text",
            "to",
            "strip",
            "split",
            "print_error",
            "github_request",
            "raise_for_status",
            "json",
            "print_info",
            "print_success"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 33,
          "isExported": false,
          "isAsync": false,
          "docstring": "Handle webhook management operations with rate-limiting support.",
          "body": "\ndef manage_webhooks(args, github_username, github_token):\n    \"\"\"Handle webhook management operations with rate-limiting support.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n    hook_id = args.hook_id if hasattr(args, 'hook_id') and args.hook_id else None\n    url = args.url if hasattr(args, 'url') and args.url else None\n    events = args.events if hasattr(args, 'events') and args.events else ['push']\n\n    if not action:\n        print_header(\"Webhook Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What webhook operation would you like to perform?\",\n                choices=[\"list\", \"create\", \"delete\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if not repo_name:\n            repo_questions = [inquirer.Text(\"repo\", message=\"Enter the repository name\")]\n            repo_answers = inquirer.prompt(repo_questions)\n            repo_name = repo_answers[\"repo\"]\n\n        if action == \"create\":\n            webhook_questions = [\n                inquirer.Text(\"url\", message=\"Enter the webhook URL\"),\n                inquirer.Text(\"events\", message=\"Enter events to subscribe to (comma-separated)\", default=\"push\"),\n            ]\n            webhook_answers = inquirer.prompt(webhook_questions)\n            url = webhook_answers[\"url\"]\n            events = [e.strip() for e in webhook_answers[\"events\"].split(\",\")]\n\n        elif action == \"delete\":\n            hook_id_questions = [inquirer.Text(\"hook_id\", message=\"Enter the ID of the webhook to delete\")]\n            hook_id_answers = inquirer.prompt(hook_id_questions)\n            hook_id = hook_id_answers[\"hook_id\"]\n\n    if not repo_name:\n        print_error(\"Repository name is required for webhook operations.\")\n        return\n\n    base_url = f\"https://api.github.com/repos/{github_username}/{repo_name}/hooks\"\n\n    try:\n        if action == \"list\":\n            response = github_request(\"GET\", base_url, github_token)\n            response.raise_for_status()\n            hooks = response.json()\n            if hooks:\n                print_info(f\"Webhooks for {repo_name}:\")\n                for hook in hooks:\n                    print(f\"- ID: {hook['id']}, URL: {hook['config']['url']}, Events: {hook['events']}\")\n            else:\n                print_info(f\"No webhooks found for {repo_name}.\")\n\n        elif action == \"create\":\n            data = {\n                \"name\": \"web\",\n                \"active\": True,\n                \"events\": events,\n                \"config\": {\n                    \"url\": url,\n                    \"content_type\": \"json\"\n                }\n            }\n            response = github_request(\"POST\", base_url, github_token, json=data)\n            response.raise_for_status()\n            print_success(\"Webhook created successfully!\")\n\n        elif action == \"delete\":\n            if not hook_id:\n                print_error(\"Hook ID is required for deletion.\")\n                return\n            delete_url = f\"{base_url}/{hook_id}\"\n            response = github_request(\"DELETE\", delete_url, github_token)\n            response.raise_for_status()\n            print_success(\"Webhook deleted successfully!\")\n\n    except Exception as e:\n        print_error(f\"Webhook operation failed: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "inquirer",
          "specifiers": [
            "inquirer"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/webhooks.py",
          "line": 1
        },
        {
          "source": ".api",
          "specifiers": [
            "github_request"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/webhooks.py",
          "line": 2
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/webhooks.py",
          "line": 3
        }
      ],
      "exports": [],
      "complexity": 33,
      "lines": 86
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/__init__.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/__init__.py",
      "language": "python",
      "functions": [],
      "classes": [],
      "imports": [],
      "exports": [],
      "complexity": 1,
      "lines": 1
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
      "language": "python",
      "functions": [
        {
          "id": "893f9c1b4076",
          "name": "extract_python_docs",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
          "startLine": 9,
          "endLine": 62,
          "lineCount": 54,
          "parameters": [
            "content",
            "filename"
          ],
          "calls": [
            "extract_python_docs",
            "parse",
            "get_docstring",
            "append",
            "join",
            "print_warning"
          ],
          "calledBy": [
            "cdf0160ec029",
            "c50e2b3c1ae7",
            "c2cd9c47dd19"
          ],
          "complexity": 18,
          "isExported": false,
          "isAsync": false,
          "docstring": "Extract documentation from Python code using AST.",
          "body": "\ndef extract_python_docs(content, filename):\n    \"\"\"Extract documentation from Python code using AST.\"\"\"\n    docs = {\n        'module_docstring': '',\n        'functions': [],\n        'classes': [],\n        'constants': []\n    }\n    \n    try:\n        tree = ast.parse(content)\n        \n        # Module docstring\n        docs['module_docstring'] = ast.get_docstring(tree) or ''\n        \n        for node in tree.body:\n            if isinstance(node, ast.FunctionDef):\n                func_doc = ast.get_docstring(node) or ''\n                args = [arg.arg for arg in node.args.args]\n                docs['functions'].append({\n                    'name': node.name,\n                    'params': ', '.join(args),\n                    'docstring': func_doc\n                })\n            elif isinstance(node, ast.ClassDef):\n                class_doc = ast.get_docstring(node) or ''\n                bases = [base.id for base in node.bases if isinstance(base, ast.Name)]\n                class_info = {\n                    'name': node.name,\n                    'parent': ', '.join(bases) if bases else 'object',\n                    'docstring': class_doc,\n                    'methods': []\n                }\n                \n                for item in node.body:\n                    if isinstance(item, ast.FunctionDef):\n                        method_doc = ast.get_docstring(item) or ''\n                        method_args = [arg.arg for arg in item.args.args]\n                        class_info['methods'].append({\n                            'name': item.name,\n                            'params': ', '.join(method_args),\n                            'docstring': method_doc\n                        })\n                \n                docs['classes'].append(class_info)\n                \n    except SyntaxError:\n        print_warning(f\"Could not parse {filename} (SyntaxError). Skipping.\")\n    except Exception as e:\n        print_warning(f\"Error parsing {filename}: {e}\")\n    \n    return docs\n"
        },
        {
          "id": "913449720a31",
          "name": "extract_javascript_docs",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
          "startLine": 62,
          "endLine": 89,
          "lineCount": 28,
          "parameters": [
            "content",
            "filename"
          ],
          "calls": [
            "extract_javascript_docs",
            "n",
            "finditer",
            "groups",
            "append",
            "strip"
          ],
          "calledBy": [],
          "complexity": 4,
          "isExported": false,
          "isAsync": false,
          "docstring": "Extract documentation from JavaScript code.",
          "body": "\ndef extract_javascript_docs(content, filename):\n    \"\"\"Extract documentation from JavaScript code.\"\"\"\n    docs = {\n        'module_description': '',\n        'functions': [],\n        'classes': []\n    }\n    \n    # Extract JSDoc comments\n    jsdoc_pattern = r'/\\*\\*\\s*\\n(\\s*\\*\\s*[^\\n]*\\n)*\\s*\\*/\\s*\\n\\s*(?:function\\s+(\\w+)|class\\s+(\\w+))'\n    for match in re.finditer(jsdoc_pattern, content, re.DOTALL):\n        jsdoc, func_name, class_name = match.groups()\n        if func_name:\n            # Extract the function\n            docs['functions'].append({\n                'name': func_name,\n                'jsdoc': jsdoc.strip()\n            })\n        elif class_name:\n            # Extract the class\n            docs['classes'].append({\n                'name': class_name,\n                'jsdoc': jsdoc.strip()\n            })\n    \n    return docs\n"
        },
        {
          "id": "afdb468ca665",
          "name": "extract_go_docs",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
          "startLine": 89,
          "endLine": 106,
          "lineCount": 18,
          "parameters": [
            "content",
            "filename"
          ],
          "calls": [
            "extract_go_docs",
            "finditer",
            "groups",
            "append",
            "strip"
          ],
          "calledBy": [],
          "complexity": 3,
          "isExported": false,
          "isAsync": false,
          "docstring": "Extract documentation from Go code.",
          "body": "\ndef extract_go_docs(content, filename):\n    \"\"\"Extract documentation from Go code.\"\"\"\n    docs = {\n        'functions': []\n    }\n\n    # Extract Go-style comments for functions\n    func_pattern = r'//\\s*(\\w+)\\s*.*\\nfunc\\s+(\\w+)\\s*\\([^)]*\\)'\n    for match in re.finditer(func_pattern, content, re.DOTALL):\n        go_doc, func_name = match.groups()\n        docs['functions'].append({\n            'name': func_name,\n            'go_doc': go_doc.strip()\n        })\n\n    return docs\n"
        },
        {
          "id": "17ba90ca870a",
          "name": "extract_cpp_docs",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
          "startLine": 106,
          "endLine": 133,
          "lineCount": 28,
          "parameters": [
            "content",
            "filename"
          ],
          "calls": [
            "extract_cpp_docs",
            "n",
            "finditer",
            "groups",
            "append",
            "strip"
          ],
          "calledBy": [],
          "complexity": 5,
          "isExported": false,
          "isAsync": false,
          "docstring": "Extract documentation from C++ code.",
          "body": "\ndef extract_cpp_docs(content, filename):\n    \"\"\"Extract documentation from C++ code.\"\"\"\n    docs = {\n        'functions': [],\n        'classes': []\n    }\n\n    # Extract Doxygen-style comments for functions\n    func_pattern = r'/\\*!\\s*\\n(\\s*\\*\\s*[^\\n]*\\n)*\\s*\\*/\\s*\\n\\s*(?:[\\w\\s]+)\\s+(\\w+)\\s*\\([^)]*\\)'\n    for match in re.finditer(func_pattern, content, re.DOTALL):\n        doxygen, func_name = match.groups()\n        docs['functions'].append({\n            'name': func_name,\n            'doxygen': doxygen.strip()\n        })\n\n    # Extract Doxygen-style comments for classes\n    class_pattern = r'/\\*!\\s*\\n(\\s*\\*\\s*[^\\n]*\\n)*\\s*\\*/\\s*\\n\\s*class\\s+(\\w+)'\n    for match in re.finditer(class_pattern, content, re.DOTALL):\n        doxygen, class_name = match.groups()\n        docs['classes'].append({\n            'name': class_name,\n            'doxygen': doxygen.strip()\n        })\n\n    return docs\n"
        },
        {
          "id": "06d13057d835",
          "name": "extract_java_docs",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
          "startLine": 133,
          "endLine": 150,
          "lineCount": 18,
          "parameters": [
            "content",
            "filename"
          ],
          "calls": [
            "extract_java_docs",
            "n",
            "finditer",
            "groups",
            "append",
            "strip"
          ],
          "calledBy": [],
          "complexity": 2,
          "isExported": false,
          "isAsync": false,
          "docstring": "Extract documentation from Java code.",
          "body": "\ndef extract_java_docs(content, filename):\n    \"\"\"Extract documentation from Java code.\"\"\"\n    docs = {\n        'classes': []\n    }\n\n    # Extract Javadoc comments\n    javadoc_pattern = r'/\\*\\*\\s*\\n(\\s*\\*\\s*[^\\n]*\\n)*\\s*\\*/\\s*\\n\\s*(?:public|private|protected)?\\s*(?:static\\s+)?(?:final\\s+)?class\\s+(\\w+)'\n    for match in re.finditer(javadoc_pattern, content, re.DOTALL):\n        javadoc, class_name = match.groups()\n        docs['classes'].append({\n            'name': class_name,\n            'javadoc': javadoc.strip()\n        })\n\n    return docs\n"
        },
        {
          "id": "09b2167e8bce",
          "name": "generate_documentation",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
          "startLine": 150,
          "endLine": 187,
          "lineCount": 38,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "generate_documentation",
            "print_info",
            "print_header",
            "input",
            "directory",
            "makedirs",
            "get_repo_contents",
            "print_error",
            "json",
            "search"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 14,
          "isExported": false,
          "isAsync": false,
          "docstring": "Generate documentation from code comments with styled output.",
          "body": "\ndef generate_documentation(github_username, github_token, config, args=None):\n    \"\"\"Generate documentation from code comments with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would generate documentation from code comments.\")\n        return\n\n    print_header(\"Documentation Generator\")\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    output_dir = \"docs\"\n    if args and args.output:\n        output_dir = args.output\n    else:\n        output_dir_input = input(f\"Enter output directory (default: {output_dir}): \")\n        output_dir = output_dir_input if output_dir_input else output_dir\n    \n    print_info(f\"Generating documentation for {repo_name}...\")\n    print_info(f\"Output directory: {output_dir}\")\n    \n    # Create output directory if it doesn't exist\n    os.makedirs(output_dir, exist_ok=True)\n    \n    # Get repository contents\n    try:\n        response = get_repo_contents(github_username, repo_name, github_token)\n        if response.status_code != 200:\n            print_error(f\"Error accessing repository: {response.status_code}\")\n            return\n        \n        contents = response.json()\n        doc_content = f\"# Documentation for {repo_name}\\n\\n\"\n        doc_content += '''<input type=\"text\" id=\"search-bar\" onkeyup=\"search()\" placeholder=\"Search for names..\">\n"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
          "line": 2
        },
        {
          "source": "re",
          "specifiers": [
            "re"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
          "line": 3
        },
        {
          "source": "ast",
          "specifiers": [
            "ast"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
          "line": 4
        },
        {
          "source": "requests",
          "specifiers": [
            "requests"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
          "line": 5
        },
        {
          "source": "..github.api",
          "specifiers": [
            "get_repo_contents"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
          "line": 7
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header",
            "print_warning"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
          "line": 8
        }
      ],
      "exports": [],
      "complexity": 8,
      "lines": 377
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
      "language": "python",
      "functions": [
        {
          "id": "dead2b1f6009",
          "name": "get_git_author",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
          "startLine": 8,
          "endLine": 21,
          "lineCount": 14,
          "parameters": [
            "file_path",
            "line_num"
          ],
          "calls": [
            "get_git_author",
            "run",
            "splitlines",
            "startswith",
            "replace",
            "strip"
          ],
          "calledBy": [
            "65c5d1c696bf"
          ],
          "complexity": 5,
          "isExported": false,
          "isAsync": false,
          "docstring": "Extracts the author's email for a specific line using git blame.",
          "body": "\ndef get_git_author(file_path, line_num):\n    \"\"\"Extracts the author's email for a specific line using git blame.\"\"\"\n    try:\n        # porcelain format is easier to parse programmatically\n        cmd = [\"git\", \"blame\", \"-L\", f\"{line_num},{line_num}\", \"--porcelain\", file_path]\n        result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n        for line in result.stdout.splitlines():\n            if line.startswith(\"author-mail \"):\n                return line.replace(\"author-mail <\", \"\").replace(\">\", \"\").strip()\n    except Exception:\n        return None\n    return None\n"
        },
        {
          "id": "03393b735f64",
          "name": "get_code_context",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
          "startLine": 21,
          "endLine": 33,
          "lineCount": 13,
          "parameters": [
            "file_path",
            "line_num",
            "window"
          ],
          "calls": [
            "get_code_context",
            "open",
            "readlines",
            "max",
            "min",
            "join"
          ],
          "calledBy": [
            "65c5d1c696bf"
          ],
          "complexity": 3,
          "isExported": false,
          "isAsync": false,
          "docstring": "Grabs a few lines of code around the TODO for better issue context.",
          "body": "\ndef get_code_context(file_path, line_num, window=3):\n    \"\"\"Grabs a few lines of code around the TODO for better issue context.\"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            lines = f.readlines()\n            start = max(0, line_num - window - 1)\n            end = min(len(lines), line_num + window)\n            snippet = \"\".join(lines[start:end])\n            return f\"```python\\n{snippet}\\n```\"\n    except Exception:\n        return \"Context unavailable.\"\n"
        },
        {
          "id": "65c5d1c696bf",
          "name": "scan_todos",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
          "startLine": 33,
          "endLine": 129,
          "lineCount": 97,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "scan_todos",
            "print_info",
            "input",
            "patterns",
            "split",
            "get_issues",
            "json",
            "print_warning",
            "strip",
            "glob",
            "isfile",
            "open",
            "search",
            "group",
            "get_git_author",
            "get_code_context",
            "append",
            "print_success",
            "search_user_by_email",
            "get",
            "create_issue",
            "print_error"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 39,
          "isExported": false,
          "isAsync": false,
          "docstring": "Advanced TODO scanner with Git Blame and Context support.",
          "body": "\ndef scan_todos(github_username, github_token, config, args=None):\n    \"\"\"Advanced TODO scanner with Git Blame and Context support.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: Scanning but not creating issues. ***\")\n\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    pattern_input = args.pattern if args and args.pattern else input(\"Enter file patterns (e.g., *.py,*.js) [*.py]: \")\n    file_patterns = pattern_input.split(\",\") if pattern_input else [\"*.py\"]\n    \n    print_info(f\"Scanning for TODOs in {repo_name} using patterns {file_patterns}...\")\n\n    # Fetch existing issues to avoid duplicates\n    print_info(\"Checking existing issues to prevent duplicates...\")\n    existing_titles = []\n    try:\n        issue_resp = get_issues(github_username, repo_name, github_token, state='all')\n        if issue_resp.status_code == 200:\n            existing_titles = [i['title'] for i in issue_resp.json()]\n    except Exception:\n        print_warning(\"Could not fetch existing issues. Duplicate detection disabled.\")\n\n    found_todos = []\n    for pattern in file_patterns:\n        # Clean pattern for glob\n        clean_pattern = pattern.strip()\n        for file_path in glob.glob(clean_pattern, recursive=True):\n            if os.path.isfile(file_path) and \".git\" not in file_path:\n                try:\n                    with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                        for line_num, line in enumerate(f, 1):\n                            if \"TODO\" in line:\n                                match = re.search(r'TODO:(.*)', line, re.IGNORECASE)\n                                if match:\n                                    comment = match.group(1).strip()\n                                    author = get_git_author(file_path, line_num)\n                                    context = get_code_context(file_path, line_num)\n                                    found_todos.append({\n                                        \"file\": file_path,\n                                        \"line\": line_num,\n                                        \"comment\": comment,\n                                        \"author\": author,\n                                        \"context\": context\n                                    })\n                except Exception as e:\n                    print_warning(f\"Skipping {file_path}: {e}\")\n\n    if not found_todos:\n        print_success(\"Clean sweep! No TODOs found.\")\n        return\n\n    print_info(f\"Found {len(found_todos)} TODOs. Processing...\")\n    \n    created_count = 0\n    for todo in found_todos:\n        title = f\"TODO: {todo['comment'][:50]}\" # Cap title length\n        if title in existing_titles:\n            print_warning(f\"Skipping duplicate issue: {title}\")\n            continue\n\n        body = f\"### Description\\n{todo['comment']}\\n\\n\"\n        body += f\"### Location\\n- **File:** `{todo['file']}`\\n- **Line:** {todo['line']}\\n\"\n        if todo['author']:\n            body += f\"- **Blame:** {todo['author']}\\n\"\n        \n        body += f\"\\n### Context\\n{todo['context']}\\n\\n\"\n        body += \"_Generated automatically by PyGitUp Smart Issue engine._\"\n\n        if args and args.dry_run:\n            print(f\"[DRY-RUN] Would create issue: {title}\")\n            created_count += 1\n            continue\n\n        # Real-Time Identity Resolution: Map email to actual GitHub username\n        resolved_assignees = [name.strip() for name in args.assign.split(\",\")] if args and args.assign else []\n        if todo['author']:\n            user_resp = search_user_by_email(todo['author'], github_token)\n            if user_resp.status_code == 200:\n                items = user_resp.json().get('items', [])\n                if items:\n                    gh_username = items[0]['login']\n                    if gh_username not in resolved_assignees:\n                        resolved_assignees.append(gh_username)\n                        print_info(f\"Resolved author email {todo['author']} to @{gh_username}\")\n\n        response = create_issue(github_username, repo_name, github_token, title, body, resolved_assignees)\n        if response.status_code == 201:\n            print_success(f\"Created issue: {title}\")\n            created_count += 1\n        else:\n            print_error(f\"Failed to create issue '{title}': {response.status_code}\")\n\n    print_success(f\"Operation complete. {created_count} new issues processed.\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "glob",
          "specifiers": [
            "glob"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
          "line": 1
        },
        {
          "source": "re",
          "specifiers": [
            "re"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
          "line": 2
        },
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
          "line": 3
        },
        {
          "source": "subprocess",
          "specifiers": [
            "subprocess"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
          "line": 4
        },
        {
          "source": "hashlib",
          "specifiers": [
            "hashlib"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
          "line": 5
        },
        {
          "source": "..github.api",
          "specifiers": [
            "create_issue",
            "get_issues",
            "search_user_by_email"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
          "line": 6
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_warning"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
          "line": 7
        }
      ],
      "exports": [],
      "complexity": 16,
      "lines": 130
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
      "language": "python",
      "functions": [
        {
          "id": "1eb3727820d9",
          "name": "get_project_directory_input",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 14,
          "endLine": 48,
          "lineCount": 35,
          "parameters": [
            "config",
            "args"
          ],
          "calls": [
            "get_project_directory_input",
            "input",
            "repository",
            "lower"
          ],
          "calledBy": [
            "44f568d20b70"
          ],
          "complexity": 17,
          "isExported": false,
          "isAsync": false,
          "docstring": "Gets user input for the project upload details.",
          "body": "\ndef get_project_directory_input(config, args=None):\n    \"\"\"Gets user input for the project upload details.\"\"\"\n    if args and args.path:\n        project_path = args.path\n    else:\n        project_path = input(\"Enter the full path to your project directory: \")\n    \n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter the desired name for your GitHub repository: \")\n    \n    if args and args.description is not None:\n        repo_description = args.description\n    else:\n        default_desc = config[\"github\"][\"default_description\"]\n        repo_description = input(f\"Enter a description for your repository (default: {default_desc}): \")\n        if not repo_description:\n            repo_description = default_desc\n    \n    if args and args.private is not None:\n        is_private = args.private\n    else:\n        default_private = config[\"github\"][\"default_private\"]\n        is_private_input = input(f\"Make the repository private? (y/n, default: {'y' if default_private else 'n'}): \").lower()\n        if is_private_input in ['y', 'yes']:\n            is_private = True\n        elif is_private_input in ['n', 'no']:\n            is_private = False\n        else:\n            is_private = default_private\n\n    return project_path, repo_name, repo_description, is_private\n"
        },
        {
          "id": "df849b43f31d",
          "name": "initialize_git_repository",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 48,
          "endLine": 73,
          "lineCount": 26,
          "parameters": [
            "project_path"
          ],
          "calls": [
            "initialize_git_repository",
            "chdir",
            "print_info",
            "isdir",
            "run",
            "print_success",
            "print_error",
            "exit"
          ],
          "calledBy": [
            "44f568d20b70"
          ],
          "complexity": 6,
          "isExported": false,
          "isAsync": false,
          "docstring": "Initializes a git repository in the specified directory.",
          "body": "\ndef initialize_git_repository(project_path):\n    \"\"\"Initializes a git repository in the specified directory.\"\"\"\n    try:\n        os.chdir(project_path)\n        print_info(f\"Changed directory to {project_path}\")\n        if not os.path.isdir(\".git\"):\n            subprocess.run([\"git\", \"init\"], check=True)\n            print_success(\"Initialized empty Git repository.\")\n        else:\n            print_info(\"This is already a git repository.\")\n        subprocess.run([\"git\", \"add\", \".\"], check=True)\n        print_info(\"Staged all files.\")\n        status_result = subprocess.run([\"git\", \"status\", \"--porcelain\"], capture_output=True, text=True)\n        if status_result.stdout:\n             subprocess.run([\"git\", \"commit\", \"-m\", \"Initial commit\"], check=True)\n             print_success(\"Committed files.\")\n        else:\n            print_info(\"No changes to commit. Working tree clean.\")\n    except FileNotFoundError:\n        print_error(f\"Error: The directory '{project_path}' does not exist.\")\n        sys.exit(1)\n    except subprocess.CalledProcessError as e:\n        print_error(f\"An error occurred while running a git command: {e}\")\n        sys.exit(1)\n"
        },
        {
          "id": "4ac56e6829e2",
          "name": "create_or_get_github_repository",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 73,
          "endLine": 88,
          "lineCount": 16,
          "parameters": [
            "repo_name",
            "repo_description",
            "is_private",
            "github_username",
            "github_token"
          ],
          "calls": [
            "create_or_get_github_repository",
            "get_repo_info",
            "print_info",
            "json",
            "create_repo",
            "print_success",
            "print_error",
            "exit"
          ],
          "calledBy": [
            "44f568d20b70",
            "6b700cc8d9be"
          ],
          "complexity": 4,
          "isExported": false,
          "isAsync": false,
          "docstring": "Creates a new repository on GitHub or confirms an existing one.",
          "body": "\ndef create_or_get_github_repository(repo_name, repo_description, is_private, github_username, github_token):\n    \"\"\"Creates a new repository on GitHub or confirms an existing one.\"\"\"\n    response = get_repo_info(github_username, repo_name, github_token)\n    if response.status_code == 200:\n        print_info(f\"Repository '{repo_name}' already exists on GitHub. Using existing repository.\")\n        return response.json()\n    \n    response = create_repo(github_username, repo_name, github_token, description=repo_description, private=is_private)\n    if response.status_code == 201:\n        print_success(f\"Successfully created repository '{repo_name}' on GitHub.\")\n        return response.json()\n    else:\n        print_error(f\"Error creating repository: {response.status_code} - {response.text}\")\n        sys.exit(1)\n"
        },
        {
          "id": "402517011038",
          "name": "push_to_github",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 88,
          "endLine": 112,
          "lineCount": 25,
          "parameters": [
            "repo_name",
            "github_username",
            "github_token"
          ],
          "calls": [
            "push_to_github",
            "run",
            "splitlines",
            "strip",
            "print_info",
            "print_success",
            "print_error",
            "exit"
          ],
          "calledBy": [
            "44f568d20b70"
          ],
          "complexity": 8,
          "isExported": false,
          "isAsync": false,
          "docstring": "Adds the remote and force pushes to the new repository.",
          "body": "\ndef push_to_github(repo_name, github_username, github_token):\n    \"\"\"Adds the remote and force pushes to the new repository.\"\"\"\n    remote_url = f\"https://{github_username}:{github_token}@github.com/{github_username}/{repo_name}.git\"\n    safe_remote_url = f\"https://github.com/{github_username}/{repo_name}.git\"\n    try:\n        result = subprocess.run([\"git\", \"remote\"], capture_output=True, text=True)\n        if \"origin\" in result.stdout.splitlines():\n            existing_url_result = subprocess.run([\"git\", \"remote\", \"get-url\", \"origin\"], capture_output=True, text=True, check=True)\n            if existing_url_result.stdout.strip() != remote_url and existing_url_result.stdout.strip() != safe_remote_url:\n                subprocess.run([\"git\", \"remote\", \"set-url\", \"origin\", remote_url], check=True)\n            else:\n                subprocess.run([\"git\", \"remote\", \"set-url\", \"origin\", remote_url], check=True)\n        else:\n            subprocess.run([\"git\", \"remote\", \"add\", \"origin\", remote_url], check=True)\n        branch_result = subprocess.run([\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"], capture_output=True, text=True, check=True)\n        if branch_result.stdout.strip() != \"main\":\n            subprocess.run([\"git\", \"branch\", \"-M\", \"main\"], check=True)\n        print_info(\"Pushing to GitHub with force...\")\n        subprocess.run([\"git\", \"push\", \"-u\", \"--force\", \"origin\", \"main\"], check=True)\n        print_success(\"Pushed to GitHub.\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"An error occurred while pushing to GitHub: {e}\")\n        sys.exit(1)\n"
        },
        {
          "id": "44f568d20b70",
          "name": "upload_project_directory",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 112,
          "endLine": 143,
          "lineCount": 32,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "upload_project_directory",
            "print_info",
            "print_header",
            "get_project_directory_input",
            "validate_file_path",
            "print_error",
            "validate_repo_name",
            "scan_directory_for_sensitive_files",
            "print_warning",
            "initialize_git_repository",
            "create_or_get_github_repository",
            "push_to_github"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 7,
          "isExported": false,
          "isAsync": false,
          "docstring": "Handles the entire process of uploading/updating a project directory.",
          "body": "\ndef upload_project_directory(github_username, github_token, config, args=None):\n    \"\"\"Handles the entire process of uploading/updating a project directory.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would initialize git repository, create/get GitHub repository, and push to GitHub.\")\n        return\n\n    print_header(\"Upload Project Directory\")\n    project_path, repo_name, repo_description, is_private = get_project_directory_input(config, args)\n    \n    # Input Validation\n    is_valid_path, path_err = validate_file_path(project_path)\n    if not is_valid_path:\n        print_error(f\"Error: {path_err}\")\n        return\n\n    is_valid_repo, repo_err = validate_repo_name(repo_name)\n    if not is_valid_repo:\n        print_error(f\"Error: {repo_err}\")\n        return\n\n    # Run security scan on the directory\n    if not scan_directory_for_sensitive_files(project_path):\n        print_warning(\"Upload cancelled due to security check.\")\n        return\n\n    initialize_git_repository(project_path)\n    create_or_get_github_repository(repo_name, repo_description, is_private, github_username, github_token)\n    push_to_github(repo_name, github_username, github_token)\n    print_info(f\"You can find your repository at: https://github.com/{github_username}/{repo_name}\")\n"
        },
        {
          "id": "8cdb7133190e",
          "name": "get_single_file_input",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 143,
          "endLine": 204,
          "lineCount": 62,
          "parameters": [
            "config",
            "args"
          ],
          "calls": [
            "get_single_file_input",
            "input",
            "print_info",
            "print_header",
            "getcwd",
            "listdir",
            "isfile",
            "print_error",
            "interactively",
            "repository",
            "message"
          ],
          "calledBy": [
            "b9152e2e05f3"
          ],
          "complexity": 21,
          "isExported": false,
          "isAsync": false,
          "docstring": "Gets user input for the file upload details.",
          "body": "\ndef get_single_file_input(config, args=None):\n    \"\"\"Gets user input for the file upload details.\"\"\"\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter the name of the target GitHub repository: \")\n\n    if args and args.file:\n        local_file_path = args.file\n        print_info(f\"Selected file: {local_file_path}\")\n    else:\n        print_header(\"Select a file to upload\")\n        local_file_path = None\n        try:\n            current_directory = os.getcwd()\n            print_info(f\"Listing files in: {current_directory}\")\n            \n            files = [item for item in os.listdir('.') if os.path.isfile(item)]\n\n            if not files:\n                print_info(\"No files found in the current directory.\")\n            else:\n                for i, filename in enumerate(files):\n                    print(f\"{i + 1}: {filename}\")\n                \n                print(\"\\nEnter the number of the file to upload, or type a different path manually.\")\n                choice = input(\"> \")\n\n                try:\n                    file_index = int(choice) - 1\n                    if 0 <= file_index < len(files):\n                        local_file_path = files[file_index]\n                        print_info(f\"You selected: {local_file_path}\")\n                    else:\n                        print_error(\"Invalid number.\")\n                except ValueError:\n                    local_file_path = choice\n                    print_info(f\"You entered path: {local_file_path}\")\n\n        except Exception as e:\n            print_error(f\"Could not list files interactively ({e}).\")\n\n    if not local_file_path:\n        print_info(\"Please provide the file path manually.\")\n        local_file_path = input(\"Enter the full local path of the file to upload: \")\n\n    if args and args.path:\n        repo_file_path = args.path\n    else:\n        repo_file_path = input(\"Enter the path for the file in the repository (e.g., folder/file.txt): \")\n\n    if args and args.message:\n        commit_message = args.message\n    else:\n        default_msg = config[\"defaults\"][\"commit_message\"]\n        commit_message = input(f\"Enter the commit message (default: {default_msg}): \")\n        if not commit_message:\n            commit_message = default_msg\n\n    return repo_name, local_file_path, repo_file_path, commit_message\n"
        },
        {
          "id": "b9152e2e05f3",
          "name": "upload_single_file",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 204,
          "endLine": 277,
          "lineCount": 74,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "upload_single_file",
            "print_info",
            "get_single_file_input",
            "print_header",
            "validate_file_path",
            "print_error",
            "validate_repo_name",
            "check_is_sensitive",
            "print_warning",
            "input",
            "lower",
            "open",
            "getsize",
            "tqdm",
            "read",
            "update",
            "exit",
            "get_file_info",
            "json",
            "update_file",
            "print_success"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 23,
          "isExported": false,
          "isAsync": false,
          "docstring": "Handles the entire process of uploading/updating a single file.",
          "body": "\ndef upload_single_file(github_username, github_token, config, args=None):\n    \"\"\"Handles the entire process of uploading/updating a single file.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        repo_name, local_file_path, repo_file_path, commit_message = get_single_file_input(config, args)\n        print_info(f\"Would upload {local_file_path} to {repo_name}/{repo_file_path} with message: {commit_message}\")\n        return\n\n    print_header(\"Upload Single File\")\n    repo_name, local_file_path, repo_file_path, commit_message = get_single_file_input(config, args)\n\n    # Input Validation\n    is_valid_path, path_err = validate_file_path(local_file_path)\n    if not is_valid_path:\n        print_error(f\"Error: {path_err}\")\n        return False\n\n    is_valid_repo, repo_err = validate_repo_name(repo_name)\n    if not is_valid_repo:\n        print_error(f\"Error: {repo_err}\")\n        return False\n\n    if check_is_sensitive(local_file_path):\n        print_warning(f\"'{local_file_path}' appears to be a sensitive file.\")\n        confirm = input(\"Are you sure you want to upload it? (y/n): \").lower()\n        if confirm != 'y':\n            print_info(\"Upload cancelled.\")\n            return False\n\n    try:\n        with open(local_file_path, \"rb\") as f:\n            if TQDM_AVAILABLE:\n                file_size = os.path.getsize(local_file_path)\n                with tqdm(total=file_size, unit='B', unit_scale=True, desc=\"Reading file\") as pbar:\n                    content = f.read()\n                    pbar.update(len(content))\n            else:\n                content = f.read()\n    except FileNotFoundError:\n        print_error(f\"Error: The local file '{local_file_path}' was not found.\")\n        if not args or not args.batch:\n            sys.exit(1)\n        return False\n    except Exception as e:\n        print_error(f\"Error reading file: {e}\")\n        if not args or not args.batch:\n            sys.exit(1)\n        return False\n\n    sha = None\n    response = get_file_info(github_username, repo_name, repo_file_path, github_token)\n    if response.status_code == 200:\n        print_info(\"File exists in the repository. It will be overwritten.\")\n        sha = response.json()['sha']\n    elif response.status_code != 404:\n        print_error(f\"Error checking for file: {response.status_code} - {response.text}\")\n        if not args or not args.batch:\n            sys.exit(1)\n        return False\n\n    response = update_file(github_username, repo_name, repo_file_path, content, github_token, commit_message, sha)\n    if response.status_code == 201:\n        print_success(f\"Successfully created file '{repo_file_path}' in '{repo_name}'.\")\n    elif response.status_code == 200:\n        print_success(f\"Successfully updated file '{repo_file_path}' in '{repo_name}'.\")\n    else:\n        print_error(f\"Error uploading file: {response.status_code} - {response.text}\")\n        if not args or not args.batch:\n            sys.exit(1)\n        return False\n    print_info(f\"View the file at: {response.json()['content']['html_url']}\")\n    return True\n"
        },
        {
          "id": "b065ed988f67",
          "name": "get_batch_files_input",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 277,
          "endLine": 318,
          "lineCount": 42,
          "parameters": [
            "config",
            "args"
          ],
          "calls": [
            "get_batch_files_input",
            "strip",
            "split",
            "print_header",
            "input",
            "lower",
            "listdir",
            "isfile",
            "print_error",
            "repository",
            "message"
          ],
          "calledBy": [
            "8aecc87cfbd7"
          ],
          "complexity": 22,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get files for batch upload.",
          "body": "\ndef get_batch_files_input(config, args=None):\n    \"\"\"Get files for batch upload.\"\"\"\n    if args and args.files:\n        files = [f.strip() for f in args.files.split(',') if f.strip()]\n    else:\n        print_header(\"Select files for batch upload\")\n        print(\"Enter file paths separated by commas, or 'all' for all files in directory:\")\n        files_input = input(\"> \").strip()\n        \n        if files_input.lower() == 'all':\n            files = [item for item in os.listdir('.') if os.path.isfile(item)]\n        else:\n            files = [f.strip() for f in files_input.split(',') if f.strip()]\n    \n    if not files:\n        print_error(\"No files specified.\")\n        return None, None, None, None\n    \n    repo_name = None\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter the name of the target GitHub repository: \")\n    \n    repo_base_path = \"\"\n    if args and args.path:\n        repo_base_path = args.path\n    else:\n        repo_base_path = input(\"Enter base path in repository (optional, e.g., src/): \")\n    \n    default_msg = config[\"defaults\"][\"commit_message\"]\n    commit_message = \"\"\n    if args and args.message:\n        commit_message = args.message\n    else:\n        commit_message = input(f\"Enter the commit message (default: {default_msg}): \")\n        if not commit_message:\n            commit_message = default_msg\n    \n    return files, repo_name, repo_base_path, commit_message\n"
        },
        {
          "id": "8aecc87cfbd7",
          "name": "upload_batch_files",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 318,
          "endLine": 381,
          "lineCount": 64,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "upload_batch_files",
            "print_info",
            "get_batch_files_input",
            "audit_files_and_prompt",
            "print_warning",
            "tqdm",
            "join",
            "basename",
            "replace",
            "open",
            "read",
            "get_file_info",
            "json",
            "update_file",
            "print_error",
            "print_success"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 17,
          "isExported": false,
          "isAsync": false,
          "docstring": "Upload multiple files in batch with styled output.",
          "body": "\ndef upload_batch_files(github_username, github_token, config, args=None):\n    \"\"\"Upload multiple files in batch with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        files, repo_name, repo_base_path, commit_message = get_batch_files_input(config, args)\n        print_info(f\"Would upload {len(files)} files to {repo_name} in batch.\")\n        return\n\n    files, repo_name, repo_base_path, commit_message = get_batch_files_input(config, args)\n    \n    if not files:\n        return\n\n    # Security check for batch files\n    files = audit_files_and_prompt(files)\n    if not files:\n        print_warning(\"No files to upload after security check.\")\n        return\n    \n    print_info(f\"\\nUploading {len(files)} files to {repo_name}...\")\n    \n    file_iterator = tqdm(files, desc=\"Uploading files\") if TQDM_AVAILABLE else files\n    \n    success_count = 0\n    fail_count = 0\n    \n    for local_file in file_iterator:\n        try:\n            if repo_base_path:\n                repo_file_path = os.path.join(repo_base_path, os.path.basename(local_file)).replace(\"\\\\\", \"/\")\n            else:\n                repo_file_path = os.path.basename(local_file)\n            \n            # Use upload_single_file logic but adapted for batch\n            # We skip some input gathering and validation already done\n            \n            with open(local_file, \"rb\") as f:\n                content = f.read()\n            \n            sha = None\n            f_info = get_file_info(github_username, repo_name, repo_file_path, github_token)\n            if f_info.status_code == 200:\n                sha = f_info.json()['sha']\n            \n            response = update_file(github_username, repo_name, repo_file_path, content, github_token, commit_message, sha)\n            \n            if response.status_code in [200, 201]:\n                success_count += 1\n            else:\n                print_error(f\"Failed to upload {local_file}: {response.status_code}\")\n                fail_count += 1\n                if not config[\"batch\"][\"continue_on_error\"]:\n                    print_warning(\"Stopping batch upload due to error.\")\n                    break\n                    \n        except Exception as e:\n            print_error(f\"Error uploading {local_file}: {e}\")\n            fail_count += 1\n            if not config[\"batch\"][\"continue_on_error\"]:\n                break\n    \n    print_success(f\"\\nBatch upload complete: {success_count} succeeded, {fail_count} failed.\")\n"
        },
        {
          "id": "985fa21cb145",
          "name": "get_multi_repo_input",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 381,
          "endLine": 408,
          "lineCount": 28,
          "parameters": [
            "config",
            "args"
          ],
          "calls": [
            "get_multi_repo_input",
            "strip",
            "split",
            "input",
            "message"
          ],
          "calledBy": [
            "44098917418d"
          ],
          "complexity": 13,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get multi-repository input.",
          "body": "\ndef get_multi_repo_input(config, args=None):\n    \"\"\"Get multi-repository input.\"\"\"\n    if args and args.multi_repo:\n        repo_names = [name.strip() for name in args.multi_repo.split(\",\")]\n    else:\n        repo_input = input(\"Enter repository names separated by commas: \")\n        repo_names = [name.strip() for name in repo_input.split(\",\")]\n    \n    if args and args.file:\n        file_path = args.file\n    else:\n        file_path = input(\"Enter local file to upload: \")\n    \n    if args and args.path:\n        repo_file_path = args.path\n    else:\n        repo_file_path = input(\"Enter repository file path: \")\n    \n    if args and args.message:\n        commit_message = args.message\n    else:\n        default_msg = config[\"defaults\"][\"commit_message\"]\n        msg_input = input(f\"Enter commit message (default: {default_msg}): \")\n        commit_message = msg_input if msg_input else default_msg\n    \n    return repo_names, file_path, repo_file_path, commit_message\n"
        },
        {
          "id": "44098917418d",
          "name": "update_multiple_repos",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 408,
          "endLine": 468,
          "lineCount": 61,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "update_multiple_repos",
            "print_info",
            "get_multi_repo_input",
            "print_header",
            "check_is_sensitive",
            "print_warning",
            "input",
            "lower",
            "exists",
            "print_error",
            "open",
            "read",
            "get_file_info",
            "json",
            "get",
            "update_file",
            "print_success"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 14,
          "isExported": false,
          "isAsync": false,
          "docstring": "Update the same file across multiple repositories with styled output.",
          "body": "\ndef update_multiple_repos(github_username, github_token, config, args=None):\n    \"\"\"Update the same file across multiple repositories with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        repo_names, file_path, repo_file_path, commit_message = get_multi_repo_input(config, args)\n        print_info(f\"Would update {file_path} in {len(repo_names)} repositories.\")\n        return\n\n    print_header(\"Multi-Repository Update\")\n    repo_names, file_path, repo_file_path, commit_message = get_multi_repo_input(config, args)\n    \n    # Security check\n    if check_is_sensitive(file_path):\n        print_warning(f\"'{file_path}' appears to be a sensitive file.\")\n        confirm = input(\"Are you sure you want to update this file across multiple repositories? (y/n): \").lower()\n        if confirm != 'y':\n            print_info(\"Multi-repo update cancelled.\")\n            return\n\n    # Filter out any empty repository names that might result from trailing commas\n    repo_names = [name for name in repo_names if name]\n\n    if not os.path.exists(file_path):\n        print_error(f\"File '{file_path}' not found.\")\n        return\n    \n    print_info(f\"Updating {file_path} in {len(repo_names)} repositories...\")\n    \n    try:\n        with open(file_path, \"rb\") as f:\n            file_content = f.read()\n    except Exception as e:\n        print_error(f\"Error reading file: {e}\")\n        return\n    \n    success_count = 0\n    for repo_name in repo_names:\n        try:\n            # Check if file exists to get SHA\n            response = get_file_info(github_username, repo_name, repo_file_path, github_token)\n            sha = None\n            if response.status_code == 200:\n                sha = response.json().get('sha')\n            \n            # Update file\n            update_response = update_file(\n                github_username, repo_name, repo_file_path,\n                file_content, github_token, commit_message, sha\n            )\n            \n            if update_response.status_code in [200, 201]:\n                print_success(f\"Updated {repo_file_path} in {repo_name}\")\n                success_count += 1\n            else:\n                print_error(f\"Failed to update {repo_file_path} in {repo_name}: {update_response.status_code}\")\n        except Exception as e:\n            print_error(f\"Error updating {repo_name}: {e}\")\n    \n    print_success(f\"Multi-repository update complete: {success_count}/{len(repo_names)} successful.\")\n"
        },
        {
          "id": "6b700cc8d9be",
          "name": "migrate_repository",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 472,
          "endLine": 506,
          "lineCount": 35,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "migrate_repository",
            "print_header",
            "input",
            "URL",
            "lower",
            "print_info",
            "create_or_get_github_repository",
            "mkdtemp",
            "clone",
            "run",
            "chdir",
            "GitHub",
            "print_success",
            "print_error",
            "rmtree",
            "dirname",
            "abspath"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 15,
          "isExported": false,
          "isAsync": false,
          "docstring": "Mirror a repository from any source to GitHub with full history.",
          "body": "\ndef migrate_repository(github_username, github_token, config, args=None):\n    \"\"\"Mirror a repository from any source to GitHub with full history.\"\"\"\n    print_header(\"The Great Migration Porter\")\n    \n    src_url = args.url if args and hasattr(args, 'url') and args.url else input(\"üîó Enter Source Repository URL (GitLab/Bitbucket/etc): \")\n    dest_name = args.repo if args and hasattr(args, 'repo') and args.repo else input(\"üì¶ Enter Destination GitHub Repository Name: \")\n    \n    is_private = args.private if args and hasattr(args, 'private') else input(\"üîí Make destination private? (y/n) [y]: \").lower() != 'n'\n\n    print_info(f\"Establishing destination on GitHub...\")\n    # Ensure dest exists\n    create_or_get_github_repository(dest_name, f\"Mirrored from {src_url}\", is_private, github_username, github_token)\n    \n    dest_url = f\"https://{github_username}:{github_token}@github.com/{github_username}/{dest_name}.git\"\n    \n    # Use a temporary directory for the mirror operation\n    temp_dir = tempfile.mkdtemp()\n    try:\n        print_info(\"Performing mirror clone (this may take time for large repos)...\")\n        subprocess.run([\"git\", \"clone\", \"--mirror\", src_url, temp_dir], check=True)\n        \n        os.chdir(temp_dir)\n        print_info(\"Pushing mirror to GitHub (preserving all branches/tags)...\")\n        subprocess.run([\"git\", \"push\", \"--mirror\", dest_url], check=True)\n        \n        print_success(f\"\\nMigration Successful! üöÄ\")\n        print_info(f\"View it at: https://github.com/{github_username}/{dest_name}\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Migration failed during git operation: {e}\")\n    finally:\n        # Cleanup\n        shutil.rmtree(temp_dir, ignore_errors=True)\n        os.chdir(os.path.dirname(os.path.abspath(__file__))) # Back to relative safety\n"
        },
        {
          "id": "1f4213d37548",
          "name": "manage_bulk_repositories",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "startLine": 506,
          "endLine": 543,
          "lineCount": 38,
          "parameters": [
            "github_token"
          ],
          "calls": [
            "manage_bulk_repositories",
            "print_header",
            "print_info",
            "get_user_repos",
            "print_error",
            "json",
            "print_success",
            "get",
            "growth",
            "tanh",
            "max",
            "min"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 8,
          "isExported": false,
          "isAsync": false,
          "docstring": "List all repositories and show aggregated health scores.",
          "body": "\ndef manage_bulk_repositories(github_token):\n    \"\"\"List all repositories and show aggregated health scores.\"\"\"\n    print_header(\"Bulk Repository Management\")\n    print_info(\"Fetching all your repositories...\")\n    \n    try:\n        response = get_user_repos(github_token)\n        if response.status_code != 200:\n            print_error(f\"Failed to fetch repos: {response.status_code}\")\n            return\n            \n        repos = response.json()\n        print_success(f\"Found {len(repos)} repositories.\\n\")\n        \n        print(f\"{ 'Repository Name':<40} | {'Stars':<6} | {'Issues':<6} | {'Score':<6}\")\n        print(\"-\" * 65)\n        \n        import math\n        for r in repos:\n            stars = r.get('stargazers_count', 0)\n            issues = r.get('open_issues_count', 0)\n            \n            # Sophisticated Health Logic:\n            # 1. Star Weight: Logarithmic growth (tanh caps it)\n            # 2. Issue Penalty: Non-linear decay based on star-to-issue ratio\n            star_impact = math.tanh(stars / 50.0) * 70  # Max 70 points from stars\n            issue_ratio = issues / (stars + 1)\n            issue_penalty = math.tanh(issue_ratio) * 30 # Max 30 point penalty\n            \n            health_score = int(30 + star_impact - issue_penalty) # Baseline of 30\n            health_score = max(0, min(100, health_score))\n            \n            color = \"green\" if health_score > 75 else \"yellow\" if health_score > 45 else \"red\"\n            print(f\"{r['name']:<40} | {stars:<6} | {issues:<6} | [{color}]{health_score}%[/{color}]\")\n            \n    except Exception as e:\n        print_error(f\"Bulk operation failed: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "line": 2
        },
        {
          "source": "subprocess",
          "specifiers": [
            "subprocess"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "line": 3
        },
        {
          "source": "sys",
          "specifiers": [
            "sys"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "line": 4
        },
        {
          "source": "base64",
          "specifiers": [
            "base64"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "line": 5
        },
        {
          "source": "math",
          "specifiers": [
            "math"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "line": 469
        },
        {
          "source": "shutil",
          "specifiers": [
            "shutil"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "line": 470
        },
        {
          "source": "tempfile",
          "specifiers": [
            "tempfile"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "line": 471
        },
        {
          "source": "tqdm",
          "specifiers": [
            "tqdm"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "line": 6
        },
        {
          "source": "..github.api",
          "specifiers": [
            "update_file",
            "get_file_info",
            "create_repo",
            "get_repo_info",
            "get_user_repos"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "line": 8
        },
        {
          "source": "..utils.security",
          "specifiers": [
            "scan_directory_for_sensitive_files",
            "audit_files_and_prompt",
            "check_is_sensitive"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "line": 9
        },
        {
          "source": "..utils.validation",
          "specifiers": [
            "validate_repo_name",
            "validate_file_path",
            "sanitize_input"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "line": 10
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_header",
            "print_info",
            "print_success",
            "print_error",
            "print_warning"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
          "line": 11
        }
      ],
      "exports": [],
      "complexity": 13,
      "lines": 544
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
      "language": "python",
      "functions": [
        {
          "id": "5285545074d8",
          "name": "main",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
          "startLine": 40,
          "endLine": 43,
          "lineCount": 4,
          "parameters": [],
          "calls": [
            "main"
          ],
          "calledBy": [],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "body": "\ndef main():\n    print(\"Hello from {{PROJECT_NAME}}!\")\n"
        },
        {
          "id": "09ae5dd659db",
          "name": "get_template_input",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
          "startLine": 77,
          "endLine": 116,
          "lineCount": 40,
          "parameters": [
            "config",
            "args"
          ],
          "calls": [
            "get_template_input",
            "keys",
            "input",
            "split",
            "strip",
            "get_github_username"
          ],
          "calledBy": [
            "3831ab37da60"
          ],
          "complexity": 15,
          "isExported": false,
          "isAsync": false,
          "docstring": "Get template input from user or arguments.",
          "body": "\ndef get_template_input(config, args=None):\n    \"\"\"Get template input from user or arguments.\"\"\"\n    if args and args.template:\n        template_name = args.template\n    else:\n        print(\"\\n--- Available Templates ---\")\n        for template in DEFAULT_TEMPLATES.keys():\n            print(f\"- {template}\")\n        template_name = input(\"Enter template name: \")\n    \n    if template_name not in DEFAULT_TEMPLATES:\n        print(f\"Template '{template_name}' not found.\")\n        return None, None, None, None\n    \n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    # Get variables\n    variables = {}\n    if args and args.variables:\n        # Parse variables from command line\n        var_pairs = args.variables.split(\",\")\n        for pair in var_pairs:\n            if \"=\" in pair:\n                key, value = pair.split(\"=\", 1)\n                variables[key.strip()] = value.strip()\n    \n    # Default variables\n    if \"PROJECT_NAME\" not in variables:\n        variables[\"PROJECT_NAME\"] = repo_name\n    if \"DESCRIPTION\" not in variables:\n        variables[\"DESCRIPTION\"] = \"Project created with PyGitUp template\"\n    if \"AUTHOR\" not in variables:\n        variables[\"AUTHOR\"] = get_github_username(config)\n    \n    return template_name, repo_name, variables, DEFAULT_TEMPLATES[template_name]\n"
        },
        {
          "id": "3831ab37da60",
          "name": "create_project_from_template",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
          "startLine": 116,
          "endLine": 166,
          "lineCount": 51,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "create_project_from_template",
            "get_template_input",
            "create_repo",
            "get",
            "items",
            "replace",
            "update_file",
            "encode"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 11,
          "isExported": false,
          "isAsync": false,
          "docstring": "Create a new project from a template.",
          "body": "\ndef create_project_from_template(github_username, github_token, config, args=None):\n    \"\"\"Create a new project from a template.\"\"\"\n    if args and args.dry_run:\n        print(\"*** Dry Run Mode: No changes will be made. ***\")\n        template_name, repo_name, variables, template = get_template_input(config, args)\n        print(f\"Would create project '{repo_name}' from template '{template_name}'.\")\n        return\n\n    template_name, repo_name, variables, template = get_template_input(config, args)\n    \n    if not template_name:\n        return\n    \n    print(f\"Creating project '{repo_name}' from template '{template_name}'...\")\n    \n    # Create repository first\n    response = create_repo(\n        github_username, repo_name, github_token,\n        description=variables.get(\"DESCRIPTION\", \"\"),\n        private=args.private if args and hasattr(args, 'private') else False\n    )\n    \n    if response.status_code not in [201, 200]:\n        print(f\"Error creating repository: {response.status_code} - {response.text}\")\n        return\n    \n    print(f\"Repository '{repo_name}' created successfully.\")\n    \n    # Create files from template\n    success_count = 0\n    for file_name, file_content in template[\"files\"].items():\n        # Replace variables in file content\n        for var_name, var_value in variables.items():\n            file_content = file_content.replace(f\"{{{{{var_name}}}}}\", var_value)\n        \n        # Upload file\n        file_response = update_file(\n            github_username, repo_name, file_name,\n            file_content.encode('utf-8'), github_token,\n            f\"Initial commit: {file_name}\"\n        )\n        \n        if file_response.status_code in [201, 200]:\n            print(f\"Created file: {file_name}\")\n            success_count += 1\n        else:\n            print(f\"Error creating file {file_name}: {file_response.status_code}\")\n    \n    print(f\"Template project created with {success_count} files.\")\n    print(f\"View your repository at: https://github.com/{github_username}/{repo_name}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "..github.api",
          "specifiers": [
            "create_repo",
            "update_file"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
          "line": 1
        },
        {
          "source": "..core.config",
          "specifiers": [
            "get_github_username"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
          "line": 2
        }
      ],
      "exports": [],
      "complexity": 9,
      "lines": 166
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/__init__.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/__init__.py",
      "language": "python",
      "functions": [],
      "classes": [],
      "imports": [],
      "exports": [],
      "complexity": 1,
      "lines": 1
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
      "language": "python",
      "functions": [
        {
          "id": "75c3cb0106cd",
          "name": "get_git_diff",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
          "startLine": 6,
          "endLine": 17,
          "lineCount": 12,
          "parameters": [],
          "calls": [
            "get_git_diff",
            "run",
            "strip"
          ],
          "calledBy": [
            "d51b6e299e0d"
          ],
          "complexity": 4,
          "isExported": false,
          "isAsync": false,
          "docstring": "Extract the staged git diff.",
          "body": "\ndef get_git_diff():\n    \"\"\"Extract the staged git diff.\"\"\"\n    try:\n        # Check if there are staged changes\n        result = subprocess.run([\"git\", \"diff\", \"--cached\"], capture_output=True, text=True, check=True)\n        if not result.stdout.strip():\n            return None\n        return result.stdout\n    except subprocess.CalledProcessError:\n        return None\n"
        },
        {
          "id": "dcae852f2920",
          "name": "generate_ai_commit_message",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
          "startLine": 17,
          "endLine": 64,
          "lineCount": 48,
          "parameters": [
            "api_key",
            "diff_text"
          ],
          "calls": [
            "generate_ai_commit_message",
            "print_error",
            "wizard",
            "standard",
            "line",
            "post",
            "json",
            "strip",
            "startswith",
            "join",
            "splitlines"
          ],
          "calledBy": [
            "d51b6e299e0d"
          ],
          "complexity": 11,
          "isExported": false,
          "isAsync": false,
          "docstring": "Uses Gemini API to generate a professional commit message from a diff.",
          "body": "\ndef generate_ai_commit_message(api_key, diff_text):\n    \"\"\"Uses Gemini API to generate a professional commit message from a diff.\"\"\"\n    if not api_key:\n        print_error(\"Gemini API Key missing. Please run the configuration wizard (Option 14).\")\n        return None\n\n    url = f\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={api_key}\"\n    \n    prompt = f\"\"\"\n    You are an expert software engineer and git specialist. \n    Analyze the following git diff and generate a professional commit message. \n    \n    CRITICAL RULES:\n    1. Follow the Conventional Commits standard (feat:, fix:, refactor:, chore:, docs:, style:, test:).\n    2. Start with a high-level summary line (max 50 chars).\n    3. Add a blank line, then a bulleted list of specific, meaningful changes.\n    4. Focus on the WHY and the IMPACT, not just the technical details.\n    5. Do not include any other text, only the commit message itself. \n    \n    DIFF DATA:\n    {diff_text[:10000]} # Truncate to 10k chars for safety\n    \"\"\"\n\n    payload = {\n        \"contents\": [{\"parts\": [{\"text\": prompt}]}]\n    }\n\n    try:\n        response = requests.post(url, json=payload, timeout=30)\n        if response.status_code == 200:\n            data = response.json()\n            try:\n                msg = data['candidates'][0]['content']['parts'][0]['text'].strip()\n                # Clean up markdown if the AI includes it\n                if msg.startswith(\"```\"):\n                    msg = \"\\n\".join(msg.splitlines()[1:-1])\n                return msg\n            except (KeyError, IndexError):\n                print_error(\"Could not parse AI response.\")\n                return None\n        else:\n            print_error(f\"Gemini API Error: {response.status_code} - {response.text}\")\n            return None\n    except Exception as e:\n        print_error(f\"Connection failed: {e}\")\n        return None\n"
        },
        {
          "id": "7c55c44cf67b",
          "name": "generate_ai_release_notes",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
          "startLine": 64,
          "endLine": 104,
          "lineCount": 41,
          "parameters": [
            "api_key",
            "repo_name",
            "commit_history"
          ],
          "calls": [
            "generate_ai_release_notes",
            "print_error",
            "join",
            "splitlines",
            "categories",
            "post",
            "json",
            "strip"
          ],
          "calledBy": [
            "51e6ef2a0fbb"
          ],
          "complexity": 8,
          "isExported": false,
          "isAsync": false,
          "docstring": "Uses Gemini to summarize recent history into a professional release announcement.",
          "body": "\ndef generate_ai_release_notes(api_key, repo_name, commit_history):\n    \"\"\"Uses Gemini to summarize recent history into a professional release announcement.\"\"\"\n    if not api_key:\n        print_error(\"Gemini API Key missing.\")\n        return None\n\n    url = f\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={api_key}\"\n    \n    # Format history for the AI\n    history_text = \"\\n\".join([f\"- {c['commit']['message'].splitlines()[0]}\" for c in commit_history[:30]])\n    \n    prompt = f\"\"\"\n    You are a professional Product Manager. \n    Write a high-quality Release Announcement for the repository '{repo_name}' based on these recent commits:\n    \n    {history_text}\n    \n    RULES:\n    1. Start with a catchy 'What's New' or 'Highlights' section.\n    2. Group technical changes into logical categories (UI, Core, Security, etc.).\n    3. Use a professional yet exciting tone.\n    4. Keep it in clean Markdown format.\n    5. Do not include meta-text, only the release notes.\n    \"\"\"\n\n    payload = {\n        \"contents\": [{\n            \"parts\": [{\"text\": prompt}]\n        }]\n    }\n\n    try:\n        response = requests.post(url, json=payload, timeout=30)\n        if response.status_code == 200:\n            data = response.json()\n            return data['candidates'][0]['content']['parts'][0]['text'].strip()\n        return None\n    except Exception:\n        return None\n"
        },
        {
          "id": "d51b6e299e0d",
          "name": "ai_commit_workflow",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
          "startLine": 104,
          "endLine": 146,
          "lineCount": 43,
          "parameters": [
            "github_username",
            "github_token",
            "config"
          ],
          "calls": [
            "ai_commit_workflow",
            "get",
            "get_git_diff",
            "print_warning",
            "print_info",
            "generate_ai_commit_message",
            "Panel",
            "input",
            "action",
            "run",
            "print_success",
            "print_error"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 7,
          "isExported": false,
          "isAsync": false,
          "docstring": "Orchestrates the AI commit process.",
          "body": "\ndef ai_commit_workflow(github_username, github_token, config):\n    \"\"\"Orchestrates the AI commit process.\"\"\"\n    api_key = config[\"github\"].get(\"ai_api_key\")\n    \n    diff = get_git_diff()\n    if not diff:\n        print_warning(\"No staged changes found. Use 'git add' to stage files before AI commit.\")\n        return False\n\n    print_info(\"ü§ñ AI is analyzing your changes...\")\n    \n    message = generate_ai_commit_message(api_key, diff)\n    if not message:\n        return False\n\n    console.print(Panel(message, title=\"[bold cyan]Generated Commit Message[/bold cyan]\", border_style=\"cyan\"))\n    \n    print(\"\\n[bold]Options:[/bold]\")\n    print(\"1: [green]Accept & Commit[/green]\")\n    print(\"2: [yellow]Edit manually[/yellow]\")\n    print(\"3: [red]Cancel[/red]\")\n    \n    choice = input(\"\\nüëâ Choose an action (1-3): \")\n    \n    if choice == '1':\n        try:\n            subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n            print_success(\"Changes committed successfully!\")\n            return True\n        except Exception as e:\n            print_error(f\"Commit failed: {e}\")\n            return False\n    elif choice == '2':\n        # Simple manual edit fallback\n        manual_msg = input(\"Enter new commit message: \")\n        if manual_msg:\n            subprocess.run([\"git\", \"commit\", \"-m\", manual_msg], check=True)\n            print_success(\"Changes committed successfully!\")\n            return True\n    \n    print_info(\"Commit cancelled.\")\n    return False"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "subprocess",
          "specifiers": [
            "subprocess"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
          "line": 2
        },
        {
          "source": "requests",
          "specifiers": [
            "requests"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
          "line": 3
        },
        {
          "source": "json",
          "specifiers": [
            "json"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
          "line": 4
        },
        {
          "source": ".ui",
          "specifiers": [
            "print_info",
            "print_error",
            "print_warning",
            "print_success",
            "console",
            "Panel"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
          "line": 5
        }
      ],
      "exports": [],
      "complexity": 8,
      "lines": 147
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
      "language": "python",
      "functions": [
        {
          "id": "26c995cec5f3",
          "name": "calculate_resolution_time",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
          "startLine": 8,
          "endLine": 23,
          "lineCount": 16,
          "parameters": [
            "issues"
          ],
          "calls": [
            "calculate_resolution_time",
            "get",
            "fromisoformat",
            "replace",
            "total_seconds",
            "round"
          ],
          "calledBy": [
            "be40efbe3e80"
          ],
          "complexity": 6,
          "isExported": false,
          "isAsync": false,
          "docstring": "Calculates average time to close an issue in hours.",
          "body": "\ndef calculate_resolution_time(issues):\n    \"\"\"Calculates average time to close an issue in hours.\"\"\"\n    closed_issues = [i for i in issues if i['state'] == 'closed' and i.get('closed_at')]\n    if not closed_issues:\n        return 0\n    \n    total_hours = 0\n    for issue in closed_issues:\n        created = datetime.fromisoformat(issue['created_at'].replace('Z', '+00:00'))\n        closed = datetime.fromisoformat(issue['closed_at'].replace('Z', '+00:00'))\n        duration = closed - created\n        total_hours += duration.total_seconds() / 3600\n        \n    return round(total_hours / len(closed_issues), 1)\n"
        },
        {
          "id": "e84e77973a97",
          "name": "predict_growth",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
          "startLine": 23,
          "endLine": 36,
          "lineCount": 14,
          "parameters": [
            "current_count",
            "created_at_str"
          ],
          "calls": [
            "predict_growth",
            "fromisoformat",
            "replace",
            "now"
          ],
          "calledBy": [
            "be40efbe3e80"
          ],
          "complexity": 4,
          "isExported": false,
          "isAsync": false,
          "docstring": "Simple linear projection for repository growth.",
          "body": "\ndef predict_growth(current_count, created_at_str):\n    \"\"\"Simple linear projection for repository growth.\"\"\"\n    try:\n        created_at = datetime.fromisoformat(created_at_str.replace('Z', '+00:00'))\n        days_old = (datetime.now(created_at.tzinfo) - created_at).days\n        if days_old <= 0: return current_count\n        \n        growth_rate = current_count / days_old\n        prediction_90_days = int(current_count + (growth_rate * 90))\n        return prediction_90_days\n    except Exception:\n        return current_count\n"
        },
        {
          "id": "f696ef68591b",
          "name": "export_report",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
          "startLine": 36,
          "endLine": 53,
          "lineCount": 18,
          "parameters": [
            "repo_name",
            "data",
            "format"
          ],
          "calls": [
            "export_report",
            "now",
            "strftime",
            "open",
            "dump",
            "writer",
            "writerow",
            "items",
            "print_success",
            "print_error"
          ],
          "calledBy": [
            "be40efbe3e80"
          ],
          "complexity": 5,
          "isExported": false,
          "isAsync": false,
          "docstring": "Exports analytics data to a file.",
          "body": "\ndef export_report(repo_name, data, format='json'):\n    \"\"\"Exports analytics data to a file.\"\"\"\n    filename = f\"{repo_name}_analytics_{datetime.now().strftime('%Y%m%d')}.{format}\"\n    try:\n        if format == 'json':\n            with open(filename, 'w') as f:\n                json.dump(data, f, indent=4)\n        elif format == 'csv':\n            with open(filename, 'w', newline='') as f:\n                writer = csv.writer(f)\n                writer.writerow([\"Metric\", \"Value\"])\n                for k, v in data.items():\n                    writer.writerow([k, v])\n        print_success(f\"Report exported to {filename}\")\n    except Exception as e:\n        print_error(f\"Export failed: {e}\")\n"
        },
        {
          "id": "be40efbe3e80",
          "name": "generate_analytics",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
          "startLine": 53,
          "endLine": 121,
          "lineCount": 69,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "generate_analytics",
            "print_header",
            "input",
            "print_info",
            "now",
            "isoformat",
            "github_request",
            "print_error",
            "json",
            "get",
            "predict_growth",
            "get_contributors",
            "Table",
            "add_column",
            "add_row",
            "get_issues",
            "calculate_resolution_time",
            "Projection",
            "lower",
            "export_report"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 10,
          "isExported": false,
          "isAsync": false,
          "docstring": "Advanced Repository Intelligence & Predictive Analytics.",
          "body": "\ndef generate_analytics(github_username, github_token, config, args=None):\n    \"\"\"Advanced Repository Intelligence & Predictive Analytics.\"\"\"\n    print_header(\"Advanced Analytics & Reporting\")\n    \n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n\n    print_info(f\"Analyzing {repo_name}...\")\n    report_data = {\"repo_name\": repo_name, \"timestamp\": datetime.now().isoformat()}\n\n    try:\n        # 1. Fetch Core Data\n        repo_resp = github_request(\"GET\", f\"https://api.github.com/repos/{github_username}/{repo_name}\", github_token)\n        if repo_resp.status_code != 200:\n            print_error(f\"Failed to fetch repo data: {repo_resp.status_code}\")\n            return\n        \n        repo_data = repo_resp.json()\n        stars = repo_data.get('stargazers_count', 0)\n        \n        # 2. Predictive Growth\n        predicted_stars = predict_growth(stars, repo_data['created_at'])\n        report_data[\"current_stars\"] = stars\n        report_data[\"predicted_stars_90d\"] = predicted_stars\n\n        # 3. Contributor Metrics\n        contrib_resp = get_contributors(github_username, repo_name, github_token)\n        if contrib_resp.status_code == 200:\n            contributors = contrib_resp.json()\n            report_data[\"contributor_count\"] = len(contributors)\n            \n            # Weighted Impact Table\n            table = Table(title=\"Contributor Performance Metrics\", box=box.DOUBLE_EDGE)\n            table.add_column(\"User\", style=\"cyan\")\n            table.add_column(\"Impact Score\", justify=\"right\", style=\"green\")\n            \n            for c in contributors[:5]:\n                # Impact = Contributions * 1.5 (Advanced weighting logic)\n                impact_score = int(c['contributions'] * 1.5)\n                table.add_row(c['login'], str(impact_score))\n            console.print(table)\n\n        # 4. Issue Resolution Analytics\n        issue_resp = get_issues(github_username, repo_name, github_token, state='all')\n        if issue_resp.status_code == 200:\n            issues = issue_resp.json()\n            avg_res_hours = calculate_resolution_time(issues)\n            report_data[\"avg_resolution_hours\"] = avg_res_hours\n            \n            res_table = Table(title=\"Predictive Maintenance\", box=box.SIMPLE)\n            res_table.add_row(\"Avg Resolution Time\", f\"{avg_res_hours} Hours\")\n            res_table.add_row(\"Growth Projection (90d)\", f\"{predicted_stars} Stars\")\n            console.print(res_table)\n\n        # 5. Dashboard Summary\n        print_info(f\"\\n[bold]Summary for {repo_name}:[/bold]\")\n        print(f\"üåü Stars: {stars} -> Predicted: {predicted_stars}\")\n        print(f\"‚è±Ô∏è  Avg Fix Time: {avg_res_hours} hrs\")\n\n        # 6. Export Prompt\n        export = input(\"\\nüíæ Export report? (json/csv/n): \").lower()\n        if export in ['json', 'csv']:\n            export_report(repo_name, report_data, export)\n\n    except Exception as e:\n        print_error(f\"Analytics engine failure: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "json",
          "specifiers": [
            "json"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
          "line": 2
        },
        {
          "source": "csv",
          "specifiers": [
            "csv"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
          "line": 3
        },
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
          "line": 4
        },
        {
          "source": "datetime",
          "specifiers": [
            "datetime",
            "timedelta"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
          "line": 5
        },
        {
          "source": "..github.api",
          "specifiers": [
            "get_contributors",
            "get_issues",
            "github_request"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
          "line": 6
        },
        {
          "source": ".ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header",
            "Table",
            "box",
            "console"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
          "line": 7
        }
      ],
      "exports": [],
      "complexity": 6,
      "lines": 122
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/banner.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/banner.py",
      "language": "python",
      "functions": [
        {
          "id": "ce0d190b4a4f",
          "name": "show_banner",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/banner.py",
          "startLine": 274,
          "endLine": 293,
          "lineCount": 20,
          "parameters": [],
          "calls": [
            "show_banner",
            "system",
            "choice",
            "write",
            "flush",
            "sleep"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 6,
          "isExported": false,
          "isAsync": false,
          "docstring": "Displays a random animated banner from the collection.",
          "body": "\ndef show_banner():\n    \"\"\"Displays a random animated banner from the collection.\"\"\"\n    # Clear screen based on OS\n    os.system('cls' if os.name == 'nt' else 'clear')\n    \n    # Pick a random banner\n    banner = random.choice(BANNERS)\n    \n    # Print the ASCII art directly\n    print(banner)\n    \n    # Typewriter effect for the subtitle\n    subtitle = f\"{WHITE}>>> Effortless GitHub Workflow Automation <<<{RESET}\\n\"\n    for char in subtitle:\n        sys.stdout.write(char)\n        sys.stdout.flush()\n        time.sleep(0.01) # Slightly faster for variety\n    \n    print(\"-\" * 50)"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "sys",
          "specifiers": [
            "sys"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/banner.py",
          "line": 1
        },
        {
          "source": "time",
          "specifiers": [
            "time"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/banner.py",
          "line": 2
        },
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/banner.py",
          "line": 3
        },
        {
          "source": "random",
          "specifiers": [
            "random"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/banner.py",
          "line": 4
        }
      ],
      "exports": [],
      "complexity": 6,
      "lines": 293
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
      "language": "python",
      "functions": [
        {
          "id": "46b90a5decb7",
          "name": "queue_offline_commit",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
          "startLine": 9,
          "endLine": 71,
          "lineCount": 63,
          "parameters": [
            "config",
            "args"
          ],
          "calls": [
            "queue_offline_commit",
            "print_info",
            "print_header",
            "input",
            "check_is_sensitive",
            "print_warning",
            "lower",
            "now",
            "isoformat",
            "exists",
            "open",
            "load",
            "append",
            "dump",
            "print_success",
            "print_error"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 18,
          "isExported": false,
          "isAsync": false,
          "docstring": "Queue a commit for when online with styled output.",
          "body": "\ndef queue_offline_commit(config, args=None):\n    \"\"\"Queue a commit for when online with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would queue a commit for the next online session.\")\n        return\n\n    print_header(\"Offline Commit Queue\")\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    if args and args.message:\n        commit_message = args.message\n    else:\n        commit_message = input(\"Enter commit message: \")\n    \n    if args and args.file:\n        file_path = args.file\n    else:\n        file_path = input(\"Enter file to commit: \")\n    \n    # Security check\n    if check_is_sensitive(file_path):\n        print_warning(f\"'{file_path}' appears to be a sensitive file.\")\n        confirm = input(\"Are you sure you want to queue this file for upload? (y/n): \").lower()\n        if confirm != 'y':\n            print_info(\"Queuing cancelled.\")\n            return\n    \n    # Create queue entry\n    queue_entry = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"repo\": repo_name,\n        \"message\": commit_message,\n        \"file\": file_path,\n        \"status\": \"queued\"\n    }\n    \n    # Load existing queue\n    queue_file = config[\"scheduling\"][\"offline_queue_file\"]\n    queue = []\n    if os.path.exists(queue_file):\n        try:\n            with open(queue_file, 'r') as f:\n                queue = json.load(f)\n        except Exception as e:\n            print_warning(f\"Could not load queue file: {e}\")\n    \n    # Add new entry\n    queue.append(queue_entry)\n    \n    # Save queue\n    try:\n        with open(queue_file, 'w') as f:\n            json.dump(queue, f, indent=2)\n        print_success(\"Commit queued for next online session.\")\n        print_info(f\"Queue file: {queue_file}\")\n    except Exception as e:\n        print_error(f\"Error saving queue: {e}\")\n"
        },
        {
          "id": "d4cc0e31330b",
          "name": "process_offline_queue",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
          "startLine": 71,
          "endLine": 145,
          "lineCount": 75,
          "parameters": [
            "github_username",
            "github_token",
            "config",
            "args"
          ],
          "calls": [
            "process_offline_queue",
            "print_info",
            "exists",
            "open",
            "load",
            "print_error",
            "print_header",
            "read",
            "update_file",
            "now",
            "isoformat",
            "print_success",
            "dump"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 21,
          "isExported": false,
          "isAsync": false,
          "docstring": "Process queued commits when online with styled output.",
          "body": "\ndef process_offline_queue(github_username, github_token, config, args=None):\n    \"\"\"Process queued commits when online with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would process the offline commit queue.\")\n        return\n\n    queue_file = config[\"scheduling\"][\"offline_queue_file\"]\n    \n    if not os.path.exists(queue_file):\n        # Silently return if no queue file exists, unless manually triggered\n        if args and args.mode == \"process-queue\":\n            print_info(\"No offline queue found.\")\n        return\n    \n    try:\n        with open(queue_file, 'r') as f:\n            queue = json.load(f)\n    except Exception as e:\n        print_error(f\"Error loading queue: {e}\")\n        return\n    \n    if not queue:\n        if args and args.mode == \"process-queue\":\n            print_info(\"Offline queue is empty.\")\n        return\n    \n    # Filter for queued entries\n    queued_entries = [e for e in queue if e[\"status\"] == \"queued\"]\n    if not queued_entries:\n        return\n\n    print_header(\"Processing Offline Queue\")\n    print_info(f\"Processing {len(queued_entries)} queued commits...\")\n    \n    processed = 0\n    for entry in queue:\n        if entry[\"status\"] == \"queued\":\n            try:\n                # Read file content\n                if not os.path.exists(entry[\"file\"]):\n                    print_error(f\"File not found: {entry['file']}. Skipping.\")\n                    entry[\"status\"] = \"failed\"\n                    entry[\"error\"] = \"File not found\"\n                    continue\n\n                with open(entry[\"file\"], \"rb\") as f:\n                    file_content = f.read()\n                \n                # Upload file\n                response = update_file(\n                    github_username, entry[\"repo\"], entry[\"file\"],\n                    file_content, github_token, entry[\"message\"]\n                )\n                \n                if response.status_code in [200, 201]:\n                    entry[\"status\"] = \"completed\"\n                    entry[\"processed_at\"] = datetime.now().isoformat()\n                    print_success(f\"Processed: {entry['message']}\")\n                    processed += 1\n                else:\n                    print_error(f\"Failed: {entry['message']} - {response.status_code}\")\n                    entry[\"error\"] = response.text\n            except Exception as e:\n                print_error(f\"Error processing: {entry['message']} - {e}\")\n                entry[\"error\"] = str(e)\n    \n    # Save updated queue\n    try:\n        with open(queue_file, 'w') as f:\n            json.dump(queue, f, indent=2)\n        print_success(f\"Processed {processed} commits from queue.\")\n    except Exception as e:\n        print_error(f\"Error saving updated queue: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
          "line": 2
        },
        {
          "source": "json",
          "specifiers": [
            "json"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
          "line": 3
        },
        {
          "source": "datetime",
          "specifiers": [
            "datetime"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
          "line": 4
        },
        {
          "source": "..github.api",
          "specifiers": [
            "update_file"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
          "line": 6
        },
        {
          "source": ".security",
          "specifiers": [
            "check_is_sensitive"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
          "line": 7
        },
        {
          "source": ".ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_info",
            "print_header",
            "print_warning"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
          "line": 8
        }
      ],
      "exports": [],
      "complexity": 20,
      "lines": 146
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/scraper.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/scraper.py",
      "language": "python",
      "functions": [
        {
          "id": "c165c3a5a54d",
          "name": "scrape_repo_info",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/scraper.py",
          "startLine": 5,
          "endLine": 112,
          "lineCount": 108,
          "parameters": [
            "url"
          ],
          "calls": [
            "scrape_repo_info",
            "print_warning",
            "get",
            "BeautifulSoup",
            "strip",
            "split",
            "find",
            "get_text",
            "found",
            "endswith",
            "Unknown",
            "By",
            "find_all",
            "append"
          ],
          "calledBy": [
            "f5e6adf207a0"
          ],
          "complexity": 41,
          "isExported": false,
          "isAsync": false,
          "docstring": "Scrapes public repository information from its GitHub HTML page.\n    Returns a dictionary structure similar to the API response.",
          "body": "\ndef scrape_repo_info(url):\n    \"\"\"\n    Scrapes public repository information from its GitHub HTML page.\n    Returns a dictionary structure similar to the API response.\n    \"\"\"\n    print_warning(f\"API failed. Attempting to scrape data from {url}...\")\n    \n    try:\n        response = requests.get(url)\n        if response.status_code != 200:\n            return None\n            \n        soup = BeautifulSoup(response.text, 'html.parser')\n        data = {}\n        \n        # Extract Owner and Name\n        path_parts = url.strip(\"/\").split(\"/\")\n        if len(path_parts) >= 2:\n            data['owner'] = {'login': path_parts[-2]}\n            data['name'] = path_parts[-1]\n            data['full_name'] = f\"{path_parts[-2]}/{path_parts[-1]}\"\n            \n        # Extract Description\n        # GitHub usually puts description in 'p.f4' inside the border grid or layout\n        desc_tag = soup.find('p', class_='f4 my-3')\n        data['description'] = desc_tag.get_text(strip=True) if desc_tag else \"No description found (scraped)\"\n        \n        # Extract Stars\n        # Looking for the star count in the sidebar or header\n        # Current GitHub layout often uses a span with id 'repo-stars-counter-star' \n        # or an 'a' tag with specific href\n        star_tag = soup.find(id='repo-stars-counter-star')\n        if star_tag:\n             data['stargazers_count'] = star_tag.get('title') or star_tag.get_text(strip=True)\n        else:\n             # Fallback: finding the 'a' tag with 'stargazers' in href\n             star_link = soup.find('a', href=lambda x: x and x.endswith('/stargazers'))\n             if star_link:\n                 # The count is usually in a span inside or just the text\n                 count_span = star_link.find('span', class_='Counter')\n                 data['stargazers_count'] = count_span.get('title') if count_span else star_link.get_text(strip=True)\n             else:\n                 data['stargazers_count'] = \"N/A\"\n\n        # Extract Forks\n        fork_tag = soup.find(id='repo-network-counter')\n        if fork_tag:\n            data['forks_count'] = fork_tag.get('title') or fork_tag.get_text(strip=True)\n        else:\n             fork_link = soup.find('a', href=lambda x: x and x.endswith('/forks'))\n             if fork_link:\n                 count_span = fork_link.find('span', class_='Counter')\n                 data['forks_count'] = count_span.get('title') if count_span else fork_link.get_text(strip=True)\n             else:\n                 data['forks_count'] = \"N/A\"\n                 \n        # Extract Issues\n        issues_tab = soup.find(id='issues-tab')\n        if issues_tab:\n            count_span = issues_tab.find('span', class_='Counter')\n            data['open_issues_count'] = count_span.get('title') if count_span else \"N/A\"\n        else:\n            data['open_issues_count'] = \"N/A\"\n            \n        # Extract Language\n        # Found in the 'Languages' section of the sidebar\n        lang_header = soup.find('h2', string='Languages')\n        if lang_header:\n            # The list is usually in a ul following the header, but specific class structures vary.\n            # A common reliable pattern is finding the list of languages progress bar or the stats list.\n            # Trying to find the first language span in the sidebar stats.\n            lang_item = soup.find('span', class_='color-fg-default text-bold mr-1')\n            data['language'] = lang_item.get_text(strip=True) if lang_item else \"Unknown\"\n        else:\n             data['language'] = \"Unknown\"\n             \n        # Metadata\n        data['private'] = False # If we can scrape it publicly, it's public\n        data['clone_url'] = f\"{url}.git\"\n        data['created_at'] = \"Unknown (Scraped)\" # Hard to scrape reliably without parsing timestamps\n        \n        # OSINT: Used By (Dependents)\n        used_by_tag = soup.find('a', href=lambda x: x and '/network/dependents' in x)\n        if used_by_tag:\n            count_span = used_by_tag.find('span', class_='Counter')\n            data['used_by'] = count_span.get('title') if count_span else used_by_tag.get_text(strip=True)\n        \n        # OSINT: Sponsorship Status\n        sponsor_btn = soup.find('a', href=lambda x: x and '/sponsors/' in x)\n        data['is_sponsored'] = True if sponsor_btn else False\n\n        # OSINT: Topics/Tags\n        topics = []\n        topic_tags = soup.find_all('a', class_='topic-tag')\n        for t in topic_tags:\n            topics.append(t.get_text(strip=True))\n        data['topics'] = topics\n\n        # OSINT: Social Preview Image\n        og_image = soup.find('meta', property='og:image')\n        data['social_preview'] = og_image.get('content') if og_image else None\n        \n        return data\n        \n    except Exception as e:\n        print_warning(f\"Scraping failed: {e}\")\n        return None"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "requests",
          "specifiers": [
            "requests"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/scraper.py",
          "line": 2
        },
        {
          "source": "bs4",
          "specifiers": [
            "BeautifulSoup"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/scraper.py",
          "line": 3
        },
        {
          "source": ".ui",
          "specifiers": [
            "print_warning"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/scraper.py",
          "line": 4
        }
      ],
      "exports": [],
      "complexity": 41,
      "lines": 113
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
      "language": "python",
      "functions": [
        {
          "id": "c935af5c11fe",
          "name": "calculate_entropy",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
          "startLine": 23,
          "endLine": 34,
          "lineCount": 12,
          "parameters": [
            "data"
          ],
          "calls": [
            "calculate_entropy",
            "count",
            "chr",
            "log"
          ],
          "calledBy": [
            "a4e88c00c9d1"
          ],
          "complexity": 4,
          "isExported": false,
          "isAsync": false,
          "docstring": "Calculates the Shannon entropy of a string.",
          "body": "\ndef calculate_entropy(data):\n    \"\"\"Calculates the Shannon entropy of a string.\"\"\"\n    if not data:\n        return 0\n    entropy = 0\n    for x in range(256):\n        p_x = float(data.count(chr(x))) / len(data)\n        if p_x > 0:\n            entropy += - p_x * math.log(p_x, 2)\n    return entropy\n"
        },
        {
          "id": "2fbf4b070b23",
          "name": "run_audit",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
          "startLine": 34,
          "endLine": 54,
          "lineCount": 21,
          "parameters": [
            "github_username",
            "repo_name",
            "github_token"
          ],
          "calls": [
            "run_audit",
            "print_header",
            "print_info",
            "run",
            "print_success",
            "print_warning",
            "run_advanced_security_scan"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 7,
          "isExported": false,
          "isAsync": false,
          "docstring": "Run a security audit on the project dependencies.",
          "body": "\ndef run_audit(github_username=None, repo_name=None, github_token=None):\n    \"\"\"Run a security audit on the project dependencies.\"\"\"\n    print_header(\"Security Audit\")\n    \n    # Local pip-audit\n    print_info(\"Running local pip-audit on current environment...\")\n    try:\n        result = subprocess.run([\"pip-audit\"], capture_output=True, text=True)\n        if result.returncode == 0:\n            print_success(\"No known local vulnerabilities found via pip-audit.\")\n        else:\n            print_warning(\"Local vulnerabilities detected:\")\n            print(result.stdout)\n    except FileNotFoundError:\n        print_warning(\"'pip-audit' not found. Skipping local scan.\")\n\n    # Remote GitHub Security scan if context provided\n    if github_username and repo_name and github_token:\n        run_advanced_security_scan(github_username, repo_name, github_token)\n"
        },
        {
          "id": "8957cebef9b3",
          "name": "run_advanced_security_scan",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
          "startLine": 54,
          "endLine": 88,
          "lineCount": 35,
          "parameters": [
            "username",
            "repo_name",
            "token"
          ],
          "calls": [
            "run_advanced_security_scan",
            "print_info",
            "get_dependabot_alerts",
            "json",
            "print_error",
            "print_success",
            "get_secret_scanning_alerts",
            "print_warning"
          ],
          "calledBy": [
            "2fbf4b070b23"
          ],
          "complexity": 16,
          "isExported": false,
          "isAsync": false,
          "docstring": "Deep vulnerability scanning using GitHub's security APIs.",
          "body": "\ndef run_advanced_security_scan(username, repo_name, token):\n    \"\"\"Deep vulnerability scanning using GitHub's security APIs.\"\"\"\n    print_info(f\"Fetching GitHub Security Alerts for {repo_name}...\")\n    \n    try:\n        # Dependabot\n        dep_resp = get_dependabot_alerts(username, repo_name, token)\n        if dep_resp.status_code == 200:\n            alerts = dep_resp.json()\n            open_alerts = [a for a in alerts if a['state'] == 'open']\n            if open_alerts:\n                print_error(f\"Found {len(open_alerts)} OPEN Dependabot vulnerabilities!\")\n                for a in open_alerts[:3]:\n                    print(f\" - {a['security_advisory']['summary']} ({a['security_advisory']['severity']})\")\n            else:\n                print_success(\"No open Dependabot alerts found.\")\n        \n        # Secret Scanning\n        sec_resp = get_secret_scanning_alerts(username, repo_name, token)\n        if sec_resp.status_code == 200:\n            secrets = sec_resp.json()\n            open_secrets = [s for s in secrets if s['state'] == 'open']\n            if open_secrets:\n                print_error(f\"ALERT: {len(open_secrets)} LEAKED SECRETS detected in repo history!\")\n                for s in open_secrets:\n                    print(f\" - Type: {s['secret_type']} at {s['html_url']}\")\n            else:\n                print_success(\"No leaked secrets detected.\")\n        elif sec_resp.status_code == 404:\n            print_info(\"Secret scanning is not enabled or not supported for this repo.\")\n\n    except Exception as e:\n        print_warning(f\"Advanced security scan failed: {e}\")\n"
        },
        {
          "id": "a4e88c00c9d1",
          "name": "check_is_sensitive",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
          "startLine": 88,
          "endLine": 118,
          "lineCount": 31,
          "parameters": [
            "file_path"
          ],
          "calls": [
            "check_is_sensitive",
            "basename",
            "exists",
            "open",
            "strip",
            "startswith",
            "fnmatch",
            "Analysis",
            "isfile",
            "getsize",
            "read",
            "splitlines",
            "split",
            "calculate_entropy"
          ],
          "calledBy": [
            "8037213f9b0d",
            "b9152e2e05f3",
            "44098917418d",
            "46b90a5decb7",
            "5ac2e130bdf5",
            "e490fdc33eb5"
          ],
          "complexity": 17,
          "isExported": false,
          "isAsync": false,
          "docstring": "Checks if a file path matches any sensitive patterns or has high entropy contents.",
          "body": "\ndef check_is_sensitive(file_path):\n    \"\"\"Checks if a file path matches any sensitive patterns or has high entropy contents.\"\"\"\n    name = os.path.basename(file_path)\n    \n    # 1. Filename Pattern Check\n    gitignore_patterns = []\n    if os.path.exists(\".gitignore\"):\n        with open(\".gitignore\", \"r\") as f:\n            gitignore_patterns = [line.strip() for line in f if line.strip() and not line.startswith(\"#\")]\n\n    all_patterns = SENSITIVE_PATTERNS + gitignore_patterns\n    for pattern in all_patterns:\n        if fnmatch.fnmatch(name, pattern) or fnmatch.fnmatch(file_path, pattern):\n            return True\n\n    # 2. Sophisticated Content Analysis (High Entropy Detection)\n    if os.path.isfile(file_path) and os.path.getsize(file_path) < 1024 * 500:\n        try:\n            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                content = f.read()\n                for line in content.splitlines():\n                    words = line.split()\n                    for word in words:\n                        if len(word) > 20 and calculate_entropy(word) > 4.5:\n                            return True\n        except Exception:\n            pass\n\n    return False\n"
        },
        {
          "id": "5ac2e130bdf5",
          "name": "audit_files_and_prompt",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
          "startLine": 118,
          "endLine": 136,
          "lineCount": 19,
          "parameters": [
            "files"
          ],
          "calls": [
            "audit_files_and_prompt",
            "check_is_sensitive",
            "print_warning",
            "input"
          ],
          "calledBy": [
            "8aecc87cfbd7"
          ],
          "complexity": 12,
          "isExported": false,
          "isAsync": false,
          "docstring": "Scans a list of files for sensitive content.",
          "body": "\ndef audit_files_and_prompt(files):\n    \"\"\"Scans a list of files for sensitive content.\"\"\"\n    sensitive_matches = [f for f in files if check_is_sensitive(f)]\n    if not sensitive_matches:\n        return files\n\n    print_warning(f\"SECURITY WARNING: {len(sensitive_matches)} sensitive or heavy files detected!\")\n    for f in sensitive_matches[:5]:\n        print(f\" - {f}\")\n    \n    choice = input(\"\\nHow to proceed? (1: Skip them [Default], 2: Upload anyway, 3: Cancel): \") or \"1\"\n    \n    if choice == \"1\":\n        return [f for f in files if f not in sensitive_matches]\n    elif choice == \"2\":\n        return files\n    return []\n"
        },
        {
          "id": "e490fdc33eb5",
          "name": "scan_directory_for_sensitive_files",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
          "startLine": 136,
          "endLine": 158,
          "lineCount": 23,
          "parameters": [
            "directory"
          ],
          "calls": [
            "scan_directory_for_sensitive_files",
            "walk",
            "join",
            "check_is_sensitive",
            "append",
            "print_warning",
            "input",
            "open",
            "write",
            "relpath"
          ],
          "calledBy": [
            "44f568d20b70"
          ],
          "complexity": 8,
          "isExported": false,
          "isAsync": false,
          "docstring": "Scans a directory for sensitive files before git add.",
          "body": "\ndef scan_directory_for_sensitive_files(directory):\n    \"\"\"Scans a directory for sensitive files before git add.\"\"\"\n    detected = []\n    for root, dirs, files in os.walk(directory):\n        for name in dirs + files:\n            full_path = os.path.join(root, name)\n            if check_is_sensitive(full_path):\n                detected.append(full_path)\n\n    if not detected:\n        return True\n\n    print_warning(f\"Sensitive files found: {len(detected)}\")\n    choice = input(\"\\nAction? (1: Add to .gitignore, 2: Ignore warning, 3: Cancel): \")\n    \n    if choice == \"1\":\n        with open(\".gitignore\", \"a\") as f:\n            f.write(\"\\n# Added by PyGitUp Interceptor\\n\")\n            for item in detected:\n                f.write(f\"{os.path.relpath(item, directory)}\\n\")\n        return True\n    return choice == \"2\""
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "subprocess",
          "specifiers": [
            "subprocess"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
          "line": 1
        },
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
          "line": 2
        },
        {
          "source": "fnmatch",
          "specifiers": [
            "fnmatch"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
          "line": 3
        },
        {
          "source": "math",
          "specifiers": [
            "math"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
          "line": 4
        },
        {
          "source": "..github.api",
          "specifiers": [
            "get_dependabot_alerts",
            "get_secret_scanning_alerts"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
          "line": 5
        },
        {
          "source": "..utils.ui",
          "specifiers": [
            "print_success",
            "print_error",
            "print_warning",
            "print_info",
            "print_header"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
          "line": 6
        }
      ],
      "exports": [],
      "complexity": 11,
      "lines": 158
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
      "language": "python",
      "functions": [
        {
          "id": "2c296aa52879",
          "name": "print_success",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "startLine": 11,
          "endLine": 15,
          "lineCount": 5,
          "parameters": [
            "message"
          ],
          "calls": [
            "print_success"
          ],
          "calledBy": [
            "cad67e0dcece",
            "c5fcd19ff943",
            "78e970b9d9ad",
            "f1f948b57bf3",
            "c655144f401e",
            "ebb909c21ccf",
            "cae9e9daf651",
            "8037213f9b0d",
            "72913908c45b",
            "dd4bb98c5440",
            "ea6606b7620d",
            "e638d8d1a537",
            "9863eda17987",
            "9ec31c3178f8",
            "1d0f56ea40c1",
            "65c5d1c696bf",
            "df849b43f31d",
            "4ac56e6829e2",
            "402517011038",
            "b9152e2e05f3",
            "8aecc87cfbd7",
            "44098917418d",
            "6b700cc8d9be",
            "1f4213d37548",
            "d51b6e299e0d",
            "f696ef68591b",
            "46b90a5decb7",
            "d4cc0e31330b",
            "2fbf4b070b23",
            "8957cebef9b3",
            "ad7661271cb1"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Prints a success message in green.",
          "body": "\ndef print_success(message):\n    \"\"\"Prints a success message in green.\"\"\"\n    console.print(f\"[bold green]‚úî {message}[/bold green]\")\n"
        },
        {
          "id": "bc37dc58134c",
          "name": "print_error",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "startLine": 15,
          "endLine": 19,
          "lineCount": 5,
          "parameters": [
            "message"
          ],
          "calls": [
            "print_error"
          ],
          "calledBy": [
            "cad67e0dcece",
            "c5fcd19ff943",
            "78e970b9d9ad",
            "f1f948b57bf3",
            "c655144f401e",
            "ebb909c21ccf",
            "cae9e9daf651",
            "8037213f9b0d",
            "72913908c45b",
            "dd4bb98c5440",
            "51e6ef2a0fbb",
            "ea6606b7620d",
            "e638d8d1a537",
            "9863eda17987",
            "9ec31c3178f8",
            "f5e6adf207a0",
            "1d0f56ea40c1",
            "09b2167e8bce",
            "65c5d1c696bf",
            "df849b43f31d",
            "4ac56e6829e2",
            "402517011038",
            "44f568d20b70",
            "8cdb7133190e",
            "b9152e2e05f3",
            "b065ed988f67",
            "8aecc87cfbd7",
            "44098917418d",
            "6b700cc8d9be",
            "1f4213d37548",
            "dcae852f2920",
            "7c55c44cf67b",
            "d51b6e299e0d",
            "f696ef68591b",
            "be40efbe3e80",
            "46b90a5decb7",
            "d4cc0e31330b",
            "8957cebef9b3",
            "ad7661271cb1"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Prints an error message in red.",
          "body": "\ndef print_error(message):\n    \"\"\"Prints an error message in red.\"\"\"\n    console.print(f\"[bold red]‚úñ {message}[/bold red]\")\n"
        },
        {
          "id": "58f8d186c498",
          "name": "print_warning",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "startLine": 19,
          "endLine": 23,
          "lineCount": 5,
          "parameters": [
            "message"
          ],
          "calls": [
            "print_warning"
          ],
          "calledBy": [
            "f1f948b57bf3",
            "8037213f9b0d",
            "ea6606b7620d",
            "9863eda17987",
            "9ec31c3178f8",
            "f5e6adf207a0",
            "893f9c1b4076",
            "65c5d1c696bf",
            "44f568d20b70",
            "b9152e2e05f3",
            "8aecc87cfbd7",
            "44098917418d",
            "d51b6e299e0d",
            "46b90a5decb7",
            "c165c3a5a54d",
            "2fbf4b070b23",
            "8957cebef9b3",
            "5ac2e130bdf5",
            "e490fdc33eb5",
            "dad53122bce0"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Prints a warning message in yellow.",
          "body": "\ndef print_warning(message):\n    \"\"\"Prints a warning message in yellow.\"\"\"\n    console.print(f\"[bold yellow]‚ö† {message}[/bold yellow]\")\n"
        },
        {
          "id": "f3de7251ed0a",
          "name": "print_info",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "startLine": 23,
          "endLine": 27,
          "lineCount": 5,
          "parameters": [
            "message"
          ],
          "calls": [
            "print_info"
          ],
          "calledBy": [
            "cad67e0dcece",
            "c5fcd19ff943",
            "78e970b9d9ad",
            "f1f948b57bf3",
            "c655144f401e",
            "ebb909c21ccf",
            "cae9e9daf651",
            "8037213f9b0d",
            "dd4bb98c5440",
            "51e6ef2a0fbb",
            "ea6606b7620d",
            "e638d8d1a537",
            "9863eda17987",
            "9ec31c3178f8",
            "1d0f56ea40c1",
            "09b2167e8bce",
            "65c5d1c696bf",
            "df849b43f31d",
            "4ac56e6829e2",
            "402517011038",
            "44f568d20b70",
            "8cdb7133190e",
            "b9152e2e05f3",
            "8aecc87cfbd7",
            "44098917418d",
            "6b700cc8d9be",
            "1f4213d37548",
            "d51b6e299e0d",
            "be40efbe3e80",
            "46b90a5decb7",
            "d4cc0e31330b",
            "2fbf4b070b23",
            "8957cebef9b3",
            "ad7661271cb1"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Prints an info message in blue.",
          "body": "\ndef print_info(message):\n    \"\"\"Prints an info message in blue.\"\"\"\n    console.print(f\"[bold blue]‚Ñπ {message}[/bold blue]\")\n"
        },
        {
          "id": "2c4e51c8e43d",
          "name": "print_header",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "startLine": 27,
          "endLine": 31,
          "lineCount": 5,
          "parameters": [
            "text"
          ],
          "calls": [
            "print_header",
            "Panel",
            "Text"
          ],
          "calledBy": [
            "cad67e0dcece",
            "c5fcd19ff943",
            "78e970b9d9ad",
            "c655144f401e",
            "ebb909c21ccf",
            "cae9e9daf651",
            "8037213f9b0d",
            "72913908c45b",
            "ea6606b7620d",
            "e638d8d1a537",
            "9863eda17987",
            "9ec31c3178f8",
            "1d0f56ea40c1",
            "09b2167e8bce",
            "44f568d20b70",
            "8cdb7133190e",
            "b9152e2e05f3",
            "b065ed988f67",
            "44098917418d",
            "6b700cc8d9be",
            "1f4213d37548",
            "be40efbe3e80",
            "46b90a5decb7",
            "d4cc0e31330b",
            "2fbf4b070b23"
          ],
          "complexity": 1,
          "isExported": false,
          "isAsync": false,
          "docstring": "Prints a styled header.",
          "body": "\ndef print_header(text):\n    \"\"\"Prints a styled header.\"\"\"\n    console.print(Panel(Text(text, justify=\"center\", style=\"bold white\"), border_style=\"blue\", expand=False))\n"
        },
        {
          "id": "0f6795e1f0c6",
          "name": "show_spinner",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "startLine": 33,
          "endLine": 42,
          "lineCount": 10,
          "parameters": [
            "text"
          ],
          "calls": [
            "show_spinner",
            "Progress",
            "SpinnerColumn",
            "TextColumn",
            "add_task"
          ],
          "calledBy": [],
          "complexity": 2,
          "isExported": true,
          "isAsync": false,
          "docstring": "Context manager for a loading spinner.",
          "body": "def show_spinner(text=\"Processing...\"):\n    \"\"\"Context manager for a loading spinner.\"\"\"\n    with Progress(\n        SpinnerColumn(),\n        TextColumn(\"[progress.description]{task.description}\"),\n        transient=True,\n    ) as progress:\n        progress.add_task(description=text, total=None)\n        yield\n"
        },
        {
          "id": "5ca874d53204",
          "name": "display_menu",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "startLine": 42,
          "endLine": 70,
          "lineCount": 29,
          "parameters": [
            "options"
          ],
          "calls": [
            "display_menu",
            "Table",
            "add_column",
            "items",
            "category",
            "add_row"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 4,
          "isExported": false,
          "isAsync": false,
          "docstring": "Displays the main menu options in a grid.",
          "body": "\ndef display_menu(options):\n    \"\"\"Displays the main menu options in a grid.\"\"\"\n    table = Table(title=\"[bold blue]PyGitUp Main Menu[/bold blue]\", box=box.ROUNDED, show_header=True, header_style=\"bold cyan\")\n    table.add_column(\"ID\", justify=\"center\", style=\"green\", no_wrap=True)\n    table.add_column(\"Feature\", style=\"white\")\n    table.add_column(\"Category\", style=\"dim\")\n\n    categories = {\n        \"Core\": [\"project\", \"file\", \"batch\", \"template\", \"migrate\"],\n        \"Git\": [\"branch\", \"stash\", \"tag\", \"cherry-pick\", \"smart-push\"],\n        \"GitHub\": [\"release\", \"multi-repo\", \"request-review\", \"gist\", \"webhook\", \"actions\", \"pr\", \"visibility\", \"delete-repo\", \"repo-info\", \"bulk-mgmt\", \"fork-intel\"],\n        \"Tools\": [\"scan-todos\", \"offline-queue\", \"process-queue\", \"generate-docs\", \"analytics\", \"audit\", \"configure\", \"ai-commit\", \"accounts\"]\n    }\n\n    for key, value in options.items():\n        # Determine category (naive approach, could be passed in)\n        cat = \"Misc\"\n        mode_guess = value[1] # Assuming value is tuple (desc, mode)\n        \n        for c_name, c_items in categories.items():\n            if mode_guess in c_items:\n                cat = c_name\n                break\n        \n        table.add_row(key, value[0], cat)\n\n    console.print(table)\n"
        },
        {
          "id": "6e59d2e3fee0",
          "name": "display_repo_info",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "startLine": 70,
          "endLine": 188,
          "lineCount": 119,
          "parameters": [
            "data"
          ],
          "calls": [
            "display_repo_info",
            "grid",
            "add_column",
            "get",
            "join",
            "items",
            "add_row",
            "sum",
            "values",
            "strip",
            "Velocity",
            "Analytics",
            "Clones",
            "Views",
            "Table",
            "Panel"
          ],
          "calledBy": [
            "f5e6adf207a0"
          ],
          "complexity": 44,
          "isExported": false,
          "isAsync": false,
          "docstring": "Displays repository info in a rich panel with traffic analytics.",
          "body": "\ndef display_repo_info(data):\n    \"\"\"Displays repository info in a rich panel with traffic analytics.\"\"\"\n    grid = Table.grid(expand=True)\n    grid.add_column(justify=\"left\", style=\"cyan\", no_wrap=True)\n    grid.add_column(justify=\"left\", style=\"white\")\n\n    fields = {\n        \"Name\": data.get(\"name\"),\n        \"Owner\": data.get(\"owner\", {}).get(\"login\"),\n        \"Visibility\": \"Private\" if data.get(\"private\") else \"Public\",\n        \"Language\": data.get(\"language\"),\n        \"Stars\": str(data.get(\"stargazers_count\")),\n        \"Forks\": str(data.get(\"forks_count\")),\n        \"Issues\": f\"{data.get('open_issues_count')} open\",\n        \"Created\": data.get(\"created_at\"),\n        \"Clone URL\": data.get(\"clone_url\"),\n        \"Used By\": data.get(\"used_by\", \"0\"),\n        \"Sponsors\": \"üíñ Active\" if data.get(\"is_sponsored\") else \"None\"\n    }\n\n    if data.get(\"topics\"):\n        fields[\"Topics\"] = \", \".join(data.get(\"topics\"))\n\n    for label, value in fields.items():\n        grid.add_row(f\"{label}:\", str(value))\n\n    # OSINT: Languages Section\n    if 'osint_languages' in data and data['osint_languages']:\n        langs = data['osint_languages']\n        total_bytes = sum(langs.values())\n        lang_str = \"\"\n        for name, bytes_count in sorted(langs.items(), key=lambda x: x[1], reverse=True)[:5]:\n            percentage = (bytes_count / total_bytes) * 100\n            lang_str += f\"{name} ({percentage:.1f}%) \"\n        grid.add_row(\"Languages:\", lang_str.strip())\n\n    # OSINT: Community Profile\n    if 'osint_community' in data and data['osint_community']:\n        comm = data['osint_community']\n        grid.add_row(\"\", \"\")\n        grid.add_row(\"[bold]Community Intelligence[/bold]\", f\"Health Score: [bold green]{comm.get('health_percentage')}%[/bold green]\")\n        \n        files = comm.get('files', {})\n        readme = \"‚úÖ\" if files.get('readme') else \"‚ùå\"\n        license = \"‚úÖ\" if files.get('license') else \"‚ùå\"\n        coc = \"‚úÖ\" if files.get('code_of_conduct') else \"‚ùå\"\n        grid.add_row(\"Documentation:\", f\"README: {readme} | LICENSE: {license} | CoC: {coc}\")\n\n    # OSINT: Release Summary\n    if 'osint_release' in data and data['osint_release']:\n        rel = data['osint_release']\n        grid.add_row(\"\", \"\")\n        grid.add_row(\"[bold]Latest Intelligence[/bold]\", \"\")\n        grid.add_row(\"Version:\", f\"{rel.get('tag_name')} ({rel.get('name')})\")\n        grid.add_row(\"Released:\", rel.get('published_at', '')[:10])\n\n    # Health & Activity Section\n    if 'health' in data and data['health']:\n        health = data['health']\n        grid.add_row(\"\", \"\")\n        grid.add_row(\"[bold]Health & Activity[/bold]\", \"\")\n        \n        if 'development_velocity_days' in health:\n            grid.add_row(\"Dev Velocity (Median):\", f\"{health['development_velocity_days']} days/commit\")\n        \n        if 'activity_status' in health:\n            status_color = \"green\" if health['activity_status'] == \"Active/Bursting\" else \"white\"\n            grid.add_row(\"Activity Status:\", f\"[{status_color}]{health['activity_status']}[/{status_color}]\")\n            \n        if 'closed_issues' in health:\n            grid.add_row(\"Closed Issues:\", str(health['closed_issues']))\n            \n        if 'contributors_count' in health:\n            grid.add_row(\"Total Contributors:\", str(health['contributors_count']))\n\n    # Traffic analytics section if available\n    if 'traffic' in data and data['traffic']:\n        traffic = data['traffic']\n        grid.add_row(\"\", \"\") # Spacer\n        grid.add_row(\"[bold]Traffic Analytics (Admin Only)[/bold]\", \"\")\n\n        if 'clones' in traffic and traffic['clones'].get('clones'):\n            # Safely get the last element or use defaults\n            clones_list = traffic['clones']['clones']\n            if clones_list:\n                latest_clones = clones_list[-1]\n                grid.add_row(\"Clones (Last recorded):\", f\"{latest_clones['count']} ({latest_clones['uniques']} unique)\")\n\n        if 'views' in traffic and traffic['views'].get('views'):\n            views_list = traffic['views']['views']\n            if views_list:\n                latest_views = views_list[-1]\n                grid.add_row(\"Views (Last recorded):\", f\"{latest_views['count']} ({latest_views['uniques']} unique)\")\n\n        if 'referrers' in traffic and traffic['referrers']:\n            referrer_table = Table(title=\"Top Referrers\", box=box.SIMPLE)\n            referrer_table.add_column(\"Referrer\", style=\"cyan\")\n            referrer_table.add_column(\"Visits\", style=\"green\")\n            referrer_table.add_column(\"Unique\", style=\"yellow\")\n\n            for referrer in traffic['referrers'][:5]:\n                referrer_table.add_row(\n                    referrer['referrer'],\n                    str(referrer['count']),\n                    str(referrer['uniques'])\n                )\n            \n            grid.add_row(\"\", \"\")\n            grid.add_row(\"Traffic Sources:\", referrer_table)\n\n    panel = Panel(\n        grid,\n        title=f\"[bold]{data.get('full_name')}[/bold]\",\n        border_style=\"green\" if not data.get(\"private\") else \"red\",\n        subtitle=data.get(\"description\") or \"No description\"\n    )\n    console.print(panel)\n"
        },
        {
          "id": "520e12ce0f39",
          "name": "display_traffic_trends",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "startLine": 188,
          "endLine": 225,
          "lineCount": 38,
          "parameters": [
            "traffic_data"
          ],
          "calls": [
            "display_traffic_trends",
            "get",
            "Table",
            "Trends",
            "add_column",
            "add_row",
            "append",
            "Group"
          ],
          "calledBy": [
            "f5e6adf207a0"
          ],
          "complexity": 9,
          "isExported": false,
          "isAsync": false,
          "docstring": "Display traffic trends in a tabular format.",
          "body": "\ndef display_traffic_trends(traffic_data):\n    \"\"\"Display traffic trends in a tabular format.\"\"\"\n    if not traffic_data:\n        return\n\n    groups = []\n\n    if 'clones' in traffic_data and traffic_data['clones'].get('clones'):\n        clones_table = Table(title=\"Clone Trends (Last 14 Days)\", box=box.MINIMAL)\n        clones_table.add_column(\"Date\", style=\"cyan\")\n        clones_table.add_column(\"Clones\", style=\"green\")\n        clones_table.add_column(\"Unique\", style=\"yellow\")\n\n        for clone_data in traffic_data['clones']['clones']:\n            clones_table.add_row(\n                clone_data['timestamp'][:10],\n                str(clone_data['count']),\n                str(clone_data['uniques'])\n            )\n        groups.append(clones_table)\n\n    if 'views' in traffic_data and traffic_data['views'].get('views'):\n        views_table = Table(title=\"View Trends (Last 14 Days)\", box=box.MINIMAL)\n        views_table.add_column(\"Date\", style=\"cyan\")\n        views_table.add_column(\"Views\", style=\"green\")\n        views_table.add_column(\"Unique\", style=\"yellow\")\n\n        for view_data in traffic_data['views']['views']:\n            views_table.add_row(\n                view_data['timestamp'][:10],\n                str(view_data['count']),\n                str(view_data['uniques'])\n            )\n        groups.append(views_table)\n\n    if groups:\n        console.print(Group(*groups))"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "rich.console",
          "specifiers": [
            "Console",
            "Group"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "line": 2
        },
        {
          "source": "rich.panel",
          "specifiers": [
            "Panel"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "line": 3
        },
        {
          "source": "rich.table",
          "specifiers": [
            "Table"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "line": 4
        },
        {
          "source": "rich.text",
          "specifiers": [
            "Text"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "line": 5
        },
        {
          "source": "rich.progress",
          "specifiers": [
            "Progress",
            "SpinnerColumn",
            "TextColumn"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "line": 6
        },
        {
          "source": "rich",
          "specifiers": [
            "box"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "line": 7
        },
        {
          "source": "contextlib",
          "specifiers": [
            "contextmanager"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
          "line": 8
        }
      ],
      "exports": [
        "show_spinner"
      ],
      "complexity": 7,
      "lines": 226
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
      "language": "python",
      "functions": [
        {
          "id": "3a3c89f865e0",
          "name": "is_newer",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
          "startLine": 10,
          "endLine": 23,
          "lineCount": 14,
          "parameters": [
            "latest",
            "current"
          ],
          "calls": [
            "is_newer",
            "split",
            "parts"
          ],
          "calledBy": [
            "dad53122bce0"
          ],
          "complexity": 7,
          "isExported": false,
          "isAsync": false,
          "docstring": "Simple semantic version comparison.",
          "body": "\ndef is_newer(latest, current):\n    \"\"\"Simple semantic version comparison.\"\"\"\n    try:\n        l_parts = [int(x) for x in latest.split(\".\")]\n        c_parts = [int(x) for x in current.split(\".\")]\n        # Compare parts (1.5.0 > 1.4.0)\n        for l, c in zip(l_parts, c_parts):\n            if l > c: return True\n            if l < c: return False\n        return len(l_parts) > len(c_parts)\n    except Exception:\n        return False\n"
        },
        {
          "id": "dad53122bce0",
          "name": "check_for_updates",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
          "startLine": 23,
          "endLine": 45,
          "lineCount": 23,
          "parameters": [],
          "calls": [
            "check_for_updates",
            "get",
            "splitlines",
            "split",
            "strip",
            "is_newer",
            "print_warning",
            "input",
            "lower",
            "perform_update"
          ],
          "calledBy": [
            "cad67e0dcece"
          ],
          "complexity": 9,
          "isExported": false,
          "isAsync": false,
          "docstring": "Checks GitHub for a newer version of PyGitUp by reading the raw source.",
          "body": "\ndef check_for_updates():\n    \"\"\"Checks GitHub for a newer version of PyGitUp by reading the raw source.\"\"\"\n    try:\n        # We check the raw __init__.py because it's the most \"real-time\" source\n        response = requests.get(GITHUB_RAW_VERSION_URL, timeout=3)\n        if response.status_code == 200:\n            content = response.text\n            latest_version = \"0.0.0\"\n            for line in content.splitlines():\n                if \"__version__\" in line:\n                    latest_version = line.split(\"=\")[1].strip().strip('\"').strip(\"'\")\n                    break\n            \n            if is_newer(latest_version, __version__):\n                print_warning(f\"üöÄ A new update is available: v{latest_version} (Current: v{__version__})\")\n                confirm = input(\"Would you like to auto-update now? (y/n): \").lower()\n                if confirm == 'y':\n                    perform_update()\n    except Exception:\n        # Fail silently to not disturb the user's workflow if offline\n        pass\n"
        },
        {
          "id": "ad7661271cb1",
          "name": "perform_update",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
          "startLine": 45,
          "endLine": 77,
          "lineCount": 33,
          "parameters": [],
          "calls": [
            "perform_update",
            "print_info",
            "PyGitUp",
            "abspath",
            "dirname",
            "getcwd",
            "exists",
            "join",
            "chdir",
            "run",
            "print_success",
            "exit",
            "print_error"
          ],
          "calledBy": [
            "dad53122bce0"
          ],
          "complexity": 5,
          "isExported": false,
          "isAsync": false,
          "docstring": "Executes a safe update by finding the package source and pulling.",
          "body": "\ndef perform_update():\n    \"\"\"Executes a safe update by finding the package source and pulling.\"\"\"\n    print_info(\"Initiating self-update sequence...\")\n    \n    # 1. Find the root of the PyGitUp installation\n    # pygitup/utils/update.py -> pygitup/utils -> pygitup -> PyGitUp (root)\n    try:\n        current_file_path = os.path.abspath(__file__)\n        package_root = os.path.dirname(os.path.dirname(os.path.dirname(current_file_path)))\n        \n        original_cwd = os.getcwd()\n        \n        if os.path.exists(os.path.join(package_root, \".git\")):\n            print_info(f\"Updating source at: {package_root}\")\n            os.chdir(package_root)\n            \n            # 2. Perform the pull\n            result = subprocess.run([\"git\", \"pull\", \"origin\", \"main\"], capture_output=True, text=True)\n            \n            if result.returncode == 0:\n                print_success(\"PyGitUp updated to the latest version!\")\n                print_info(\"Please restart the tool to apply changes.\")\n                os.chdir(original_cwd)\n                sys.exit(0)\n            else:\n                print_error(f\"Git Pull Failed: {result.stderr}\")\n        else:\n            print_error(\"This installation is not managed by Git. Please update manually via 'pip install --upgrade .'\")\n            \n        os.chdir(original_cwd)\n    except Exception as e:\n        print_error(f\"Update sequence failed: {e}\")"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "requests",
          "specifiers": [
            "requests"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
          "line": 1
        },
        {
          "source": "subprocess",
          "specifiers": [
            "subprocess"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
          "line": 2
        },
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
          "line": 3
        },
        {
          "source": "sys",
          "specifiers": [
            "sys"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
          "line": 4
        },
        {
          "source": "..",
          "specifiers": [
            "__version__"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
          "line": 5
        },
        {
          "source": ".ui",
          "specifiers": [
            "print_info",
            "print_success",
            "print_error",
            "print_warning"
          ],
          "isDefault": false,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
          "line": 6
        }
      ],
      "exports": [],
      "complexity": 7,
      "lines": 77
    },
    {
      "path": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
      "relativePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
      "language": "python",
      "functions": [
        {
          "id": "02fd6a9cefdc",
          "name": "validate_repo_name",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
          "startLine": 4,
          "endLine": 20,
          "lineCount": 17,
          "parameters": [
            "name"
          ],
          "calls": [
            "validate_repo_name",
            "match",
            "long"
          ],
          "calledBy": [
            "44f568d20b70",
            "b9152e2e05f3"
          ],
          "complexity": 6,
          "isExported": false,
          "isAsync": false,
          "docstring": "Validates a GitHub repository name.\n    Rules: Only alphanumeric characters, hyphens, and underscores.",
          "body": "\ndef validate_repo_name(name):\n    \"\"\"\n    Validates a GitHub repository name.\n    Rules: Only alphanumeric characters, hyphens, and underscores.\n    \"\"\"\n    if not name:\n        return False, \"Repository name cannot be empty.\"\n    \n    if not re.match(r'^[a-zA-Z0-9\\-_.]+$', name):\n        return False, \"Invalid repository name. Use only letters, numbers, hyphens, dots, and underscores.\"\n    \n    if len(name) > 100:\n        return False, \"Repository name is too long (max 100 characters).\"\n        \n    return True, \"\"\n"
        },
        {
          "id": "923970dfa901",
          "name": "validate_file_path",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
          "startLine": 20,
          "endLine": 32,
          "lineCount": 13,
          "parameters": [
            "path",
            "must_exist"
          ],
          "calls": [
            "validate_file_path",
            "exists"
          ],
          "calledBy": [
            "44f568d20b70",
            "b9152e2e05f3"
          ],
          "complexity": 5,
          "isExported": false,
          "isAsync": false,
          "docstring": "Validates a local file path.",
          "body": "\ndef validate_file_path(path, must_exist=True):\n    \"\"\"\n    Validates a local file path.\n    \"\"\"\n    if not path:\n        return False, \"File path cannot be empty.\"\n    \n    if must_exist and not os.path.exists(path):\n        return False, f\"File or directory does not exist: {path}\"\n        \n    return True, \"\"\n"
        },
        {
          "id": "723f41af521e",
          "name": "sanitize_input",
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
          "startLine": 32,
          "endLine": 40,
          "lineCount": 9,
          "parameters": [
            "text"
          ],
          "calls": [
            "sanitize_input",
            "strip"
          ],
          "calledBy": [],
          "complexity": 3,
          "isExported": false,
          "isAsync": false,
          "docstring": "Basic sanitization for string inputs.\n    Removes leading/trailing whitespace.",
          "body": "\ndef sanitize_input(text):\n    \"\"\"\n    Basic sanitization for string inputs.\n    Removes leading/trailing whitespace.\n    \"\"\"\n    if text is None:\n        return \"\"\n    return str(text).strip()"
        }
      ],
      "classes": [],
      "imports": [
        {
          "source": "re",
          "specifiers": [
            "re"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
          "line": 2
        },
        {
          "source": "os",
          "specifiers": [
            "os"
          ],
          "isDefault": true,
          "isNamespace": false,
          "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
          "line": 3
        }
      ],
      "exports": [],
      "complexity": 5,
      "lines": 41
    }
  ],
  "callGraph": [
    {
      "from": "mod:/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
      "to": "mod:/data/data/com.termux/files/home/PyGitUp/pygitup.py",
      "type": "import",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:ce0d190b4a4f",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:dad53122bce0",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:8ecc4f2a4045",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:76fd775187dc",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:4c3d0e0cf92c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:a647d0933dd8",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:4c6a9058fc9b",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:d4cc0e31330b",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:5ca874d53204",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:44f568d20b70",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:b9152e2e05f3",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:8aecc87cfbd7",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:3831ab37da60",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:ea6606b7620d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:44098917418d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:65c5d1c696bf",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:46b90a5decb7",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:dd4bb98c5440",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:f1f948b57bf3",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:09b2167e8bce",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:be40efbe3e80",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:c5fcd19ff943",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:c655144f401e",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:ebb909c21ccf",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:78e970b9d9ad",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:8037213f9b0d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:1d0f56ea40c1",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:cae9e9daf651",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:72913908c45b",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:2fbf4b070b23",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:e638d8d1a537",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:f5e6adf207a0",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:9863eda17987",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:1f4213d37548",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:6b700cc8d9be",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:ac5fff938bb6",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:9ec31c3178f8",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:d51b6e299e0d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:470391cb22b0",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:f3bb89e569dd",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:2b972eff3796",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cad67e0dcece",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cdf0160ec029",
      "to": "func:893f9c1b4076",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c50e2b3c1ae7",
      "to": "func:893f9c1b4076",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c2cd9c47dd19",
      "to": "func:893f9c1b4076",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c187ab92c4f2",
      "to": "func:8ecc4f2a4045",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:900ceb8b2016",
      "to": "func:76fd775187dc",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:d58b10bba610",
      "to": "func:76fd775187dc",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:918666a425f8",
      "to": "func:4c6a9058fc9b",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:86b1d0cf1c48",
      "to": "func:4c6a9058fc9b",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:a4a0df0df6d3",
      "to": "func:a647d0933dd8",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f12bbe815d45",
      "to": "func:a647d0933dd8",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cd26c0773f45",
      "to": "func:729bde7aebfc",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ea310d7744bd",
      "to": "func:59cce6cbf9ef",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:56eb7f277de9",
      "to": "func:a05438a21c94",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:2e314dc6c749",
      "to": "func:ed9e81d9ba4e",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c5fcd19ff943",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c5fcd19ff943",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c5fcd19ff943",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c5fcd19ff943",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:78e970b9d9ad",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:78e970b9d9ad",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:78e970b9d9ad",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:78e970b9d9ad",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f1f948b57bf3",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f1f948b57bf3",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f1f948b57bf3",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f1f948b57bf3",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c655144f401e",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c655144f401e",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c655144f401e",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c655144f401e",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ebb909c21ccf",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ebb909c21ccf",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ebb909c21ccf",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ebb909c21ccf",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cae9e9daf651",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cae9e9daf651",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cae9e9daf651",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cae9e9daf651",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cae9e9daf651",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cae9e9daf651",
      "to": "func:bfb968263df8",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:04ec89b8dcdb",
      "to": "func:ae53fa12588e",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:22799e5e935b",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:729bde7aebfc",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:59cce6cbf9ef",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f288fcba775c",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:a05438a21c94",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ed46502e03e4",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9f5b6b9d7027",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:304c2f42440f",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:0be2041124b1",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:2940e06f8c6f",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:e598644894fc",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:1a4cd86312dd",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8af97186e8e2",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f21215245cf7",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:cc1f5fc47297",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:851ca2aa04d6",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:7aba7221be60",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:2cc012b3cc34",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c05b776fcc1c",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:4b3f28ce9e27",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:4350d6620c0f",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:6e8a9abe9285",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:3007556417ad",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:bfb968263df8",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f16e5c44fb5b",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:596d2eb4e17c",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8037213f9b0d",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8037213f9b0d",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8037213f9b0d",
      "to": "func:a4e88c00c9d1",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8037213f9b0d",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8037213f9b0d",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8037213f9b0d",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8037213f9b0d",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:72913908c45b",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:72913908c45b",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:72913908c45b",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:72913908c45b",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:dd4bb98c5440",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:dd4bb98c5440",
      "to": "func:2940e06f8c6f",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:dd4bb98c5440",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:dd4bb98c5440",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:51e6ef2a0fbb",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:51e6ef2a0fbb",
      "to": "func:ed46502e03e4",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:51e6ef2a0fbb",
      "to": "func:7c55c44cf67b",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:51e6ef2a0fbb",
      "to": "func:daedf59a9872",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:51e6ef2a0fbb",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:51e6ef2a0fbb",
      "to": "func:ed9e81d9ba4e",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ed9e81d9ba4e",
      "to": "func:ed46502e03e4",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ea6606b7620d",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ea6606b7620d",
      "to": "func:51e6ef2a0fbb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ea6606b7620d",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ea6606b7620d",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ea6606b7620d",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ea6606b7620d",
      "to": "func:9f5b6b9d7027",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ea6606b7620d",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:e638d8d1a537",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:e638d8d1a537",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:e638d8d1a537",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:e638d8d1a537",
      "to": "func:4350d6620c0f",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:e638d8d1a537",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9863eda17987",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9863eda17987",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9863eda17987",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9863eda17987",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9863eda17987",
      "to": "func:6e8a9abe9285",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9863eda17987",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9ec31c3178f8",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9ec31c3178f8",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9ec31c3178f8",
      "to": "func:8af97186e8e2",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9ec31c3178f8",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9ec31c3178f8",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9ec31c3178f8",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:9ec31c3178f8",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:6dcebe2d9f75",
      "to": "func:ed46502e03e4",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:6dcebe2d9f75",
      "to": "func:1a4cd86312dd",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:6dcebe2d9f75",
      "to": "func:e598644894fc",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f5e6adf207a0",
      "to": "func:ac5fff938bb6",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f5e6adf207a0",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f5e6adf207a0",
      "to": "func:729bde7aebfc",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f5e6adf207a0",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f5e6adf207a0",
      "to": "func:c165c3a5a54d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f5e6adf207a0",
      "to": "func:6e59d2e3fee0",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f5e6adf207a0",
      "to": "func:cc1f5fc47297",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f5e6adf207a0",
      "to": "func:851ca2aa04d6",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f5e6adf207a0",
      "to": "func:7aba7221be60",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f5e6adf207a0",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f5e6adf207a0",
      "to": "func:6dcebe2d9f75",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f5e6adf207a0",
      "to": "func:520e12ce0f39",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:1d0f56ea40c1",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:1d0f56ea40c1",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:1d0f56ea40c1",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:1d0f56ea40c1",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:1d0f56ea40c1",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:893f9c1b4076",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:09b2167e8bce",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:09b2167e8bce",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:09b2167e8bce",
      "to": "func:2cc012b3cc34",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:09b2167e8bce",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:65c5d1c696bf",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:65c5d1c696bf",
      "to": "func:1a4cd86312dd",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:65c5d1c696bf",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:65c5d1c696bf",
      "to": "func:dead2b1f6009",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:65c5d1c696bf",
      "to": "func:03393b735f64",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:65c5d1c696bf",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:65c5d1c696bf",
      "to": "func:c05b776fcc1c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:65c5d1c696bf",
      "to": "func:304c2f42440f",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:65c5d1c696bf",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:df849b43f31d",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:df849b43f31d",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:df849b43f31d",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:4ac56e6829e2",
      "to": "func:729bde7aebfc",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:4ac56e6829e2",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:4ac56e6829e2",
      "to": "func:59cce6cbf9ef",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:4ac56e6829e2",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:4ac56e6829e2",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:402517011038",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:402517011038",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:402517011038",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44f568d20b70",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44f568d20b70",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44f568d20b70",
      "to": "func:1eb3727820d9",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44f568d20b70",
      "to": "func:923970dfa901",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44f568d20b70",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44f568d20b70",
      "to": "func:02fd6a9cefdc",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44f568d20b70",
      "to": "func:e490fdc33eb5",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44f568d20b70",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44f568d20b70",
      "to": "func:df849b43f31d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44f568d20b70",
      "to": "func:4ac56e6829e2",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44f568d20b70",
      "to": "func:402517011038",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8cdb7133190e",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8cdb7133190e",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8cdb7133190e",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b9152e2e05f3",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b9152e2e05f3",
      "to": "func:8cdb7133190e",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b9152e2e05f3",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b9152e2e05f3",
      "to": "func:923970dfa901",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b9152e2e05f3",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b9152e2e05f3",
      "to": "func:02fd6a9cefdc",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b9152e2e05f3",
      "to": "func:a4e88c00c9d1",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b9152e2e05f3",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b9152e2e05f3",
      "to": "func:f288fcba775c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b9152e2e05f3",
      "to": "func:a05438a21c94",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b9152e2e05f3",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b065ed988f67",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:b065ed988f67",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8aecc87cfbd7",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8aecc87cfbd7",
      "to": "func:b065ed988f67",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8aecc87cfbd7",
      "to": "func:5ac2e130bdf5",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8aecc87cfbd7",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8aecc87cfbd7",
      "to": "func:f288fcba775c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8aecc87cfbd7",
      "to": "func:a05438a21c94",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8aecc87cfbd7",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8aecc87cfbd7",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44098917418d",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44098917418d",
      "to": "func:985fa21cb145",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44098917418d",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44098917418d",
      "to": "func:a4e88c00c9d1",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44098917418d",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44098917418d",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44098917418d",
      "to": "func:f288fcba775c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44098917418d",
      "to": "func:a05438a21c94",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:44098917418d",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:6b700cc8d9be",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:6b700cc8d9be",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:6b700cc8d9be",
      "to": "func:4ac56e6829e2",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:6b700cc8d9be",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:6b700cc8d9be",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:1f4213d37548",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:1f4213d37548",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:1f4213d37548",
      "to": "func:4b3f28ce9e27",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:1f4213d37548",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:1f4213d37548",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:09ae5dd659db",
      "to": "func:a647d0933dd8",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:3831ab37da60",
      "to": "func:09ae5dd659db",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:3831ab37da60",
      "to": "func:59cce6cbf9ef",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:3831ab37da60",
      "to": "func:a05438a21c94",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:dcae852f2920",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:7c55c44cf67b",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:d51b6e299e0d",
      "to": "func:75c3cb0106cd",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:d51b6e299e0d",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:d51b6e299e0d",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:d51b6e299e0d",
      "to": "func:dcae852f2920",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:d51b6e299e0d",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:d51b6e299e0d",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f696ef68591b",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:f696ef68591b",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:be40efbe3e80",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:be40efbe3e80",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:be40efbe3e80",
      "to": "func:04ec89b8dcdb",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:be40efbe3e80",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:be40efbe3e80",
      "to": "func:e84e77973a97",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:be40efbe3e80",
      "to": "func:e598644894fc",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:be40efbe3e80",
      "to": "func:1a4cd86312dd",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:be40efbe3e80",
      "to": "func:26c995cec5f3",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:be40efbe3e80",
      "to": "func:f696ef68591b",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:46b90a5decb7",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:46b90a5decb7",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:46b90a5decb7",
      "to": "func:a4e88c00c9d1",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:46b90a5decb7",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:46b90a5decb7",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:46b90a5decb7",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:d4cc0e31330b",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:d4cc0e31330b",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:d4cc0e31330b",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:d4cc0e31330b",
      "to": "func:a05438a21c94",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:d4cc0e31330b",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:c165c3a5a54d",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:2fbf4b070b23",
      "to": "func:2c4e51c8e43d",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:2fbf4b070b23",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:2fbf4b070b23",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:2fbf4b070b23",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:2fbf4b070b23",
      "to": "func:8957cebef9b3",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8957cebef9b3",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8957cebef9b3",
      "to": "func:f16e5c44fb5b",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8957cebef9b3",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8957cebef9b3",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8957cebef9b3",
      "to": "func:596d2eb4e17c",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:8957cebef9b3",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:a4e88c00c9d1",
      "to": "func:c935af5c11fe",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:5ac2e130bdf5",
      "to": "func:a4e88c00c9d1",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:5ac2e130bdf5",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:e490fdc33eb5",
      "to": "func:a4e88c00c9d1",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:e490fdc33eb5",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:dad53122bce0",
      "to": "func:3a3c89f865e0",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:dad53122bce0",
      "to": "func:58f8d186c498",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:dad53122bce0",
      "to": "func:ad7661271cb1",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ad7661271cb1",
      "to": "func:f3de7251ed0a",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ad7661271cb1",
      "to": "func:2c296aa52879",
      "type": "call",
      "weight": 1
    },
    {
      "from": "func:ad7661271cb1",
      "to": "func:bc37dc58134c",
      "type": "call",
      "weight": 1
    }
  ],
  "circularDependencies": [],
  "godFunctions": [
    {
      "function": {
        "id": "cad67e0dcece",
        "name": "main",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
        "startLine": 28,
        "endLine": 240,
        "lineCount": 213,
        "parameters": [],
        "calls": [
          "main",
          "show_banner",
          "check_for_updates",
          "create_parser",
          "parse_args",
          "load_config",
          "get",
          "print_info",
          "configuration_wizard",
          "get_github_username",
          "get_github_token",
          "process_offline_queue",
          "audit",
          "Intelligence",
          "Accounts",
          "display_menu",
          "max",
          "keys",
          "isdigit",
          "input",
          "choice",
          "print_error",
          "upload_project_directory",
          "upload_single_file",
          "upload_batch_files",
          "create_project_from_template",
          "create_release_tag",
          "update_multiple_repos",
          "scan_todos",
          "queue_offline_commit",
          "request_code_review",
          "smart_push",
          "generate_documentation",
          "generate_analytics",
          "manage_branches",
          "manage_stashes",
          "manage_tags",
          "cherry_pick_commit",
          "manage_gists",
          "manage_webhooks",
          "manage_actions",
          "manage_pull_requests",
          "run_audit",
          "manage_repo_visibility",
          "get_detailed_repo_info",
          "delete_repository",
          "manage_bulk_repositories",
          "migrate_repository",
          "parse_github_url",
          "get_fork_intelligence",
          "ai_commit_workflow",
          "print_header",
          "list_profiles",
          "get_active_profile_path",
          "basename",
          "replace",
          "set_active_profile",
          "print_success",
          "exit",
          "system"
        ],
        "calledBy": [],
        "complexity": 71,
        "isExported": false,
        "isAsync": false,
        "docstring": "Main function to orchestrate the process.",
        "body": "\ndef main():\n    \"\"\"Main function to orchestrate the process.\"\"\"\n    try:\n        show_banner()\n        check_for_updates()\n\n        # Parse command line arguments\n        parser = create_parser()\n        args = parser.parse_args()\n        \n        # Load configuration\n        config = load_config(args.config)\n        \n        # Auto-Setup Wizard if credentials missing\n        if not config[\"github\"].get(\"username\") or not config[\"github\"].get(\"token\"):\n            print_info(\"No existing credentials found. Starting stealth setup...\")\n            configuration_wizard()\n            # Reload after setup\n            config = load_config(args.config)\n\n        # Get credentials\n        github_username = get_github_username(config)\n        github_token = get_github_token(config)\n        \n        # Process offline queue if not in queue processing mode\n        if args.mode != \"process-queue\":\n            process_offline_queue(github_username, github_token, config)\n        \n        # Persistent loop for interactive mode\n        is_interactive = not args.mode\n        \n        while True:\n            # Determine mode\n            mode = args.mode\n            if not mode:\n                menu_options = {\n                    '1': (\"Upload/update a whole project directory\", \"project\"),\n                    '2': (\"Upload/update a single file\", \"file\"),\n                    '3': (\"Batch upload multiple files\", \"batch\"),\n                    '4': (\"Create project from template\", \"template\"),\n                    '5': (\"Create GitHub release\", \"release\"),\n                    '6': (\"Update file in multiple repositories\", \"multi-repo\"),\n                    '7': (\"Scan for TODOs and create issues\", \"scan-todos\"),\n                    '8': (\"Queue commit for offline\", \"offline-queue\"),\n                    '9': (\"Process offline commit queue\", \"process-queue\"),\n                    '10': (\"Request code review\", \"request-review\"),\n                    '11': (\"Smart push with commit squashing\", \"smart-push\"),\n                    '12': (\"Generate documentation\", \"generate-docs\"),\n                    '13': (\"Generate collaboration analytics\", \"analytics\"),\n                    '14': (\"Run the configuration wizard\", \"configure\"),\n                    '15': (\"Manage branches\", \"branch\"),\n                    '16': (\"Manage stashes\", \"stash\"),\n                    '17': (\"Manage tags\", \"tag\"),\n                    '18': (\"Cherry-pick a commit\", \"cherry-pick\"),\n                    '19': (\"Manage Gists\", \"gist\"),\n                    '20': (\"Manage Webhooks\", \"webhook\"),\n                    '21': (\"Manage GitHub Actions\", \"actions\"),\n                    '22': (\"Manage Pull Requests\", \"pr\"),\n                    '23': (\"Run security audit (Local + GitHub)\", \"audit\"),\n                    '24': (\"Change repository visibility\", \"visibility\"),\n                    '25': (\"Get repository info from URL\", \"repo-info\"),\n                    '26': (\"Delete GitHub repository\", \"delete-repo\"),\n                    '27': (\"Bulk Repository Management & Health\", \"bulk-mgmt\"),\n                    '28': (\"Migrate/Mirror Repository from any source\", \"migrate\"),\n                    '29': (\"Network & Fork Intelligence (OSINT)\", \"fork-intel\"),\n                    '30': (\"AI-Powered Semantic Commit\", \"ai-commit\"),\n                    '31': (\"Manage Accounts (Switch/Add/List)\", \"accounts\"),\n                    '0': (\"Exit PyGitUp\", \"exit\")\n                }\n\n                display_menu(menu_options)\n                max_choice = max([int(k) for k in menu_options.keys() if k.isdigit()])\n                choice = input(f\"\\nüëâ Enter your choice (0-{max_choice}): \")\n                \n                if choice == '0':\n                    print_info(\"Goodbye! üöÄ\")\n                    break\n\n                selected_option = menu_options.get(choice)\n                if not selected_option:\n                    print_error(\"Invalid choice. Try again.\")\n                    continue\n                mode = selected_option[1]\n\n            # Execute the corresponding function based on the mode\n            if mode == \"project\":\n                upload_project_directory(github_username, github_token, config, args)\n            elif mode == \"file\":\n                upload_single_file(github_username, github_token, config, args)\n            elif mode == \"batch\":\n                upload_batch_files(github_username, github_token, config, args)\n            elif mode == \"template\":\n                create_project_from_template(github_username, github_token, config, args)\n            elif mode == \"release\":\n                create_release_tag(github_username, github_token, config, args)\n            elif mode == \"multi-repo\":\n                update_multiple_repos(github_username, github_token, config, args)\n            elif mode == \"scan-todos\":\n                scan_todos(github_username, github_token, config, args)\n            elif mode == \"offline-queue\":\n                queue_offline_commit(config, args)\n            elif mode == \"process-queue\":\n                process_offline_queue(github_username, github_token, config, args)\n            elif mode == \"request-review\":\n                request_code_review(github_username, github_token, config, args)\n            elif mode == \"smart-push\":\n                smart_push(github_username, github_token, config, args)\n            elif mode == \"generate-docs\":\n                generate_documentation(github_username, github_token, config, args)\n            elif mode == \"analytics\":\n                generate_analytics(github_username, github_token, config, args)\n            elif mode == \"configure\":\n                configuration_wizard()\n                # Reload config after wizard\n                config = load_config(args.config)\n                github_username = get_github_username(config)\n                github_token = get_github_token(config)\n            elif mode == \"branch\":\n                manage_branches(args)\n            elif mode == \"stash\":\n                manage_stashes(args)\n            elif mode == \"tag\":\n                manage_tags(args)\n            elif mode == \"cherry-pick\":\n                cherry_pick_commit(args)\n            elif mode == \"gist\":\n                manage_gists(args, github_username, github_token)\n            elif mode == \"webhook\":\n                manage_webhooks(args, github_username, github_token)\n            elif mode == \"actions\":\n                manage_actions(args, github_username, github_token)\n            elif mode == \"pr\":\n                manage_pull_requests(args, github_username, github_token)\n            elif mode == \"audit\":\n                repo_to_audit = args.repo if args and hasattr(args, 'repo') and args.repo else input(\"Enter repo name for GitHub security scan: \")\n                run_audit(github_username, repo_to_audit, github_token)\n            elif mode == \"visibility\":\n                manage_repo_visibility(args, github_username, github_token)\n            elif mode == \"repo-info\":\n                get_detailed_repo_info(args, github_token)\n            elif mode == \"delete-repo\":\n                delete_repository(args, github_username, github_token)\n            elif mode == \"bulk-mgmt\":\n                manage_bulk_repositories(github_token)\n            elif mode == \"migrate\":\n                migrate_repository(github_username, github_token, config, args)\n            elif mode == \"fork-intel\":\n                url = args.url if args and hasattr(args, 'url') and args.url else input(\"Enter repository URL: \")\n                owner, repo_name = parse_github_url(url)\n                if owner and repo_name:\n                    get_fork_intelligence(owner, repo_name, github_token)\n                else:\n                    print_error(\"Invalid repository URL.\")\n            elif mode == \"ai-commit\":\n                ai_commit_workflow(github_username, github_token, config)\n            elif mode == \"accounts\":\n                print_header(\"Account & Profile Manager\")\n                profiles = list_profiles()\n                active_path = get_active_profile_path()\n                active_name = os.path.basename(active_path).replace(\".yaml\", \"\")\n\n                print_info(f\"Current Active Profile: [bold green]{active_name}[/bold green]\")\n                print(\"\\nAvailable Profiles:\")\n                for p in profiles:\n                    marker = \"‚ûú \" if p == active_name else \"  \"\n                    print(f\"{marker}{p}\")\n                \n                print(\"\\n[bold]Options:[/bold]\")\n                print(\"1: Switch Profile\")\n                print(\"2: Add New Account\")\n                print(\"3: Back\")\n                \n                acc_choice = input(\"\\nüëâ Choice: \")\n                if acc_choice == '1':\n                    target = input(\"Enter profile name to switch to: \")\n                    success, msg = set_active_profile(target)\n                    if success:\n                        print_success(msg)\n                        # Reload everything\n                        config = load_config(args.config)\n                        github_username = get_github_username(config)\n                        github_token = get_github_token(config)\n                    else:\n                        print_error(msg)\n                elif acc_choice == '2':\n                    configuration_wizard()\n                    config = load_config(args.config)\n                    github_username = get_github_username(config)\n                    github_token = get_github_token(config)\n            else:\n                print_error(\"Invalid mode selected.\")\n                if not is_interactive: sys.exit(1)\n\n            print_success(\"Operation complete.\")\n            \n            # If we were in CLI mode, exit loop after one operation\n            if not is_interactive:\n                break\n            \n            input(\"\\n‚å®Ô∏è  Press Enter to return to the menu...\")\n            # Clear screen for next iteration\n            import os\n            os.system('cls' if os.name == 'nt' else 'clear')\n            show_banner()\n    except KeyboardInterrupt:\n        print(\"\\n\")\n        print_info(\"PyGitUp interrupted by user. Exiting...\")\n        sys.exit(0)\n    except Exception as e:\n        print_error(f\"A critical error occurred: {e}\")\n        print_info(\"Please report this bug at: https://github.com/frederickabrah/PyGitup/issues\")\n        sys.exit(1)"
      },
      "reasons": [
        "Function has 213 lines (threshold: 100). Extremely oversized.",
        "Cyclomatic complexity is 71 (threshold: 15). Too many decision paths.",
        "Function makes 60 distinct calls (threshold: 20). May have too many responsibilities.",
        "Generic function name \"main\" often indicates a catch-all function.",
        "High logic density (33.3% complexity per line). Code may be too terse.",
        "Makes 60 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 95,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within main and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split main into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If main has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: main, show_banner, check_for_updates, create_parser, parse_args"
      ]
    },
    {
      "function": {
        "id": "c165c3a5a54d",
        "name": "scrape_repo_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/scraper.py",
        "startLine": 5,
        "endLine": 112,
        "lineCount": 108,
        "parameters": [
          "url"
        ],
        "calls": [
          "scrape_repo_info",
          "print_warning",
          "get",
          "BeautifulSoup",
          "strip",
          "split",
          "find",
          "get_text",
          "found",
          "endswith",
          "Unknown",
          "By",
          "find_all",
          "append"
        ],
        "calledBy": [
          "f5e6adf207a0"
        ],
        "complexity": 41,
        "isExported": false,
        "isAsync": false,
        "docstring": "Scrapes public repository information from its GitHub HTML page.\n    Returns a dictionary structure similar to the API response.",
        "body": "\ndef scrape_repo_info(url):\n    \"\"\"\n    Scrapes public repository information from its GitHub HTML page.\n    Returns a dictionary structure similar to the API response.\n    \"\"\"\n    print_warning(f\"API failed. Attempting to scrape data from {url}...\")\n    \n    try:\n        response = requests.get(url)\n        if response.status_code != 200:\n            return None\n            \n        soup = BeautifulSoup(response.text, 'html.parser')\n        data = {}\n        \n        # Extract Owner and Name\n        path_parts = url.strip(\"/\").split(\"/\")\n        if len(path_parts) >= 2:\n            data['owner'] = {'login': path_parts[-2]}\n            data['name'] = path_parts[-1]\n            data['full_name'] = f\"{path_parts[-2]}/{path_parts[-1]}\"\n            \n        # Extract Description\n        # GitHub usually puts description in 'p.f4' inside the border grid or layout\n        desc_tag = soup.find('p', class_='f4 my-3')\n        data['description'] = desc_tag.get_text(strip=True) if desc_tag else \"No description found (scraped)\"\n        \n        # Extract Stars\n        # Looking for the star count in the sidebar or header\n        # Current GitHub layout often uses a span with id 'repo-stars-counter-star' \n        # or an 'a' tag with specific href\n        star_tag = soup.find(id='repo-stars-counter-star')\n        if star_tag:\n             data['stargazers_count'] = star_tag.get('title') or star_tag.get_text(strip=True)\n        else:\n             # Fallback: finding the 'a' tag with 'stargazers' in href\n             star_link = soup.find('a', href=lambda x: x and x.endswith('/stargazers'))\n             if star_link:\n                 # The count is usually in a span inside or just the text\n                 count_span = star_link.find('span', class_='Counter')\n                 data['stargazers_count'] = count_span.get('title') if count_span else star_link.get_text(strip=True)\n             else:\n                 data['stargazers_count'] = \"N/A\"\n\n        # Extract Forks\n        fork_tag = soup.find(id='repo-network-counter')\n        if fork_tag:\n            data['forks_count'] = fork_tag.get('title') or fork_tag.get_text(strip=True)\n        else:\n             fork_link = soup.find('a', href=lambda x: x and x.endswith('/forks'))\n             if fork_link:\n                 count_span = fork_link.find('span', class_='Counter')\n                 data['forks_count'] = count_span.get('title') if count_span else fork_link.get_text(strip=True)\n             else:\n                 data['forks_count'] = \"N/A\"\n                 \n        # Extract Issues\n        issues_tab = soup.find(id='issues-tab')\n        if issues_tab:\n            count_span = issues_tab.find('span', class_='Counter')\n            data['open_issues_count'] = count_span.get('title') if count_span else \"N/A\"\n        else:\n            data['open_issues_count'] = \"N/A\"\n            \n        # Extract Language\n        # Found in the 'Languages' section of the sidebar\n        lang_header = soup.find('h2', string='Languages')\n        if lang_header:\n            # The list is usually in a ul following the header, but specific class structures vary.\n            # A common reliable pattern is finding the list of languages progress bar or the stats list.\n            # Trying to find the first language span in the sidebar stats.\n            lang_item = soup.find('span', class_='color-fg-default text-bold mr-1')\n            data['language'] = lang_item.get_text(strip=True) if lang_item else \"Unknown\"\n        else:\n             data['language'] = \"Unknown\"\n             \n        # Metadata\n        data['private'] = False # If we can scrape it publicly, it's public\n        data['clone_url'] = f\"{url}.git\"\n        data['created_at'] = \"Unknown (Scraped)\" # Hard to scrape reliably without parsing timestamps\n        \n        # OSINT: Used By (Dependents)\n        used_by_tag = soup.find('a', href=lambda x: x and '/network/dependents' in x)\n        if used_by_tag:\n            count_span = used_by_tag.find('span', class_='Counter')\n            data['used_by'] = count_span.get('title') if count_span else used_by_tag.get_text(strip=True)\n        \n        # OSINT: Sponsorship Status\n        sponsor_btn = soup.find('a', href=lambda x: x and '/sponsors/' in x)\n        data['is_sponsored'] = True if sponsor_btn else False\n\n        # OSINT: Topics/Tags\n        topics = []\n        topic_tags = soup.find_all('a', class_='topic-tag')\n        for t in topic_tags:\n            topics.append(t.get_text(strip=True))\n        data['topics'] = topics\n\n        # OSINT: Social Preview Image\n        og_image = soup.find('meta', property='og:image')\n        data['social_preview'] = og_image.get('content') if og_image else None\n        \n        return data\n        \n    except Exception as e:\n        print_warning(f\"Scraping failed: {e}\")\n        return None"
      },
      "reasons": [
        "Function has 108 lines (threshold: 100). Slightly oversized.",
        "Cyclomatic complexity is 41 (threshold: 15). Too many decision paths.",
        "High logic density (38.0% complexity per line). Code may be too terse.",
        "Makes 14 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 64,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within scrape_repo_info and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split scrape_repo_info into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If scrape_repo_info has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: scrape_repo_info, print_warning, get, BeautifulSoup, strip"
      ]
    },
    {
      "function": {
        "id": "6e59d2e3fee0",
        "name": "display_repo_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "startLine": 70,
        "endLine": 188,
        "lineCount": 119,
        "parameters": [
          "data"
        ],
        "calls": [
          "display_repo_info",
          "grid",
          "add_column",
          "get",
          "join",
          "items",
          "add_row",
          "sum",
          "values",
          "strip",
          "Velocity",
          "Analytics",
          "Clones",
          "Views",
          "Table",
          "Panel"
        ],
        "calledBy": [
          "f5e6adf207a0"
        ],
        "complexity": 44,
        "isExported": false,
        "isAsync": false,
        "docstring": "Displays repository info in a rich panel with traffic analytics.",
        "body": "\ndef display_repo_info(data):\n    \"\"\"Displays repository info in a rich panel with traffic analytics.\"\"\"\n    grid = Table.grid(expand=True)\n    grid.add_column(justify=\"left\", style=\"cyan\", no_wrap=True)\n    grid.add_column(justify=\"left\", style=\"white\")\n\n    fields = {\n        \"Name\": data.get(\"name\"),\n        \"Owner\": data.get(\"owner\", {}).get(\"login\"),\n        \"Visibility\": \"Private\" if data.get(\"private\") else \"Public\",\n        \"Language\": data.get(\"language\"),\n        \"Stars\": str(data.get(\"stargazers_count\")),\n        \"Forks\": str(data.get(\"forks_count\")),\n        \"Issues\": f\"{data.get('open_issues_count')} open\",\n        \"Created\": data.get(\"created_at\"),\n        \"Clone URL\": data.get(\"clone_url\"),\n        \"Used By\": data.get(\"used_by\", \"0\"),\n        \"Sponsors\": \"üíñ Active\" if data.get(\"is_sponsored\") else \"None\"\n    }\n\n    if data.get(\"topics\"):\n        fields[\"Topics\"] = \", \".join(data.get(\"topics\"))\n\n    for label, value in fields.items():\n        grid.add_row(f\"{label}:\", str(value))\n\n    # OSINT: Languages Section\n    if 'osint_languages' in data and data['osint_languages']:\n        langs = data['osint_languages']\n        total_bytes = sum(langs.values())\n        lang_str = \"\"\n        for name, bytes_count in sorted(langs.items(), key=lambda x: x[1], reverse=True)[:5]:\n            percentage = (bytes_count / total_bytes) * 100\n            lang_str += f\"{name} ({percentage:.1f}%) \"\n        grid.add_row(\"Languages:\", lang_str.strip())\n\n    # OSINT: Community Profile\n    if 'osint_community' in data and data['osint_community']:\n        comm = data['osint_community']\n        grid.add_row(\"\", \"\")\n        grid.add_row(\"[bold]Community Intelligence[/bold]\", f\"Health Score: [bold green]{comm.get('health_percentage')}%[/bold green]\")\n        \n        files = comm.get('files', {})\n        readme = \"‚úÖ\" if files.get('readme') else \"‚ùå\"\n        license = \"‚úÖ\" if files.get('license') else \"‚ùå\"\n        coc = \"‚úÖ\" if files.get('code_of_conduct') else \"‚ùå\"\n        grid.add_row(\"Documentation:\", f\"README: {readme} | LICENSE: {license} | CoC: {coc}\")\n\n    # OSINT: Release Summary\n    if 'osint_release' in data and data['osint_release']:\n        rel = data['osint_release']\n        grid.add_row(\"\", \"\")\n        grid.add_row(\"[bold]Latest Intelligence[/bold]\", \"\")\n        grid.add_row(\"Version:\", f\"{rel.get('tag_name')} ({rel.get('name')})\")\n        grid.add_row(\"Released:\", rel.get('published_at', '')[:10])\n\n    # Health & Activity Section\n    if 'health' in data and data['health']:\n        health = data['health']\n        grid.add_row(\"\", \"\")\n        grid.add_row(\"[bold]Health & Activity[/bold]\", \"\")\n        \n        if 'development_velocity_days' in health:\n            grid.add_row(\"Dev Velocity (Median):\", f\"{health['development_velocity_days']} days/commit\")\n        \n        if 'activity_status' in health:\n            status_color = \"green\" if health['activity_status'] == \"Active/Bursting\" else \"white\"\n            grid.add_row(\"Activity Status:\", f\"[{status_color}]{health['activity_status']}[/{status_color}]\")\n            \n        if 'closed_issues' in health:\n            grid.add_row(\"Closed Issues:\", str(health['closed_issues']))\n            \n        if 'contributors_count' in health:\n            grid.add_row(\"Total Contributors:\", str(health['contributors_count']))\n\n    # Traffic analytics section if available\n    if 'traffic' in data and data['traffic']:\n        traffic = data['traffic']\n        grid.add_row(\"\", \"\") # Spacer\n        grid.add_row(\"[bold]Traffic Analytics (Admin Only)[/bold]\", \"\")\n\n        if 'clones' in traffic and traffic['clones'].get('clones'):\n            # Safely get the last element or use defaults\n            clones_list = traffic['clones']['clones']\n            if clones_list:\n                latest_clones = clones_list[-1]\n                grid.add_row(\"Clones (Last recorded):\", f\"{latest_clones['count']} ({latest_clones['uniques']} unique)\")\n\n        if 'views' in traffic and traffic['views'].get('views'):\n            views_list = traffic['views']['views']\n            if views_list:\n                latest_views = views_list[-1]\n                grid.add_row(\"Views (Last recorded):\", f\"{latest_views['count']} ({latest_views['uniques']} unique)\")\n\n        if 'referrers' in traffic and traffic['referrers']:\n            referrer_table = Table(title=\"Top Referrers\", box=box.SIMPLE)\n            referrer_table.add_column(\"Referrer\", style=\"cyan\")\n            referrer_table.add_column(\"Visits\", style=\"green\")\n            referrer_table.add_column(\"Unique\", style=\"yellow\")\n\n            for referrer in traffic['referrers'][:5]:\n                referrer_table.add_row(\n                    referrer['referrer'],\n                    str(referrer['count']),\n                    str(referrer['uniques'])\n                )\n            \n            grid.add_row(\"\", \"\")\n            grid.add_row(\"Traffic Sources:\", referrer_table)\n\n    panel = Panel(\n        grid,\n        title=f\"[bold]{data.get('full_name')}[/bold]\",\n        border_style=\"green\" if not data.get(\"private\") else \"red\",\n        subtitle=data.get(\"description\") or \"No description\"\n    )\n    console.print(panel)\n"
      },
      "reasons": [
        "Function has 119 lines (threshold: 100). Slightly oversized.",
        "Cyclomatic complexity is 44 (threshold: 15). Too many decision paths.",
        "High logic density (37.0% complexity per line). Code may be too terse.",
        "Makes 16 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 64,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within display_repo_info and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split display_repo_info into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If display_repo_info has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: display_repo_info, grid, add_column, get, join"
      ]
    },
    {
      "function": {
        "id": "65c5d1c696bf",
        "name": "scan_todos",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
        "startLine": 33,
        "endLine": 129,
        "lineCount": 97,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "scan_todos",
          "print_info",
          "input",
          "patterns",
          "split",
          "get_issues",
          "json",
          "print_warning",
          "strip",
          "glob",
          "isfile",
          "open",
          "search",
          "group",
          "get_git_author",
          "get_code_context",
          "append",
          "print_success",
          "search_user_by_email",
          "get",
          "create_issue",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 39,
        "isExported": false,
        "isAsync": false,
        "docstring": "Advanced TODO scanner with Git Blame and Context support.",
        "body": "\ndef scan_todos(github_username, github_token, config, args=None):\n    \"\"\"Advanced TODO scanner with Git Blame and Context support.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: Scanning but not creating issues. ***\")\n\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    pattern_input = args.pattern if args and args.pattern else input(\"Enter file patterns (e.g., *.py,*.js) [*.py]: \")\n    file_patterns = pattern_input.split(\",\") if pattern_input else [\"*.py\"]\n    \n    print_info(f\"Scanning for TODOs in {repo_name} using patterns {file_patterns}...\")\n\n    # Fetch existing issues to avoid duplicates\n    print_info(\"Checking existing issues to prevent duplicates...\")\n    existing_titles = []\n    try:\n        issue_resp = get_issues(github_username, repo_name, github_token, state='all')\n        if issue_resp.status_code == 200:\n            existing_titles = [i['title'] for i in issue_resp.json()]\n    except Exception:\n        print_warning(\"Could not fetch existing issues. Duplicate detection disabled.\")\n\n    found_todos = []\n    for pattern in file_patterns:\n        # Clean pattern for glob\n        clean_pattern = pattern.strip()\n        for file_path in glob.glob(clean_pattern, recursive=True):\n            if os.path.isfile(file_path) and \".git\" not in file_path:\n                try:\n                    with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                        for line_num, line in enumerate(f, 1):\n                            if \"TODO\" in line:\n                                match = re.search(r'TODO:(.*)', line, re.IGNORECASE)\n                                if match:\n                                    comment = match.group(1).strip()\n                                    author = get_git_author(file_path, line_num)\n                                    context = get_code_context(file_path, line_num)\n                                    found_todos.append({\n                                        \"file\": file_path,\n                                        \"line\": line_num,\n                                        \"comment\": comment,\n                                        \"author\": author,\n                                        \"context\": context\n                                    })\n                except Exception as e:\n                    print_warning(f\"Skipping {file_path}: {e}\")\n\n    if not found_todos:\n        print_success(\"Clean sweep! No TODOs found.\")\n        return\n\n    print_info(f\"Found {len(found_todos)} TODOs. Processing...\")\n    \n    created_count = 0\n    for todo in found_todos:\n        title = f\"TODO: {todo['comment'][:50]}\" # Cap title length\n        if title in existing_titles:\n            print_warning(f\"Skipping duplicate issue: {title}\")\n            continue\n\n        body = f\"### Description\\n{todo['comment']}\\n\\n\"\n        body += f\"### Location\\n- **File:** `{todo['file']}`\\n- **Line:** {todo['line']}\\n\"\n        if todo['author']:\n            body += f\"- **Blame:** {todo['author']}\\n\"\n        \n        body += f\"\\n### Context\\n{todo['context']}\\n\\n\"\n        body += \"_Generated automatically by PyGitUp Smart Issue engine._\"\n\n        if args and args.dry_run:\n            print(f\"[DRY-RUN] Would create issue: {title}\")\n            created_count += 1\n            continue\n\n        # Real-Time Identity Resolution: Map email to actual GitHub username\n        resolved_assignees = [name.strip() for name in args.assign.split(\",\")] if args and args.assign else []\n        if todo['author']:\n            user_resp = search_user_by_email(todo['author'], github_token)\n            if user_resp.status_code == 200:\n                items = user_resp.json().get('items', [])\n                if items:\n                    gh_username = items[0]['login']\n                    if gh_username not in resolved_assignees:\n                        resolved_assignees.append(gh_username)\n                        print_info(f\"Resolved author email {todo['author']} to @{gh_username}\")\n\n        response = create_issue(github_username, repo_name, github_token, title, body, resolved_assignees)\n        if response.status_code == 201:\n            print_success(f\"Created issue: {title}\")\n            created_count += 1\n        else:\n            print_error(f\"Failed to create issue '{title}': {response.status_code}\")\n\n    print_success(f\"Operation complete. {created_count} new issues processed.\")"
      },
      "reasons": [
        "Cyclomatic complexity is 39 (threshold: 15). Too many decision paths.",
        "Function makes 22 distinct calls (threshold: 20). May have too many responsibilities.",
        "High logic density (40.2% complexity per line). Code may be too terse.",
        "Makes 22 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 62,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within scan_todos and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split scan_todos into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If scan_todos has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: scan_todos, print_info, input, patterns, split"
      ]
    },
    {
      "function": {
        "id": "f5e6adf207a0",
        "name": "get_detailed_repo_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
        "startLine": 122,
        "endLine": 226,
        "lineCount": 105,
        "parameters": [
          "args",
          "github_token"
        ],
        "calls": [
          "get_detailed_repo_info",
          "Text",
          "prompt",
          "parse_github_url",
          "print_error",
          "get_repo_info",
          "print_warning",
          "scrape_repo_info",
          "display_repo_info",
          "json",
          "get",
          "get_repo_languages",
          "get_community_profile",
          "get_latest_release",
          "analytics",
          "github_request",
          "get_repo_health_metrics",
          "display_traffic_trends"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 30,
        "isExported": false,
        "isAsync": false,
        "docstring": "Fetch and display comprehensive repository information with insights.",
        "body": "\ndef get_detailed_repo_info(args, github_token):\n    \"\"\"Fetch and display comprehensive repository information with insights.\"\"\"\n    url = args.url if hasattr(args, 'url') and args.url else None\n\n    if not url:\n        questions = [\n            inquirer.Text(\"url\", message=\"Enter the GitHub repository URL\")\n        ]\n        answers = inquirer.prompt(questions)\n        url = answers[\"url\"]\n\n    owner, repo_name = parse_github_url(url)\n    \n    if not owner or not repo_name:\n        print_error(\"Error: Could not parse repository owner and name from the URL.\")\n        print(\"Please ensure the URL is in the format: https://github.com/owner/repo\")\n        return\n\n    print(f\"\\nFetching comprehensive report for '{owner}/{repo_name}'...\")\n    \n    try:\n        # Get basic repo info\n        repo_response = get_repo_info(owner, repo_name, github_token)\n        if repo_response.status_code != 200:\n            print_warning(f\"API Error: {repo_response.status_code} - {repo_response.text}\")\n            print_warning(\"Attempting to fallback to HTML scraping...\")\n            \n            scraped_data = scrape_repo_info(url)\n            if scraped_data:\n                display_repo_info(scraped_data)\n                return\n            else:\n                print_error(\"Failed to fetch repository data via API and Scraping.\")\n                return\n\n        repo_data = repo_response.json()\n\n        # Hybrid Intelligence: Scrape data that API hides\n        try:\n            full_url = f\"https://github.com/{owner}/{repo_name}\"\n            scraped_intel = scrape_repo_info(full_url)\n            if scraped_intel:\n                repo_data['used_by'] = scraped_intel.get('used_by')\n                repo_data['is_sponsored'] = scraped_intel.get('is_sponsored')\n                repo_data['topics'] = scraped_intel.get('topics', [])\n                repo_data['social_preview'] = scraped_intel.get('social_preview')\n        except Exception:\n            pass\n\n        # OSINT Upgrade: Fetch deep metadata\n        try:\n            # Languages\n            lang_resp = get_repo_languages(owner, repo_name, github_token)\n            if lang_resp.status_code == 200:\n                repo_data['osint_languages'] = lang_resp.json()\n            \n            # Community Profile\n            comm_resp = get_community_profile(owner, repo_name, github_token)\n            if comm_resp.status_code == 200:\n                repo_data['osint_community'] = comm_resp.json()\n            \n            # Latest Release\n            rel_resp = get_latest_release(owner, repo_name, github_token)\n            if rel_resp.status_code == 200:\n                repo_data['osint_release'] = rel_resp.json()\n        except Exception:\n            pass\n\n        # Add traffic analytics (requires push access)\n        traffic_data = {}\n        try:\n            # Clones data\n            clones_response = github_request(\"GET\", f\"https://api.github.com/repos/{owner}/{repo_name}/traffic/clones\", github_token)\n            if clones_response.status_code == 200:\n                traffic_data['clones'] = clones_response.json()\n\n            # Views data\n            views_response = github_request(\"GET\", f\"https://api.github.com/repos/{owner}/{repo_name}/traffic/views\", github_token)\n            if views_response.status_code == 200:\n                traffic_data['views'] = views_response.json()\n\n            # Referrers data\n            referrers_response = github_request(\"GET\", f\"https://api.github.com/repos/{owner}/{repo_name}/traffic/popular/referrers\", github_token)\n            if referrers_response.status_code == 200:\n                traffic_data['referrers'] = referrers_response.json()\n\n            if traffic_data:\n                repo_data['traffic'] = traffic_data\n        except Exception as e:\n            # Silently fail for traffic data if permissions are missing, or log warning\n            pass\n\n        # Add health metrics\n        health_metrics = get_repo_health_metrics(owner, repo_name, github_token)\n        repo_data['health'] = health_metrics\n        \n        # Display comprehensive report\n        display_repo_info(repo_data)\n        \n        if 'traffic' in repo_data and repo_data['traffic']:\n            display_traffic_trends(repo_data['traffic'])\n\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
      },
      "reasons": [
        "Function has 105 lines (threshold: 100). Slightly oversized.",
        "Cyclomatic complexity is 30 (threshold: 15). Too many decision paths.",
        "Makes 18 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 59,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within get_detailed_repo_info and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split get_detailed_repo_info into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If get_detailed_repo_info has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: get_detailed_repo_info, Text, prompt, parse_github_url, print_error"
      ]
    },
    {
      "function": {
        "id": "cae9e9daf651",
        "name": "manage_actions",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/actions.py",
        "startLine": 4,
        "endLine": 84,
        "lineCount": 81,
        "parameters": [
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "manage_actions",
          "print_header",
          "List",
          "prompt",
          "Text",
          "github_request",
          "json",
          "get",
          "print_error",
          "input",
          "ref",
          "print_success",
          "print_info",
          "fromisoformat",
          "replace",
          "divmod",
          "total_seconds",
          "Rate",
          "lower",
          "toggle_workflow_api"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 26,
        "isExported": false,
        "isAsync": false,
        "docstring": "Advanced GitHub Actions Control Center.",
        "body": "\ndef manage_actions(args, github_username, github_token):\n    \"\"\"Advanced GitHub Actions Control Center.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n\n    if not action:\n        print_header(\"CI/CD Control Center\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"Select an Actions operation\",\n                choices=[\"Trigger Workflow\", \"Monitor Status & Metrics\", \"Enable Workflow\", \"Disable Workflow\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n    if not repo_name:\n        repo_name = inquirer.prompt([inquirer.Text(\"repo\", message=\"Enter the repository name\")])[\"repo\"]\n\n    base_url = f\"https://api.github.com/repos/{github_username}/{repo_name}/actions\"\n\n    try:\n        if action == \"Trigger Workflow\":\n            # List workflows first to let user choose\n            w_resp = github_request(\"GET\", f\"{base_url}/workflows\", github_token)\n            workflows = w_resp.json().get(\"workflows\", [])\n            if not workflows:\n                print_error(\"No workflows found.\")\n                return\n            \n            choices = [(w['name'], w['id']) for w in workflows]\n            w_choice = inquirer.prompt([inquirer.List(\"w\", message=\"Select workflow to trigger\", choices=choices)])[\"w\"]\n            ref = input(\"Enter ref (branch/tag) [main]: \") or \"main\"\n            \n            trigger_url = f\"{base_url}/workflows/{w_choice}/dispatches\"\n            github_request(\"POST\", trigger_url, github_token, json={\"ref\": ref})\n            print_success(f\"Successfully triggered workflow run on {ref}\")\n\n        elif action == \"Monitor Status & Metrics\":\n            print_info(f\"Fetching execution metrics for {repo_name}...\")\n            run_resp = github_request(\"GET\", f\"{base_url}/runs\", github_token, params={\"per_page\": 10})\n            runs = run_resp.json().get(\"workflow_runs\", [])\n            \n            if not runs:\n                print_info(\"No recent runs found.\")\n                return\n\n            print(\"\\n[bold]Recent Workflow Runs & Metrics:[/bold]\")\n            success_count = 0\n            from datetime import datetime\n            for run in runs:\n                status_icon = \"üü¢\" if run['conclusion'] == \"success\" else \"üî¥\" if run['conclusion'] == \"failure\" else \"‚è≥\"\n                if run['conclusion'] == \"success\": success_count += 1\n                \n                duration_str = \"N/A\"\n                if run.get('updated_at') and run.get('run_started_at'):\n                    start = datetime.fromisoformat(run['run_started_at'].replace('Z', '+00:00'))\n                    end = datetime.fromisoformat(run['updated_at'].replace('Z', '+00:00'))\n                    diff = end - start\n                    minutes, seconds = divmod(diff.total_seconds(), 60)\n                    duration_str = f\"{int(minutes)}m {int(seconds)}s\"\n\n                print(f\"{status_icon} ID: {run['id']} | {run['name']} | Time: {duration_str} | Result: {run['conclusion']}\")\n            \n            success_rate = (success_count / len(runs)) * 100\n            print(f\"\\n[bold cyan]Success Rate (Last 10): {success_rate:.0f}%[/bold cyan]\")\n\n        elif \"Workflow\" in action:\n            enable = \"Enable\" in action\n            w_resp = github_request(\"GET\", f\"{base_url}/workflows\", github_token)\n            workflows = w_resp.json().get(\"workflows\", [])\n            choices = [(w['name'], w['id']) for w in workflows]\n            w_choice = inquirer.prompt([inquirer.List(\"w\", message=f\"Select workflow to {action.lower()}\", choices=choices)])[\"w\"]\n            \n            toggle_workflow_api(github_username, repo_name, github_token, w_choice, enable=enable)\n            print_success(f\"Workflow {action.lower()}d successfully.\")\n\n    except Exception as e:\n        print_error(f\"Actions operation failed: {e}\")"
      },
      "reasons": [
        "Cyclomatic complexity is 26 (threshold: 15). Too many decision paths.",
        "High logic density (32.1% complexity per line). Code may be too terse.",
        "Makes 20 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 54,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within manage_actions and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split manage_actions into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If manage_actions has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: manage_actions, print_header, List, prompt, Text"
      ]
    },
    {
      "function": {
        "id": "8037213f9b0d",
        "name": "manage_gists",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
        "startLine": 5,
        "endLine": 84,
        "lineCount": 80,
        "parameters": [
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "manage_gists",
          "print_header",
          "List",
          "prompt",
          "print_info",
          "Text",
          "Confirm",
          "check_is_sensitive",
          "print_warning",
          "input",
          "lower",
          "github_request",
          "raise_for_status",
          "json",
          "print_success",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 32,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle Gist management operations with rate-limiting support.",
        "body": "\ndef manage_gists(args, github_username, github_token):\n    \"\"\"Handle Gist management operations with rate-limiting support.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    filename = args.filename if hasattr(args, 'filename') and args.filename else None\n    content = args.content if hasattr(args, 'content') and args.content else None\n    description = args.description if hasattr(args, 'description') and args.description else None\n    public = args.public if hasattr(args, 'public') and args.public else False\n\n    if not action:\n        print_header(\"Gist Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What Gist operation would you like to perform?\",\n                choices=[\"create\", \"list\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        if not answers:\n            print_info(\"Operation cancelled.\")\n            return\n        action = answers[\"action\"]\n\n        if action == \"create\":\n            gist_questions = [\n                inquirer.Text(\"filename\", message=\"Enter the filename for the Gist\"),\n                inquirer.Text(\"content\", message=\"Enter the content of the Gist\"),\n                inquirer.Text(\"description\", message=\"Enter an optional description for the Gist\"),\n                inquirer.Confirm(\"public\", message=\"Make the Gist public?\", default=False),\n            ]\n            gist_answers = inquirer.prompt(gist_questions)\n            if not gist_answers:\n                print_info(\"Operation cancelled.\")\n                return\n            filename = gist_answers[\"filename\"]\n            content = gist_answers[\"content\"]\n            description = gist_answers[\"description\"]\n            public = gist_answers[\"public\"]\n\n    try:\n        if action == \"create\":\n            # Security check for Gist content/filename\n            if check_is_sensitive(filename):\n                print_warning(f\"'{filename}' appears to be a sensitive filename pattern.\")\n                confirm = input(\"Are you sure you want to create this Gist? (y/n): \").lower()\n                if confirm != 'y':\n                    print_info(\"Gist creation cancelled.\")\n                    return\n\n            data = {\n                \"description\": description or \"\",\n                \"public\": public,\n                \"files\": {\n                    filename: {\n                        \"content\": content\n                    }\n                }\n            }\n            response = github_request(\"POST\", \"https://api.github.com/gists\", github_token, json=data)\n            response.raise_for_status()\n            gist_data = response.json()\n            print_success(\"Gist created successfully!\")\n            print_info(f\"View it here: {gist_data['html_url']}\")\n\n        elif action == \"list\":\n            url = f\"https://api.github.com/users/{github_username}/gists\"\n            response = github_request(\"GET\", url, github_token)\n            response.raise_for_status()\n            gists = response.json()\n            if gists:\n                print_info(\"Your Gists:\")\n                for gist in gists:\n                    gist_desc = gist['description'] or \"No description\"\n                    print(f\"- {gist['html_url']} ({gist_desc})\")\n            else:\n                print_info(\"You don't have any Gists.\")\n\n    except Exception as e:\n        print_error(f\"Gist operation failed: {e}\")"
      },
      "reasons": [
        "Cyclomatic complexity is 32 (threshold: 15). Too many decision paths.",
        "High logic density (40.0% complexity per line). Code may be too terse.",
        "Makes 16 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 54,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within manage_gists and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split manage_gists into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If manage_gists has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: manage_gists, print_header, List, prompt, print_info"
      ]
    },
    {
      "function": {
        "id": "dd4bb98c5440",
        "name": "request_code_review",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
        "startLine": 70,
        "endLine": 143,
        "lineCount": 74,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "request_code_review",
          "print_info",
          "prompt",
          "Text",
          "time",
          "run",
          "split",
          "input",
          "review",
          "join",
          "reviewers",
          "create_pull_request",
          "json",
          "print_success",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 28,
        "isExported": false,
        "isAsync": false,
        "docstring": "Request code reviews for specific files.",
        "body": "\ndef request_code_review(github_username, github_token, config, args=None):\n    \"\"\"Request code reviews for specific files.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would request a code review.\")\n        return\n\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = inquirer.prompt([inquirer.Text(\"repo\", message=\"Enter the repository name\")])[\"repo\"]\n\n    # Create a new branch for the review\n    branch_name = f\"review-{int(time.time())}\"\n\n    try:\n        # Create and switch to the new branch\n        subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n        print_info(f\"Created and switched to new branch: {branch_name}\")\n\n        if args and args.files:\n            files = args.files.split(\",\")\n        else:\n            files_input = input(\"Enter files to review (comma-separated): \")\n            files = files_input.split(\",\") if files_input else []\n\n        if files:\n            # Add the specified files to the branch\n            subprocess.run([\"git\", \"add\"] + files, check=True)\n            print_info(f\"Added files to the branch: {files}\")\n\n            # Commit the changes\n            commit_message = f\"Code review request for: {', '.join(files)}\"\n            subprocess.run([\"git\", \"commit\", \"-m\", commit_message], check=True)\n            print_info(\"Committed changes to the branch.\")\n\n        # Push the new branch to GitHub\n        subprocess.run([\"git\", \"push\", \"-u\", \"origin\", branch_name], check=True)\n        print_info(\"Pushed the new branch to GitHub.\")\n\n        reviewers = []\n        if args and args.reviewers:\n            reviewers = args.reviewers.split(\",\")\n        else:\n            reviewers_input = input(\"Enter reviewers (comma-separated GitHub usernames): \")\n            reviewers = reviewers_input.split(\",\") if reviewers_input else []\n\n        # Create a pull request\n        pr_title = f\"Code Review Request: {', '.join(files) if files else 'General Review'}\"\n        pr_body = f\"This PR is requesting code review for the following files:\\n\"\n        for file in files:\n            pr_body += f\"- {file}\\n\"\n\n        if reviewers:\n            pr_body += f\"\\nRequested reviewers: {', '.join(reviewers)}\"\n\n        response = create_pull_request(github_username, repo_name, github_token, pr_title, branch_name, \"main\", pr_body)\n\n        if response.status_code == 201:\n            pr_data = response.json()\n            print_success(\"\\nPull request created successfully!\")\n            print_info(f\"View it here: {pr_data['html_url']}\")\n        else:\n            print_error(f\"\\nError creating pull request: {response.status_code} - {response.text}\")\n\n    except subprocess.CalledProcessError as e:\n        print_error(f\"An error occurred while running a git command: {e}\")\n    except Exception as e:\n        print_error(f\"An error occurred: {e}\")\n    finally:\n        # Switch back to the main branch\n        subprocess.run([\"git\", \"checkout\", \"main\"], check=True)\n        print_info(\"Switched back to the main branch.\")"
      },
      "reasons": [
        "Cyclomatic complexity is 28 (threshold: 15). Too many decision paths.",
        "High logic density (37.8% complexity per line). Code may be too terse.",
        "Makes 15 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 54,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within request_code_review and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split request_code_review into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If request_code_review has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: request_code_review, print_info, prompt, Text, time"
      ]
    },
    {
      "function": {
        "id": "1d0f56ea40c1",
        "name": "manage_webhooks",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/webhooks.py",
        "startLine": 4,
        "endLine": 86,
        "lineCount": 83,
        "parameters": [
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "manage_webhooks",
          "print_header",
          "List",
          "prompt",
          "Text",
          "to",
          "strip",
          "split",
          "print_error",
          "github_request",
          "raise_for_status",
          "json",
          "print_info",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 33,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle webhook management operations with rate-limiting support.",
        "body": "\ndef manage_webhooks(args, github_username, github_token):\n    \"\"\"Handle webhook management operations with rate-limiting support.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n    hook_id = args.hook_id if hasattr(args, 'hook_id') and args.hook_id else None\n    url = args.url if hasattr(args, 'url') and args.url else None\n    events = args.events if hasattr(args, 'events') and args.events else ['push']\n\n    if not action:\n        print_header(\"Webhook Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What webhook operation would you like to perform?\",\n                choices=[\"list\", \"create\", \"delete\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if not repo_name:\n            repo_questions = [inquirer.Text(\"repo\", message=\"Enter the repository name\")]\n            repo_answers = inquirer.prompt(repo_questions)\n            repo_name = repo_answers[\"repo\"]\n\n        if action == \"create\":\n            webhook_questions = [\n                inquirer.Text(\"url\", message=\"Enter the webhook URL\"),\n                inquirer.Text(\"events\", message=\"Enter events to subscribe to (comma-separated)\", default=\"push\"),\n            ]\n            webhook_answers = inquirer.prompt(webhook_questions)\n            url = webhook_answers[\"url\"]\n            events = [e.strip() for e in webhook_answers[\"events\"].split(\",\")]\n\n        elif action == \"delete\":\n            hook_id_questions = [inquirer.Text(\"hook_id\", message=\"Enter the ID of the webhook to delete\")]\n            hook_id_answers = inquirer.prompt(hook_id_questions)\n            hook_id = hook_id_answers[\"hook_id\"]\n\n    if not repo_name:\n        print_error(\"Repository name is required for webhook operations.\")\n        return\n\n    base_url = f\"https://api.github.com/repos/{github_username}/{repo_name}/hooks\"\n\n    try:\n        if action == \"list\":\n            response = github_request(\"GET\", base_url, github_token)\n            response.raise_for_status()\n            hooks = response.json()\n            if hooks:\n                print_info(f\"Webhooks for {repo_name}:\")\n                for hook in hooks:\n                    print(f\"- ID: {hook['id']}, URL: {hook['config']['url']}, Events: {hook['events']}\")\n            else:\n                print_info(f\"No webhooks found for {repo_name}.\")\n\n        elif action == \"create\":\n            data = {\n                \"name\": \"web\",\n                \"active\": True,\n                \"events\": events,\n                \"config\": {\n                    \"url\": url,\n                    \"content_type\": \"json\"\n                }\n            }\n            response = github_request(\"POST\", base_url, github_token, json=data)\n            response.raise_for_status()\n            print_success(\"Webhook created successfully!\")\n\n        elif action == \"delete\":\n            if not hook_id:\n                print_error(\"Hook ID is required for deletion.\")\n                return\n            delete_url = f\"{base_url}/{hook_id}\"\n            response = github_request(\"DELETE\", delete_url, github_token)\n            response.raise_for_status()\n            print_success(\"Webhook deleted successfully!\")\n\n    except Exception as e:\n        print_error(f\"Webhook operation failed: {e}\")"
      },
      "reasons": [
        "Cyclomatic complexity is 33 (threshold: 15). Too many decision paths.",
        "High logic density (39.8% complexity per line). Code may be too terse.",
        "Makes 14 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 54,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within manage_webhooks and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split manage_webhooks into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If manage_webhooks has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: manage_webhooks, print_header, List, prompt, Text"
      ]
    },
    {
      "function": {
        "id": "b9152e2e05f3",
        "name": "upload_single_file",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 204,
        "endLine": 277,
        "lineCount": 74,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "upload_single_file",
          "print_info",
          "get_single_file_input",
          "print_header",
          "validate_file_path",
          "print_error",
          "validate_repo_name",
          "check_is_sensitive",
          "print_warning",
          "input",
          "lower",
          "open",
          "getsize",
          "tqdm",
          "read",
          "update",
          "exit",
          "get_file_info",
          "json",
          "update_file",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 23,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handles the entire process of uploading/updating a single file.",
        "body": "\ndef upload_single_file(github_username, github_token, config, args=None):\n    \"\"\"Handles the entire process of uploading/updating a single file.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        repo_name, local_file_path, repo_file_path, commit_message = get_single_file_input(config, args)\n        print_info(f\"Would upload {local_file_path} to {repo_name}/{repo_file_path} with message: {commit_message}\")\n        return\n\n    print_header(\"Upload Single File\")\n    repo_name, local_file_path, repo_file_path, commit_message = get_single_file_input(config, args)\n\n    # Input Validation\n    is_valid_path, path_err = validate_file_path(local_file_path)\n    if not is_valid_path:\n        print_error(f\"Error: {path_err}\")\n        return False\n\n    is_valid_repo, repo_err = validate_repo_name(repo_name)\n    if not is_valid_repo:\n        print_error(f\"Error: {repo_err}\")\n        return False\n\n    if check_is_sensitive(local_file_path):\n        print_warning(f\"'{local_file_path}' appears to be a sensitive file.\")\n        confirm = input(\"Are you sure you want to upload it? (y/n): \").lower()\n        if confirm != 'y':\n            print_info(\"Upload cancelled.\")\n            return False\n\n    try:\n        with open(local_file_path, \"rb\") as f:\n            if TQDM_AVAILABLE:\n                file_size = os.path.getsize(local_file_path)\n                with tqdm(total=file_size, unit='B', unit_scale=True, desc=\"Reading file\") as pbar:\n                    content = f.read()\n                    pbar.update(len(content))\n            else:\n                content = f.read()\n    except FileNotFoundError:\n        print_error(f\"Error: The local file '{local_file_path}' was not found.\")\n        if not args or not args.batch:\n            sys.exit(1)\n        return False\n    except Exception as e:\n        print_error(f\"Error reading file: {e}\")\n        if not args or not args.batch:\n            sys.exit(1)\n        return False\n\n    sha = None\n    response = get_file_info(github_username, repo_name, repo_file_path, github_token)\n    if response.status_code == 200:\n        print_info(\"File exists in the repository. It will be overwritten.\")\n        sha = response.json()['sha']\n    elif response.status_code != 404:\n        print_error(f\"Error checking for file: {response.status_code} - {response.text}\")\n        if not args or not args.batch:\n            sys.exit(1)\n        return False\n\n    response = update_file(github_username, repo_name, repo_file_path, content, github_token, commit_message, sha)\n    if response.status_code == 201:\n        print_success(f\"Successfully created file '{repo_file_path}' in '{repo_name}'.\")\n    elif response.status_code == 200:\n        print_success(f\"Successfully updated file '{repo_file_path}' in '{repo_name}'.\")\n    else:\n        print_error(f\"Error uploading file: {response.status_code} - {response.text}\")\n        if not args or not args.batch:\n            sys.exit(1)\n        return False\n    print_info(f\"View the file at: {response.json()['content']['html_url']}\")\n    return True\n"
      },
      "reasons": [
        "Cyclomatic complexity is 23 (threshold: 15). Too many decision paths.",
        "Function makes 21 distinct calls (threshold: 20). May have too many responsibilities.",
        "High logic density (31.1% complexity per line). Code may be too terse.",
        "Makes 21 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 47,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within upload_single_file and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split upload_single_file into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If upload_single_file has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: upload_single_file, print_info, get_single_file_input, print_header, validate_file_path"
      ]
    },
    {
      "function": {
        "id": "ebb909c21ccf",
        "name": "manage_tags",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/tag.py",
        "startLine": 4,
        "endLine": 63,
        "lineCount": 60,
        "parameters": [
          "args"
        ],
        "calls": [
          "manage_tags",
          "print_header",
          "List",
          "prompt",
          "Text",
          "print_info",
          "run",
          "print_error",
          "extend",
          "append",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 22,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle tag management operations with styled output.",
        "body": "\ndef manage_tags(args):\n    \"\"\"Handle tag management operations with styled output.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    tag_name = args.tag_name if hasattr(args, 'tag_name') and args.tag_name else None\n    message = args.message if hasattr(args, 'message') and args.message else None\n\n    if not action:\n        print_header(\"Tag Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What tag operation would you like to perform?\",\n                choices=[\"list\", \"create\", \"delete\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if action in [\"create\", \"delete\"]:\n            tag_questions = [\n                inquirer.Text(\"tag_name\", message=f\"Enter the name of the tag to {action}\")\n            ]\n            tag_answers = inquirer.prompt(tag_questions)\n            tag_name = tag_answers[\"tag_name\"]\n\n        if action == \"create\":\n            message_questions = [\n                inquirer.Text(\"message\", message=\"Enter an optional annotation message for the tag\")\n            ]\n            message_answers = inquirer.prompt(message_questions)\n            message = message_answers[\"message\"]\n\n    try:\n        if action == \"list\":\n            print_info(\"Listing all tags:\")\n            subprocess.run([\"git\", \"tag\"], check=True)\n        elif action == \"create\":\n            if not tag_name:\n                print_error(\"Tag name is required.\")\n                return\n            command = [\"git\", \"tag\"]\n            if message:\n                command.extend([\"-a\", tag_name, \"-m\", message])\n            else:\n                command.append(tag_name)\n            print_info(f\"Creating new tag: {tag_name}\")\n            subprocess.run(command, check=True)\n            print_success(f\"Tag '{tag_name}' created.\")\n        elif action == \"delete\":\n            if not tag_name:\n                print_error(\"Tag name is required.\")\n                return\n            print_info(f\"Deleting tag: {tag_name}\")\n            subprocess.run([\"git\", \"tag\", \"-d\", tag_name], check=True)\n            print_success(f\"Tag '{tag_name}' deleted.\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
      },
      "reasons": [
        "Cyclomatic complexity is 22 (threshold: 15). Too many decision paths.",
        "High logic density (36.7% complexity per line). Code may be too terse.",
        "Makes 11 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 39,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within manage_tags and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split manage_tags into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If manage_tags has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: manage_tags, print_header, List, prompt, Text"
      ]
    },
    {
      "function": {
        "id": "51e6ef2a0fbb",
        "name": "get_release_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
        "startLine": 23,
        "endLine": 78,
        "lineCount": 56,
        "parameters": [
          "config",
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "get_release_input",
          "input",
          "tag",
          "name",
          "Changelog",
          "Editor",
          "print_info",
          "get_commit_history",
          "get",
          "generate_ai_release_notes",
          "json",
          "lower",
          "open_editor",
          "print_error",
          "generate_changelog"
        ],
        "calledBy": [
          "ea6606b7620d"
        ],
        "complexity": 20,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get release input from user or arguments with AI support.",
        "body": "\ndef get_release_input(config, args, github_username, github_token):\n    \"\"\"Get release input from user or arguments with AI support.\"\"\"\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    if args and args.version:\n        version = args.version\n    else:\n        version = input(\"Enter version tag (e.g., v1.0.0): \")\n    \n    if args and args.name:\n        name = args.name\n    else:\n        default_name = f\"Release {version}\"\n        name_input = input(f\"Enter release name (default: {default_name}): \")\n        name = name_input if name_input else default_name\n    \n    # Release Notes Logic\n    changelog = \"\"\n    print(\"\\n[bold]Release Notes Options:[/bold]\")\n    print(\"1: [cyan]AI-Generated Summary[/cyan]\")\n    print(\"2: [green]Auto-Changelog (Commit list)[/green]\")\n    print(\"3: [yellow]Manual Editor (Nano/Vim)[/yellow]\")\n    print(\"4: [white]Skip / Basic prompt[/white]\")\n    \n    note_choice = input(\"\\nüëâ Choice: \")\n    \n    if note_choice == '1':\n        print_info(\"ü§ñ AI is analyzing your project history...\")\n        resp = get_commit_history(github_username, repo_name, github_token)\n        if resp.status_code == 200:\n            ai_key = config[\"github\"].get(\"ai_api_key\")\n            changelog = generate_ai_release_notes(ai_key, repo_name, resp.json())\n            # Let user tweak the AI's output\n            if changelog:\n                confirm = input(\"AI notes generated. Edit them before publishing? (y/n): \").lower()\n                if confirm == 'y':\n                    changelog = open_editor(changelog)\n        else:\n            print_error(\"Failed to fetch history for AI.\")\n            \n    elif note_choice == '2':\n        changelog = generate_changelog(github_username, repo_name, github_token, version)\n    elif note_choice == '3':\n        changelog = open_editor(\"# Release Notes for \" + version + \"\\n\\n\")\n    else:\n        if args and args.message:\n            changelog = args.message\n        else:\n            changelog = input(\"Enter release notes: \")\n    \n    return repo_name, version, name, changelog\n"
      },
      "reasons": [
        "Cyclomatic complexity is 20 (threshold: 15). Too many decision paths.",
        "High logic density (35.7% complexity per line). Code may be too terse.",
        "Makes 15 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 39,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within get_release_input and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split get_release_input into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If get_release_input has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: get_release_input, input, tag, name, Changelog"
      ]
    },
    {
      "function": {
        "id": "8cdb7133190e",
        "name": "get_single_file_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 143,
        "endLine": 204,
        "lineCount": 62,
        "parameters": [
          "config",
          "args"
        ],
        "calls": [
          "get_single_file_input",
          "input",
          "print_info",
          "print_header",
          "getcwd",
          "listdir",
          "isfile",
          "print_error",
          "interactively",
          "repository",
          "message"
        ],
        "calledBy": [
          "b9152e2e05f3"
        ],
        "complexity": 21,
        "isExported": false,
        "isAsync": false,
        "docstring": "Gets user input for the file upload details.",
        "body": "\ndef get_single_file_input(config, args=None):\n    \"\"\"Gets user input for the file upload details.\"\"\"\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter the name of the target GitHub repository: \")\n\n    if args and args.file:\n        local_file_path = args.file\n        print_info(f\"Selected file: {local_file_path}\")\n    else:\n        print_header(\"Select a file to upload\")\n        local_file_path = None\n        try:\n            current_directory = os.getcwd()\n            print_info(f\"Listing files in: {current_directory}\")\n            \n            files = [item for item in os.listdir('.') if os.path.isfile(item)]\n\n            if not files:\n                print_info(\"No files found in the current directory.\")\n            else:\n                for i, filename in enumerate(files):\n                    print(f\"{i + 1}: {filename}\")\n                \n                print(\"\\nEnter the number of the file to upload, or type a different path manually.\")\n                choice = input(\"> \")\n\n                try:\n                    file_index = int(choice) - 1\n                    if 0 <= file_index < len(files):\n                        local_file_path = files[file_index]\n                        print_info(f\"You selected: {local_file_path}\")\n                    else:\n                        print_error(\"Invalid number.\")\n                except ValueError:\n                    local_file_path = choice\n                    print_info(f\"You entered path: {local_file_path}\")\n\n        except Exception as e:\n            print_error(f\"Could not list files interactively ({e}).\")\n\n    if not local_file_path:\n        print_info(\"Please provide the file path manually.\")\n        local_file_path = input(\"Enter the full local path of the file to upload: \")\n\n    if args and args.path:\n        repo_file_path = args.path\n    else:\n        repo_file_path = input(\"Enter the path for the file in the repository (e.g., folder/file.txt): \")\n\n    if args and args.message:\n        commit_message = args.message\n    else:\n        default_msg = config[\"defaults\"][\"commit_message\"]\n        commit_message = input(f\"Enter the commit message (default: {default_msg}): \")\n        if not commit_message:\n            commit_message = default_msg\n\n    return repo_name, local_file_path, repo_file_path, commit_message\n"
      },
      "reasons": [
        "Cyclomatic complexity is 21 (threshold: 15). Too many decision paths.",
        "High logic density (33.9% complexity per line). Code may be too terse.",
        "Makes 11 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 39,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within get_single_file_input and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split get_single_file_input into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If get_single_file_input has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: get_single_file_input, input, print_info, print_header, getcwd"
      ]
    },
    {
      "function": {
        "id": "b065ed988f67",
        "name": "get_batch_files_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 277,
        "endLine": 318,
        "lineCount": 42,
        "parameters": [
          "config",
          "args"
        ],
        "calls": [
          "get_batch_files_input",
          "strip",
          "split",
          "print_header",
          "input",
          "lower",
          "listdir",
          "isfile",
          "print_error",
          "repository",
          "message"
        ],
        "calledBy": [
          "8aecc87cfbd7"
        ],
        "complexity": 22,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get files for batch upload.",
        "body": "\ndef get_batch_files_input(config, args=None):\n    \"\"\"Get files for batch upload.\"\"\"\n    if args and args.files:\n        files = [f.strip() for f in args.files.split(',') if f.strip()]\n    else:\n        print_header(\"Select files for batch upload\")\n        print(\"Enter file paths separated by commas, or 'all' for all files in directory:\")\n        files_input = input(\"> \").strip()\n        \n        if files_input.lower() == 'all':\n            files = [item for item in os.listdir('.') if os.path.isfile(item)]\n        else:\n            files = [f.strip() for f in files_input.split(',') if f.strip()]\n    \n    if not files:\n        print_error(\"No files specified.\")\n        return None, None, None, None\n    \n    repo_name = None\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter the name of the target GitHub repository: \")\n    \n    repo_base_path = \"\"\n    if args and args.path:\n        repo_base_path = args.path\n    else:\n        repo_base_path = input(\"Enter base path in repository (optional, e.g., src/): \")\n    \n    default_msg = config[\"defaults\"][\"commit_message\"]\n    commit_message = \"\"\n    if args and args.message:\n        commit_message = args.message\n    else:\n        commit_message = input(f\"Enter the commit message (default: {default_msg}): \")\n        if not commit_message:\n            commit_message = default_msg\n    \n    return files, repo_name, repo_base_path, commit_message\n"
      },
      "reasons": [
        "Cyclomatic complexity is 22 (threshold: 15). Too many decision paths.",
        "High logic density (52.4% complexity per line). Code may be too terse.",
        "Makes 11 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 39,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within get_batch_files_input and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split get_batch_files_input into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If get_batch_files_input has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: get_batch_files_input, strip, split, print_header, input"
      ]
    },
    {
      "function": {
        "id": "72913908c45b",
        "name": "manage_pull_requests",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
        "startLine": 7,
        "endLine": 70,
        "lineCount": 64,
        "parameters": [
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "manage_pull_requests",
          "print_header",
          "List",
          "prompt",
          "Text",
          "print_error",
          "github_request",
          "raise_for_status",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 23,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle pull request management operations with rate-limiting support.",
        "body": "\ndef manage_pull_requests(args, github_username, github_token):\n    \"\"\"Handle pull request management operations with rate-limiting support.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n    pr_number = args.pr_number if hasattr(args, 'pr_number') and args.pr_number else None\n    comment = args.comment if hasattr(args, 'comment') and args.comment else None\n\n    if not action:\n        print_header(\"Pull Request Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What pull request operation would you like to perform?\",\n                choices=[\"merge\", \"close\", \"comment\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if not repo_name:\n            repo_questions = [inquirer.Text(\"repo\", message=\"Enter the repository name\")]\n            repo_answers = inquirer.prompt(repo_questions)\n            repo_name = repo_answers[\"repo\"]\n\n        pr_number_questions = [inquirer.Text(\"pr_number\", message=\"Enter the pull request number\")]\n        pr_number_answers = inquirer.prompt(pr_number_questions)\n        pr_number = int(pr_number_answers[\"pr_number\"])\n\n        if action == \"comment\":\n            comment_questions = [inquirer.Text(\"comment\", message=\"Enter your comment\")]\n            comment_answers = inquirer.prompt(comment_questions)\n            comment = comment_answers[\"comment\"]\n\n    if not repo_name or not pr_number:\n        print_error(\"Repository name and pull request number are required.\")\n        return\n\n    base_url = f\"https://api.github.com/repos/{github_username}/{repo_name}\"\n\n    try:\n        if action == \"merge\":\n            url = f\"{base_url}/pulls/{pr_number}/merge\"\n            response = github_request(\"PUT\", url, github_token)\n            response.raise_for_status()\n            print_success(\"Pull request merged successfully!\")\n\n        elif action == \"close\":\n            url = f\"{base_url}/pulls/{pr_number}\"\n            data = {\"state\": \"closed\"}\n            response = github_request(\"PATCH\", url, github_token, json=data)\n            response.raise_for_status()\n            print_success(\"Pull request closed successfully!\")\n\n        elif action == \"comment\":\n            url = f\"{base_url}/issues/{pr_number}/comments\"\n            data = {\"body\": comment}\n            response = github_request(\"POST\", url, github_token, json=data)\n            response.raise_for_status()\n            print_success(\"Comment added successfully!\")\n\n    except Exception as e:\n        print_error(f\"Pull request operation failed: {e}\")\n"
      },
      "reasons": [
        "Cyclomatic complexity is 23 (threshold: 15). Too many decision paths.",
        "High logic density (35.9% complexity per line). Code may be too terse."
      ],
      "score": 35,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within manage_pull_requests and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If manage_pull_requests has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: manage_pull_requests, print_header, List, prompt, Text"
      ]
    },
    {
      "function": {
        "id": "e638d8d1a537",
        "name": "manage_repo_visibility",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
        "startLine": 5,
        "endLine": 61,
        "lineCount": 57,
        "parameters": [
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "manage_repo_visibility",
          "print_header",
          "append",
          "Text",
          "List",
          "prompt",
          "print_error",
          "print_info",
          "update_repo_visibility",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 23,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle repository visibility changes with styled output.",
        "body": "\ndef manage_repo_visibility(args, github_username, github_token):\n    \"\"\"Handle repository visibility changes with styled output.\"\"\"\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n    \n    # Determine desired state from args\n    target_private = None\n    if hasattr(args, 'private') and args.private:\n        target_private = True\n    elif hasattr(args, 'public') and args.public:\n        target_private = False\n\n    # Interactive mode if info is missing\n    if (not repo_name or target_private is None):\n        print_header(\"Repository Visibility\")\n        questions = []\n        if not repo_name:\n            questions.append(inquirer.Text(\"repo\", message=\"Enter the repository name\"))\n        \n        if target_private is None:\n            questions.append(inquirer.List(\n                \"visibility\",\n                message=\"Select new visibility\",\n                choices=[\"Private\", \"Public\"],\n            ))\n            \n        answers = inquirer.prompt(questions)\n        \n        if not repo_name:\n            repo_name = answers[\"repo\"]\n        \n        if target_private is None:\n            target_private = answers[\"visibility\"] == \"Private\"\n\n    if not repo_name:\n        print_error(\"Repository name is required.\")\n        return\n\n    if target_private is None:\n        print_error(\"You must specify --private or --public, or select an option.\")\n        return\n\n    visibility_str = \"PRIVATE\" if target_private else \"PUBLIC\"\n    print_info(f\"Changing visibility of '{repo_name}' to {visibility_str}...\")\n\n    try:\n        response = update_repo_visibility(github_username, repo_name, github_token, target_private)\n        \n        if response.status_code == 200:\n            print_success(f\"Successfully changed '{repo_name}' to {visibility_str}.\")\n        else:\n            print_error(f\"Failed to change visibility: {response.status_code} - {response.text}\")\n            print_info(\"Note: You need admin access to the repository to change its visibility.\")\n            \n    except Exception as e:\n        print_error(f\"An error occurred: {e}\")\n"
      },
      "reasons": [
        "Cyclomatic complexity is 23 (threshold: 15). Too many decision paths.",
        "High logic density (40.4% complexity per line). Code may be too terse."
      ],
      "score": 35,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within manage_repo_visibility and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If manage_repo_visibility has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: manage_repo_visibility, print_header, append, Text, List"
      ]
    },
    {
      "function": {
        "id": "f1f948b57bf3",
        "name": "smart_push",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/push.py",
        "startLine": 3,
        "endLine": 74,
        "lineCount": 72,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "smart_push",
          "print_info",
          "input",
          "split",
          "squash",
          "run",
          "strip",
          "lower",
          "append",
          "print_success",
          "join",
          "print_warning",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 20,
        "isExported": false,
        "isAsync": false,
        "docstring": "Smart push that squashes meaningless commits with styled output.",
        "body": "\ndef smart_push(github_username, github_token, config, args=None):\n    \"\"\"Smart push that squashes meaningless commits with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would perform a smart push with commit squashing.\")\n        return\n\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n\n    # Get squash patterns\n    if args and args.squash_pattern:\n        patterns = args.squash_pattern.split(\",\")\n    else:\n        patterns_input = input(\"Enter commit message patterns to squash (comma-separated): \")\n        patterns = patterns_input.split(\",\") if patterns_input else [\"typo\", \"fix\", \"update\"]\n\n    print_info(f\"Smart pushing to {repo_name} with squash patterns: {patterns}\")\n\n    try:\n        # Get the last 10 commits\n        log_result = subprocess.run([\"git\", \"log\", \"--oneline\", \"-n\", \"10\"], capture_output=True, text=True, check=True)\n        commits = log_result.stdout.strip().split(\"\\n\")\n\n        # Identify commits to squash\n        commits_to_squash = []\n        for commit in commits:\n            parts = commit.split(\" \", 1)\n            if len(parts) < 2: continue\n            commit_hash, commit_message = parts\n            for pattern in patterns:\n                if pattern.lower() in commit_message.lower():\n                    commits_to_squash.append(commit_hash)\n                    break\n\n        if not commits_to_squash:\n            print_info(\"No commits to squash. Pushing normally.\")\n            subprocess.run([\"git\", \"push\"], check=True)\n            print_success(\"Pushed to GitHub.\")\n            return\n\n        print_info(f\"Found {len(commits_to_squash)} commits to squash: {commits_to_squash}\")\n\n        # The parent of the oldest commit to be squashed\n        squash_base = f\"{commits_to_squash[-1]}~\"\n\n        # Get the messages of the commits being squashed for the new commit message\n        squashed_messages = []\n        for commit_hash in reversed(commits_to_squash):\n            msg = subprocess.run([\"git\", \"log\", \"--format=%B\", \"-n\", \"1\", commit_hash], capture_output=True, text=True, check=True).stdout.strip()\n            squashed_messages.append(msg)\n\n        new_commit_message = f\"Squashed {len(squashed_messages)} commits\\n\\n\" + \"\\n\".join(f\"- {msg}\" for msg in squashed_messages)\n\n        print_info(f\"Resetting to {squash_base} and preparing to squash.\")\n        subprocess.run([\"git\", \"reset\", \"--soft\", squash_base], check=True)\n\n        print_info(\"Creating new squashed commit.\")\n        subprocess.run([\"git\", \"commit\", \"-m\", new_commit_message], check=True)\n\n        print_warning(\"Force-pushing the new history. This will overwrite the remote history.\")\n        subprocess.run([\"git\", \"push\", \"--force-with-lease\"], check=True)\n\n        print_success(\"Smart push complete.\")\n\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
      },
      "reasons": [
        "Cyclomatic complexity is 20 (threshold: 15). Too many decision paths.",
        "Makes 13 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 34,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within smart_push and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split smart_push into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If smart_push has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: smart_push, print_info, input, split, squash"
      ]
    },
    {
      "function": {
        "id": "d4cc0e31330b",
        "name": "process_offline_queue",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
        "startLine": 71,
        "endLine": 145,
        "lineCount": 75,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "process_offline_queue",
          "print_info",
          "exists",
          "open",
          "load",
          "print_error",
          "print_header",
          "read",
          "update_file",
          "now",
          "isoformat",
          "print_success",
          "dump"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 21,
        "isExported": false,
        "isAsync": false,
        "docstring": "Process queued commits when online with styled output.",
        "body": "\ndef process_offline_queue(github_username, github_token, config, args=None):\n    \"\"\"Process queued commits when online with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would process the offline commit queue.\")\n        return\n\n    queue_file = config[\"scheduling\"][\"offline_queue_file\"]\n    \n    if not os.path.exists(queue_file):\n        # Silently return if no queue file exists, unless manually triggered\n        if args and args.mode == \"process-queue\":\n            print_info(\"No offline queue found.\")\n        return\n    \n    try:\n        with open(queue_file, 'r') as f:\n            queue = json.load(f)\n    except Exception as e:\n        print_error(f\"Error loading queue: {e}\")\n        return\n    \n    if not queue:\n        if args and args.mode == \"process-queue\":\n            print_info(\"Offline queue is empty.\")\n        return\n    \n    # Filter for queued entries\n    queued_entries = [e for e in queue if e[\"status\"] == \"queued\"]\n    if not queued_entries:\n        return\n\n    print_header(\"Processing Offline Queue\")\n    print_info(f\"Processing {len(queued_entries)} queued commits...\")\n    \n    processed = 0\n    for entry in queue:\n        if entry[\"status\"] == \"queued\":\n            try:\n                # Read file content\n                if not os.path.exists(entry[\"file\"]):\n                    print_error(f\"File not found: {entry['file']}. Skipping.\")\n                    entry[\"status\"] = \"failed\"\n                    entry[\"error\"] = \"File not found\"\n                    continue\n\n                with open(entry[\"file\"], \"rb\") as f:\n                    file_content = f.read()\n                \n                # Upload file\n                response = update_file(\n                    github_username, entry[\"repo\"], entry[\"file\"],\n                    file_content, github_token, entry[\"message\"]\n                )\n                \n                if response.status_code in [200, 201]:\n                    entry[\"status\"] = \"completed\"\n                    entry[\"processed_at\"] = datetime.now().isoformat()\n                    print_success(f\"Processed: {entry['message']}\")\n                    processed += 1\n                else:\n                    print_error(f\"Failed: {entry['message']} - {response.status_code}\")\n                    entry[\"error\"] = response.text\n            except Exception as e:\n                print_error(f\"Error processing: {entry['message']} - {e}\")\n                entry[\"error\"] = str(e)\n    \n    # Save updated queue\n    try:\n        with open(queue_file, 'w') as f:\n            json.dump(queue, f, indent=2)\n        print_success(f\"Processed {processed} commits from queue.\")\n    except Exception as e:\n        print_error(f\"Error saving updated queue: {e}\")"
      },
      "reasons": [
        "Cyclomatic complexity is 21 (threshold: 15). Too many decision paths.",
        "Makes 13 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 34,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within process_offline_queue and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split process_offline_queue into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If process_offline_queue has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: process_offline_queue, print_info, exists, open, load"
      ]
    },
    {
      "function": {
        "id": "a4e88c00c9d1",
        "name": "check_is_sensitive",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "startLine": 88,
        "endLine": 118,
        "lineCount": 31,
        "parameters": [
          "file_path"
        ],
        "calls": [
          "check_is_sensitive",
          "basename",
          "exists",
          "open",
          "strip",
          "startswith",
          "fnmatch",
          "Analysis",
          "isfile",
          "getsize",
          "read",
          "splitlines",
          "split",
          "calculate_entropy"
        ],
        "calledBy": [
          "8037213f9b0d",
          "b9152e2e05f3",
          "44098917418d",
          "46b90a5decb7",
          "5ac2e130bdf5",
          "e490fdc33eb5"
        ],
        "complexity": 17,
        "isExported": false,
        "isAsync": false,
        "docstring": "Checks if a file path matches any sensitive patterns or has high entropy contents.",
        "body": "\ndef check_is_sensitive(file_path):\n    \"\"\"Checks if a file path matches any sensitive patterns or has high entropy contents.\"\"\"\n    name = os.path.basename(file_path)\n    \n    # 1. Filename Pattern Check\n    gitignore_patterns = []\n    if os.path.exists(\".gitignore\"):\n        with open(\".gitignore\", \"r\") as f:\n            gitignore_patterns = [line.strip() for line in f if line.strip() and not line.startswith(\"#\")]\n\n    all_patterns = SENSITIVE_PATTERNS + gitignore_patterns\n    for pattern in all_patterns:\n        if fnmatch.fnmatch(name, pattern) or fnmatch.fnmatch(file_path, pattern):\n            return True\n\n    # 2. Sophisticated Content Analysis (High Entropy Detection)\n    if os.path.isfile(file_path) and os.path.getsize(file_path) < 1024 * 500:\n        try:\n            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                content = f.read()\n                for line in content.splitlines():\n                    words = line.split()\n                    for word in words:\n                        if len(word) > 20 and calculate_entropy(word) > 4.5:\n                            return True\n        except Exception:\n            pass\n\n    return False\n"
      },
      "reasons": [
        "Cyclomatic complexity is 17 (threshold: 15). Too many decision paths.",
        "High logic density (54.8% complexity per line). Code may be too terse.",
        "Makes 14 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 24,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within check_is_sensitive and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split check_is_sensitive into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If check_is_sensitive has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: check_is_sensitive, basename, exists, open, strip"
      ]
    },
    {
      "function": {
        "id": "c5fcd19ff943",
        "name": "manage_branches",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/branch.py",
        "startLine": 4,
        "endLine": 57,
        "lineCount": 54,
        "parameters": [
          "args"
        ],
        "calls": [
          "manage_branches",
          "print_header",
          "List",
          "prompt",
          "Text",
          "print_info",
          "run",
          "print_error",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 18,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle branch management operations with styled output.",
        "body": "\ndef manage_branches(args):\n    \"\"\"Handle branch management operations with styled output.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    branch_name = args.branch_name if hasattr(args, 'branch_name') and args.branch_name else None\n\n    if not action:\n        print_header(\"Branch Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What branch operation would you like to perform?\",\n                choices=[\"list\", \"create\", \"delete\", \"switch\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if action in [\"create\", \"delete\", \"switch\"]:\n            branch_questions = [\n                inquirer.Text(\"branch_name\", message=f\"Enter the name of the branch to {action}\")\n            ]\n            branch_answers = inquirer.prompt(branch_questions)\n            branch_name = branch_answers[\"branch_name\"]\n\n    try:\n        if action == \"list\":\n            print_info(\"Listing all local branches:\")\n            subprocess.run([\"git\", \"branch\"], check=True)\n        elif action == \"create\":\n            if not branch_name:\n                print_error(\"Branch name is required.\")\n                return\n            print_info(f\"Creating new branch: {branch_name}\")\n            subprocess.run([\"git\", \"branch\", branch_name], check=True)\n            print_success(f\"Branch '{branch_name}' created.\")\n        elif action == \"delete\":\n            if not branch_name:\n                print_error(\"Branch name is required.\")\n                return\n            print_info(f\"Deleting branch: {branch_name}\")\n            subprocess.run([\"git\", \"branch\", \"-d\", branch_name], check=True)\n            print_success(f\"Branch '{branch_name}' deleted.\")\n        elif action == \"switch\":\n            if not branch_name:\n                print_error(\"Branch name is required.\")\n                return\n            print_info(f\"Switching to branch: {branch_name}\")\n            subprocess.run([\"git\", \"checkout\", branch_name], check=True)\n            print_success(f\"Switched to branch '{branch_name}'.\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
      },
      "reasons": [
        "Cyclomatic complexity is 18 (threshold: 15). Too many decision paths.",
        "High logic density (33.3% complexity per line). Code may be too terse."
      ],
      "score": 20,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within manage_branches and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If manage_branches has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: manage_branches, print_header, List, prompt, Text"
      ]
    },
    {
      "function": {
        "id": "c655144f401e",
        "name": "manage_stashes",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/stash.py",
        "startLine": 4,
        "endLine": 55,
        "lineCount": 52,
        "parameters": [
          "args"
        ],
        "calls": [
          "manage_stashes",
          "print_header",
          "List",
          "prompt",
          "Text",
          "append",
          "print_info",
          "run",
          "print_success",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 19,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle stash management operations with styled output.",
        "body": "\ndef manage_stashes(args):\n    \"\"\"Handle stash management operations with styled output.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    message = args.message if hasattr(args, 'message') and args.message else None\n\n    if not action:\n        print_header(\"Stash Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What stash operation would you like to perform?\",\n                choices=[\"save\", \"list\", \"apply\", \"pop\", \"drop\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if action == \"save\":\n            stash_questions = [\n                inquirer.Text(\"message\", message=\"Enter an optional message for the stash\")\n            ]\n            stash_answers = inquirer.prompt(stash_questions)\n            message = stash_answers[\"message\"]\n\n    try:\n        if action == \"save\":\n            command = [\"git\", \"stash\", \"save\"]\n            if message:\n                command.append(message)\n            print_info(\"Saving current changes to a new stash.\")\n            subprocess.run(command, check=True)\n            print_success(\"Changes stashed.\")\n        elif action == \"list\":\n            print_info(\"Listing all stashes:\")\n            subprocess.run([\"git\", \"stash\", \"list\"], check=True)\n        elif action == \"apply\":\n            print_info(\"Applying the latest stash.\")\n            subprocess.run([\"git\", \"stash\", \"apply\"], check=True)\n            print_success(\"Stash applied.\")\n        elif action == \"pop\":\n            print_info(\"Applying the latest stash and dropping it from the list.\")\n            subprocess.run([\"git\", \"stash\", \"pop\"], check=True)\n            print_success(\"Stash popped.\")\n        elif action == \"drop\":\n            print_info(\"Dropping the latest stash.\")\n            subprocess.run([\"git\", \"stash\", \"drop\"], check=True)\n            print_success(\"Stash dropped.\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
      },
      "reasons": [
        "Cyclomatic complexity is 19 (threshold: 15). Too many decision paths.",
        "High logic density (36.5% complexity per line). Code may be too terse."
      ],
      "score": 20,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within manage_stashes and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If manage_stashes has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: manage_stashes, print_header, List, prompt, Text"
      ]
    },
    {
      "function": {
        "id": "893f9c1b4076",
        "name": "extract_python_docs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "startLine": 9,
        "endLine": 62,
        "lineCount": 54,
        "parameters": [
          "content",
          "filename"
        ],
        "calls": [
          "extract_python_docs",
          "parse",
          "get_docstring",
          "append",
          "join",
          "print_warning"
        ],
        "calledBy": [
          "cdf0160ec029",
          "c50e2b3c1ae7",
          "c2cd9c47dd19"
        ],
        "complexity": 18,
        "isExported": false,
        "isAsync": false,
        "docstring": "Extract documentation from Python code using AST.",
        "body": "\ndef extract_python_docs(content, filename):\n    \"\"\"Extract documentation from Python code using AST.\"\"\"\n    docs = {\n        'module_docstring': '',\n        'functions': [],\n        'classes': [],\n        'constants': []\n    }\n    \n    try:\n        tree = ast.parse(content)\n        \n        # Module docstring\n        docs['module_docstring'] = ast.get_docstring(tree) or ''\n        \n        for node in tree.body:\n            if isinstance(node, ast.FunctionDef):\n                func_doc = ast.get_docstring(node) or ''\n                args = [arg.arg for arg in node.args.args]\n                docs['functions'].append({\n                    'name': node.name,\n                    'params': ', '.join(args),\n                    'docstring': func_doc\n                })\n            elif isinstance(node, ast.ClassDef):\n                class_doc = ast.get_docstring(node) or ''\n                bases = [base.id for base in node.bases if isinstance(base, ast.Name)]\n                class_info = {\n                    'name': node.name,\n                    'parent': ', '.join(bases) if bases else 'object',\n                    'docstring': class_doc,\n                    'methods': []\n                }\n                \n                for item in node.body:\n                    if isinstance(item, ast.FunctionDef):\n                        method_doc = ast.get_docstring(item) or ''\n                        method_args = [arg.arg for arg in item.args.args]\n                        class_info['methods'].append({\n                            'name': item.name,\n                            'params': ', '.join(method_args),\n                            'docstring': method_doc\n                        })\n                \n                docs['classes'].append(class_info)\n                \n    except SyntaxError:\n        print_warning(f\"Could not parse {filename} (SyntaxError). Skipping.\")\n    except Exception as e:\n        print_warning(f\"Error parsing {filename}: {e}\")\n    \n    return docs\n"
      },
      "reasons": [
        "Cyclomatic complexity is 18 (threshold: 15). Too many decision paths.",
        "High logic density (33.3% complexity per line). Code may be too terse."
      ],
      "score": 20,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within extract_python_docs and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If extract_python_docs has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: extract_python_docs, parse, get_docstring, append, join"
      ]
    },
    {
      "function": {
        "id": "1eb3727820d9",
        "name": "get_project_directory_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 14,
        "endLine": 48,
        "lineCount": 35,
        "parameters": [
          "config",
          "args"
        ],
        "calls": [
          "get_project_directory_input",
          "input",
          "repository",
          "lower"
        ],
        "calledBy": [
          "44f568d20b70"
        ],
        "complexity": 17,
        "isExported": false,
        "isAsync": false,
        "docstring": "Gets user input for the project upload details.",
        "body": "\ndef get_project_directory_input(config, args=None):\n    \"\"\"Gets user input for the project upload details.\"\"\"\n    if args and args.path:\n        project_path = args.path\n    else:\n        project_path = input(\"Enter the full path to your project directory: \")\n    \n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter the desired name for your GitHub repository: \")\n    \n    if args and args.description is not None:\n        repo_description = args.description\n    else:\n        default_desc = config[\"github\"][\"default_description\"]\n        repo_description = input(f\"Enter a description for your repository (default: {default_desc}): \")\n        if not repo_description:\n            repo_description = default_desc\n    \n    if args and args.private is not None:\n        is_private = args.private\n    else:\n        default_private = config[\"github\"][\"default_private\"]\n        is_private_input = input(f\"Make the repository private? (y/n, default: {'y' if default_private else 'n'}): \").lower()\n        if is_private_input in ['y', 'yes']:\n            is_private = True\n        elif is_private_input in ['n', 'no']:\n            is_private = False\n        else:\n            is_private = default_private\n\n    return project_path, repo_name, repo_description, is_private\n"
      },
      "reasons": [
        "Cyclomatic complexity is 17 (threshold: 15). Too many decision paths.",
        "High logic density (48.6% complexity per line). Code may be too terse."
      ],
      "score": 20,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within get_project_directory_input and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If get_project_directory_input has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting."
      ]
    },
    {
      "function": {
        "id": "8957cebef9b3",
        "name": "run_advanced_security_scan",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "startLine": 54,
        "endLine": 88,
        "lineCount": 35,
        "parameters": [
          "username",
          "repo_name",
          "token"
        ],
        "calls": [
          "run_advanced_security_scan",
          "print_info",
          "get_dependabot_alerts",
          "json",
          "print_error",
          "print_success",
          "get_secret_scanning_alerts",
          "print_warning"
        ],
        "calledBy": [
          "2fbf4b070b23"
        ],
        "complexity": 16,
        "isExported": false,
        "isAsync": false,
        "docstring": "Deep vulnerability scanning using GitHub's security APIs.",
        "body": "\ndef run_advanced_security_scan(username, repo_name, token):\n    \"\"\"Deep vulnerability scanning using GitHub's security APIs.\"\"\"\n    print_info(f\"Fetching GitHub Security Alerts for {repo_name}...\")\n    \n    try:\n        # Dependabot\n        dep_resp = get_dependabot_alerts(username, repo_name, token)\n        if dep_resp.status_code == 200:\n            alerts = dep_resp.json()\n            open_alerts = [a for a in alerts if a['state'] == 'open']\n            if open_alerts:\n                print_error(f\"Found {len(open_alerts)} OPEN Dependabot vulnerabilities!\")\n                for a in open_alerts[:3]:\n                    print(f\" - {a['security_advisory']['summary']} ({a['security_advisory']['severity']})\")\n            else:\n                print_success(\"No open Dependabot alerts found.\")\n        \n        # Secret Scanning\n        sec_resp = get_secret_scanning_alerts(username, repo_name, token)\n        if sec_resp.status_code == 200:\n            secrets = sec_resp.json()\n            open_secrets = [s for s in secrets if s['state'] == 'open']\n            if open_secrets:\n                print_error(f\"ALERT: {len(open_secrets)} LEAKED SECRETS detected in repo history!\")\n                for s in open_secrets:\n                    print(f\" - Type: {s['secret_type']} at {s['html_url']}\")\n            else:\n                print_success(\"No leaked secrets detected.\")\n        elif sec_resp.status_code == 404:\n            print_info(\"Secret scanning is not enabled or not supported for this repo.\")\n\n    except Exception as e:\n        print_warning(f\"Advanced security scan failed: {e}\")\n"
      },
      "reasons": [
        "Cyclomatic complexity is 16 (threshold: 15). Too many decision paths.",
        "High logic density (45.7% complexity per line). Code may be too terse."
      ],
      "score": 20,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within run_advanced_security_scan and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If run_advanced_security_scan has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: run_advanced_security_scan, print_info, get_dependabot_alerts, json, print_error"
      ]
    },
    {
      "function": {
        "id": "9ec31c3178f8",
        "name": "get_fork_intelligence",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
        "startLine": 6,
        "endLine": 61,
        "lineCount": 56,
        "parameters": [
          "owner",
          "repo",
          "token"
        ],
        "calls": [
          "get_fork_intelligence",
          "print_header",
          "print_info",
          "get_repo_forks",
          "print_error",
          "json",
          "github_request",
          "get",
          "print_success",
          "print_warning",
          "forks"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 16,
        "isExported": false,
        "isAsync": false,
        "docstring": "Deep scan of the Forks Network to find hidden community improvements.",
        "body": "\ndef get_fork_intelligence(owner, repo, token):\n    \"\"\"Deep scan of the Forks Network to find hidden community improvements.\"\"\"\n    print_header(\"Network & Fork Intelligence\")\n    print_info(f\"Scanning community forks for {owner}/{repo}...\")\n    \n    try:\n        forks_resp = get_repo_forks(owner, repo, token)\n        if forks_resp.status_code != 200:\n            print_error(\"Failed to fetch forks list.\")\n            return\n            \n        forks = forks_resp.json()\n        if not forks:\n            print_info(\"No forks found for this repository.\")\n            return\n            \n        print_info(f\"Analyzing {len(forks)} forks for unique activity...\")\n        \n        found_unique = False\n        for fork in forks:\n            f_owner = fork['owner']['login']\n            f_name = fork['name']\n            f_default_branch = fork['default_branch']\n            \n            print(f\"  üîç Checking @{f_owner}/{f_name} [{f_default_branch}]...\")\n            \n            # Compare the fork's default branch against the upstream's default branch\n            compare_url = f\"https://api.github.com/repos/{owner}/{repo}/compare/{owner}:{f_default_branch}...{f_owner}:{f_default_branch}\"\n            compare_resp = github_request(\"GET\", compare_url, token)\n            \n            if compare_resp.status_code == 200:\n                data = compare_resp.json()\n                ahead = data.get('ahead_by', 0)\n                behind = data.get('behind_by', 0)\n                \n                status = \"Synced\"\n                if ahead > 0 and behind > 0: status = \"Diverged\"\n                elif ahead > 0: status = \"Ahead\"\n                elif behind > 0: status = \"Behind\"\n                \n                print(f\"     ‚îî‚îÄ Status: {status} | Ahead: {ahead} | Behind: {behind}\")\n                \n                if ahead > 0:\n                    found_unique = True\n                    print_success(f\"     üåü Discovery: Unique code found in @{f_owner}!\")\n                    print(f\"        View Diff: {data.get('html_url')}\")\n            else:\n                print_warning(f\"     ‚ö†Ô∏è  Could not compare: {compare_resp.status_code}\")\n        \n        if not found_unique:\n            print_info(\"No unique community work detected in forks (all forks are in-sync or behind).\")\n            \n    except Exception as e:\n        print_error(f\"Fork intelligence scan failed: {e}\")\n"
      },
      "reasons": [
        "Cyclomatic complexity is 16 (threshold: 15). Too many decision paths.",
        "Makes 11 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 19,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within get_fork_intelligence and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split get_fork_intelligence into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If get_fork_intelligence has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: get_fork_intelligence, print_header, print_info, get_repo_forks, print_error"
      ]
    },
    {
      "function": {
        "id": "8aecc87cfbd7",
        "name": "upload_batch_files",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 318,
        "endLine": 381,
        "lineCount": 64,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "upload_batch_files",
          "print_info",
          "get_batch_files_input",
          "audit_files_and_prompt",
          "print_warning",
          "tqdm",
          "join",
          "basename",
          "replace",
          "open",
          "read",
          "get_file_info",
          "json",
          "update_file",
          "print_error",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 17,
        "isExported": false,
        "isAsync": false,
        "docstring": "Upload multiple files in batch with styled output.",
        "body": "\ndef upload_batch_files(github_username, github_token, config, args=None):\n    \"\"\"Upload multiple files in batch with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        files, repo_name, repo_base_path, commit_message = get_batch_files_input(config, args)\n        print_info(f\"Would upload {len(files)} files to {repo_name} in batch.\")\n        return\n\n    files, repo_name, repo_base_path, commit_message = get_batch_files_input(config, args)\n    \n    if not files:\n        return\n\n    # Security check for batch files\n    files = audit_files_and_prompt(files)\n    if not files:\n        print_warning(\"No files to upload after security check.\")\n        return\n    \n    print_info(f\"\\nUploading {len(files)} files to {repo_name}...\")\n    \n    file_iterator = tqdm(files, desc=\"Uploading files\") if TQDM_AVAILABLE else files\n    \n    success_count = 0\n    fail_count = 0\n    \n    for local_file in file_iterator:\n        try:\n            if repo_base_path:\n                repo_file_path = os.path.join(repo_base_path, os.path.basename(local_file)).replace(\"\\\\\", \"/\")\n            else:\n                repo_file_path = os.path.basename(local_file)\n            \n            # Use upload_single_file logic but adapted for batch\n            # We skip some input gathering and validation already done\n            \n            with open(local_file, \"rb\") as f:\n                content = f.read()\n            \n            sha = None\n            f_info = get_file_info(github_username, repo_name, repo_file_path, github_token)\n            if f_info.status_code == 200:\n                sha = f_info.json()['sha']\n            \n            response = update_file(github_username, repo_name, repo_file_path, content, github_token, commit_message, sha)\n            \n            if response.status_code in [200, 201]:\n                success_count += 1\n            else:\n                print_error(f\"Failed to upload {local_file}: {response.status_code}\")\n                fail_count += 1\n                if not config[\"batch\"][\"continue_on_error\"]:\n                    print_warning(\"Stopping batch upload due to error.\")\n                    break\n                    \n        except Exception as e:\n            print_error(f\"Error uploading {local_file}: {e}\")\n            fail_count += 1\n            if not config[\"batch\"][\"continue_on_error\"]:\n                break\n    \n    print_success(f\"\\nBatch upload complete: {success_count} succeeded, {fail_count} failed.\")\n"
      },
      "reasons": [
        "Cyclomatic complexity is 17 (threshold: 15). Too many decision paths.",
        "Makes 16 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 19,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within upload_batch_files and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split upload_batch_files into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If upload_batch_files has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: upload_batch_files, print_info, get_batch_files_input, audit_files_and_prompt, print_warning"
      ]
    },
    {
      "function": {
        "id": "46b90a5decb7",
        "name": "queue_offline_commit",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
        "startLine": 9,
        "endLine": 71,
        "lineCount": 63,
        "parameters": [
          "config",
          "args"
        ],
        "calls": [
          "queue_offline_commit",
          "print_info",
          "print_header",
          "input",
          "check_is_sensitive",
          "print_warning",
          "lower",
          "now",
          "isoformat",
          "exists",
          "open",
          "load",
          "append",
          "dump",
          "print_success",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 18,
        "isExported": false,
        "isAsync": false,
        "docstring": "Queue a commit for when online with styled output.",
        "body": "\ndef queue_offline_commit(config, args=None):\n    \"\"\"Queue a commit for when online with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would queue a commit for the next online session.\")\n        return\n\n    print_header(\"Offline Commit Queue\")\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    if args and args.message:\n        commit_message = args.message\n    else:\n        commit_message = input(\"Enter commit message: \")\n    \n    if args and args.file:\n        file_path = args.file\n    else:\n        file_path = input(\"Enter file to commit: \")\n    \n    # Security check\n    if check_is_sensitive(file_path):\n        print_warning(f\"'{file_path}' appears to be a sensitive file.\")\n        confirm = input(\"Are you sure you want to queue this file for upload? (y/n): \").lower()\n        if confirm != 'y':\n            print_info(\"Queuing cancelled.\")\n            return\n    \n    # Create queue entry\n    queue_entry = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"repo\": repo_name,\n        \"message\": commit_message,\n        \"file\": file_path,\n        \"status\": \"queued\"\n    }\n    \n    # Load existing queue\n    queue_file = config[\"scheduling\"][\"offline_queue_file\"]\n    queue = []\n    if os.path.exists(queue_file):\n        try:\n            with open(queue_file, 'r') as f:\n                queue = json.load(f)\n        except Exception as e:\n            print_warning(f\"Could not load queue file: {e}\")\n    \n    # Add new entry\n    queue.append(queue_entry)\n    \n    # Save queue\n    try:\n        with open(queue_file, 'w') as f:\n            json.dump(queue, f, indent=2)\n        print_success(\"Commit queued for next online session.\")\n        print_info(f\"Queue file: {queue_file}\")\n    except Exception as e:\n        print_error(f\"Error saving queue: {e}\")\n"
      },
      "reasons": [
        "Cyclomatic complexity is 18 (threshold: 15). Too many decision paths.",
        "Makes 16 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 19,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within queue_offline_commit and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split queue_offline_commit into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If queue_offline_commit has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: queue_offline_commit, print_info, print_header, input, check_is_sensitive"
      ]
    },
    {
      "function": {
        "id": "04ec89b8dcdb",
        "name": "github_request",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 11,
        "endLine": 36,
        "lineCount": 26,
        "parameters": [
          "method",
          "url",
          "token",
          "**kwargs"
        ],
        "calls": [
          "github_request",
          "get_github_headers",
          "update",
          "pop",
          "request",
          "get",
          "time",
          "max",
          "sleep"
        ],
        "calledBy": [
          "cae9e9daf651",
          "22799e5e935b",
          "729bde7aebfc",
          "59cce6cbf9ef",
          "f288fcba775c",
          "a05438a21c94",
          "ed46502e03e4",
          "9f5b6b9d7027",
          "304c2f42440f",
          "0be2041124b1",
          "2940e06f8c6f",
          "e598644894fc",
          "1a4cd86312dd",
          "8af97186e8e2",
          "f21215245cf7",
          "cc1f5fc47297",
          "851ca2aa04d6",
          "7aba7221be60",
          "2cc012b3cc34",
          "c05b776fcc1c",
          "4b3f28ce9e27",
          "4350d6620c0f",
          "6e8a9abe9285",
          "3007556417ad",
          "bfb968263df8",
          "f16e5c44fb5b",
          "596d2eb4e17c",
          "8037213f9b0d",
          "72913908c45b",
          "9ec31c3178f8",
          "f5e6adf207a0",
          "1d0f56ea40c1",
          "be40efbe3e80"
        ],
        "complexity": 8,
        "isExported": false,
        "isAsync": false,
        "docstring": "Centralized GitHub API request handler with rate-limiting support.",
        "body": "\ndef github_request(method, url, token, **kwargs):\n    \"\"\"Centralized GitHub API request handler with rate-limiting support.\"\"\"\n    headers = get_github_headers(token)\n    if 'headers' in kwargs:\n        headers.update(kwargs.pop('headers'))\n    \n    while True:\n        try:\n            response = requests.request(method, url, headers=headers, **kwargs)\n            \n            # Handle rate limiting\n            if response.status_code == 403 and 'X-RateLimit-Remaining' in response.headers:\n                remaining = int(response.headers.get('X-RateLimit-Remaining', 1))\n                if remaining == 0:\n                    reset_time = int(response.headers.get('X-RateLimit-Reset', time.time() + 60))\n                    sleep_duration = max(reset_time - time.time() + 1, 1)\n                    print(f\"\\n[!] Rate limit reached. Sleeping for {sleep_duration:.0f}s until reset...\")\n                    time.sleep(sleep_duration)\n                    continue\n            \n            return response\n        except requests.exceptions.RequestException as e:\n            print(f\"Request failed: {e}\")\n            raise\n"
      },
      "reasons": [
        "Function is called from 33 places (threshold: 30). High coupling - changes here will ripple.",
        "High logic density (30.8% complexity per line). Code may be too terse."
      ],
      "score": 10,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within github_request and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If github_request has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: github_request, get_github_headers, update, pop, request"
      ]
    },
    {
      "function": {
        "id": "6b700cc8d9be",
        "name": "migrate_repository",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 472,
        "endLine": 506,
        "lineCount": 35,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "migrate_repository",
          "print_header",
          "input",
          "URL",
          "lower",
          "print_info",
          "create_or_get_github_repository",
          "mkdtemp",
          "clone",
          "run",
          "chdir",
          "GitHub",
          "print_success",
          "print_error",
          "rmtree",
          "dirname",
          "abspath"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 15,
        "isExported": false,
        "isAsync": false,
        "docstring": "Mirror a repository from any source to GitHub with full history.",
        "body": "\ndef migrate_repository(github_username, github_token, config, args=None):\n    \"\"\"Mirror a repository from any source to GitHub with full history.\"\"\"\n    print_header(\"The Great Migration Porter\")\n    \n    src_url = args.url if args and hasattr(args, 'url') and args.url else input(\"üîó Enter Source Repository URL (GitLab/Bitbucket/etc): \")\n    dest_name = args.repo if args and hasattr(args, 'repo') and args.repo else input(\"üì¶ Enter Destination GitHub Repository Name: \")\n    \n    is_private = args.private if args and hasattr(args, 'private') else input(\"üîí Make destination private? (y/n) [y]: \").lower() != 'n'\n\n    print_info(f\"Establishing destination on GitHub...\")\n    # Ensure dest exists\n    create_or_get_github_repository(dest_name, f\"Mirrored from {src_url}\", is_private, github_username, github_token)\n    \n    dest_url = f\"https://{github_username}:{github_token}@github.com/{github_username}/{dest_name}.git\"\n    \n    # Use a temporary directory for the mirror operation\n    temp_dir = tempfile.mkdtemp()\n    try:\n        print_info(\"Performing mirror clone (this may take time for large repos)...\")\n        subprocess.run([\"git\", \"clone\", \"--mirror\", src_url, temp_dir], check=True)\n        \n        os.chdir(temp_dir)\n        print_info(\"Pushing mirror to GitHub (preserving all branches/tags)...\")\n        subprocess.run([\"git\", \"push\", \"--mirror\", dest_url], check=True)\n        \n        print_success(f\"\\nMigration Successful! üöÄ\")\n        print_info(f\"View it at: https://github.com/{github_username}/{dest_name}\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Migration failed during git operation: {e}\")\n    finally:\n        # Cleanup\n        shutil.rmtree(temp_dir, ignore_errors=True)\n        os.chdir(os.path.dirname(os.path.abspath(__file__))) # Back to relative safety\n"
      },
      "reasons": [
        "High logic density (42.9% complexity per line). Code may be too terse.",
        "Makes 17 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 9,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within migrate_repository and extract them into smaller, focused functions.",
        "Apply Single Responsibility: Split migrate_repository into multiple functions, each handling one aspect.",
        "Replace Conditionals with Polymorphism: If migrate_repository has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: migrate_repository, print_header, input, URL, lower"
      ]
    },
    {
      "function": {
        "id": "c2cd9c47dd19",
        "name": "test_extract_python_docs_classes",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "startLine": 63,
        "endLine": 88,
        "lineCount": 26,
        "parameters": [],
        "calls": [
          "test_extract_python_docs_classes",
          "extract_python_docs",
          "next"
        ],
        "calledBy": [],
        "complexity": 10,
        "isExported": false,
        "isAsync": false,
        "body": "\ndef test_extract_python_docs_classes():\n    docs = extract_python_docs(SAMPLE_PYTHON_CODE, \"sample.py\")\n    \n    # Test MyClass\n    cls = next((c for c in docs['classes'] if c['name'] == 'MyClass'), None)\n    assert cls is not None\n    assert cls['parent'] == 'object'\n    assert \"A sample class to demonstrate AST parsing.\" in cls['docstring']\n    \n    # Test MyClass methods\n    init_method = next((m for m in cls['methods'] if m['name'] == '__init__'), None)\n    assert init_method is not None\n    assert init_method['params'] == 'self, name'\n    assert \"The constructor for MyClass.\" in init_method['docstring']\n\n    my_method = next((m for m in cls['methods'] if m['name'] == 'my_method'), None)\n    assert my_method is not None\n    assert my_method['params'] == 'self, value'\n    assert \"A sample method within MyClass.\" in my_method['docstring']\n\n    # Test AnotherClass\n    another_cls = next((c for c in docs['classes'] if c['name'] == 'AnotherClass'), None)\n    assert another_cls is not None\n    assert another_cls['parent'] == 'object' # Default parent\n    assert \"Another class with no explicit base.\" in another_cls['docstring']"
      },
      "reasons": [
        "High logic density (38.5% complexity per line). Code may be too terse."
      ],
      "score": 5,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within test_extract_python_docs_classes and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If test_extract_python_docs_classes has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting."
      ]
    },
    {
      "function": {
        "id": "09b2167e8bce",
        "name": "generate_documentation",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "startLine": 150,
        "endLine": 187,
        "lineCount": 38,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "generate_documentation",
          "print_info",
          "print_header",
          "input",
          "directory",
          "makedirs",
          "get_repo_contents",
          "print_error",
          "json",
          "search"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 14,
        "isExported": false,
        "isAsync": false,
        "docstring": "Generate documentation from code comments with styled output.",
        "body": "\ndef generate_documentation(github_username, github_token, config, args=None):\n    \"\"\"Generate documentation from code comments with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would generate documentation from code comments.\")\n        return\n\n    print_header(\"Documentation Generator\")\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    output_dir = \"docs\"\n    if args and args.output:\n        output_dir = args.output\n    else:\n        output_dir_input = input(f\"Enter output directory (default: {output_dir}): \")\n        output_dir = output_dir_input if output_dir_input else output_dir\n    \n    print_info(f\"Generating documentation for {repo_name}...\")\n    print_info(f\"Output directory: {output_dir}\")\n    \n    # Create output directory if it doesn't exist\n    os.makedirs(output_dir, exist_ok=True)\n    \n    # Get repository contents\n    try:\n        response = get_repo_contents(github_username, repo_name, github_token)\n        if response.status_code != 200:\n            print_error(f\"Error accessing repository: {response.status_code}\")\n            return\n        \n        contents = response.json()\n        doc_content = f\"# Documentation for {repo_name}\\n\\n\"\n        doc_content += '''<input type=\"text\" id=\"search-bar\" onkeyup=\"search()\" placeholder=\"Search for names..\">\n"
      },
      "reasons": [
        "High logic density (36.8% complexity per line). Code may be too terse."
      ],
      "score": 5,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within generate_documentation and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If generate_documentation has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: generate_documentation, print_info, print_header, input, directory"
      ]
    },
    {
      "function": {
        "id": "402517011038",
        "name": "push_to_github",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 88,
        "endLine": 112,
        "lineCount": 25,
        "parameters": [
          "repo_name",
          "github_username",
          "github_token"
        ],
        "calls": [
          "push_to_github",
          "run",
          "splitlines",
          "strip",
          "print_info",
          "print_success",
          "print_error",
          "exit"
        ],
        "calledBy": [
          "44f568d20b70"
        ],
        "complexity": 8,
        "isExported": false,
        "isAsync": false,
        "docstring": "Adds the remote and force pushes to the new repository.",
        "body": "\ndef push_to_github(repo_name, github_username, github_token):\n    \"\"\"Adds the remote and force pushes to the new repository.\"\"\"\n    remote_url = f\"https://{github_username}:{github_token}@github.com/{github_username}/{repo_name}.git\"\n    safe_remote_url = f\"https://github.com/{github_username}/{repo_name}.git\"\n    try:\n        result = subprocess.run([\"git\", \"remote\"], capture_output=True, text=True)\n        if \"origin\" in result.stdout.splitlines():\n            existing_url_result = subprocess.run([\"git\", \"remote\", \"get-url\", \"origin\"], capture_output=True, text=True, check=True)\n            if existing_url_result.stdout.strip() != remote_url and existing_url_result.stdout.strip() != safe_remote_url:\n                subprocess.run([\"git\", \"remote\", \"set-url\", \"origin\", remote_url], check=True)\n            else:\n                subprocess.run([\"git\", \"remote\", \"set-url\", \"origin\", remote_url], check=True)\n        else:\n            subprocess.run([\"git\", \"remote\", \"add\", \"origin\", remote_url], check=True)\n        branch_result = subprocess.run([\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"], capture_output=True, text=True, check=True)\n        if branch_result.stdout.strip() != \"main\":\n            subprocess.run([\"git\", \"branch\", \"-M\", \"main\"], check=True)\n        print_info(\"Pushing to GitHub with force...\")\n        subprocess.run([\"git\", \"push\", \"-u\", \"--force\", \"origin\", \"main\"], check=True)\n        print_success(\"Pushed to GitHub.\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"An error occurred while pushing to GitHub: {e}\")\n        sys.exit(1)\n"
      },
      "reasons": [
        "High logic density (32.0% complexity per line). Code may be too terse."
      ],
      "score": 5,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within push_to_github and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If push_to_github has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: push_to_github, run, splitlines, strip, print_info"
      ]
    },
    {
      "function": {
        "id": "985fa21cb145",
        "name": "get_multi_repo_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 381,
        "endLine": 408,
        "lineCount": 28,
        "parameters": [
          "config",
          "args"
        ],
        "calls": [
          "get_multi_repo_input",
          "strip",
          "split",
          "input",
          "message"
        ],
        "calledBy": [
          "44098917418d"
        ],
        "complexity": 13,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get multi-repository input.",
        "body": "\ndef get_multi_repo_input(config, args=None):\n    \"\"\"Get multi-repository input.\"\"\"\n    if args and args.multi_repo:\n        repo_names = [name.strip() for name in args.multi_repo.split(\",\")]\n    else:\n        repo_input = input(\"Enter repository names separated by commas: \")\n        repo_names = [name.strip() for name in repo_input.split(\",\")]\n    \n    if args and args.file:\n        file_path = args.file\n    else:\n        file_path = input(\"Enter local file to upload: \")\n    \n    if args and args.path:\n        repo_file_path = args.path\n    else:\n        repo_file_path = input(\"Enter repository file path: \")\n    \n    if args and args.message:\n        commit_message = args.message\n    else:\n        default_msg = config[\"defaults\"][\"commit_message\"]\n        msg_input = input(f\"Enter commit message (default: {default_msg}): \")\n        commit_message = msg_input if msg_input else default_msg\n    \n    return repo_names, file_path, repo_file_path, commit_message\n"
      },
      "reasons": [
        "High logic density (46.4% complexity per line). Code may be too terse."
      ],
      "score": 5,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within get_multi_repo_input and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If get_multi_repo_input has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting."
      ]
    },
    {
      "function": {
        "id": "09ae5dd659db",
        "name": "get_template_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
        "startLine": 77,
        "endLine": 116,
        "lineCount": 40,
        "parameters": [
          "config",
          "args"
        ],
        "calls": [
          "get_template_input",
          "keys",
          "input",
          "split",
          "strip",
          "get_github_username"
        ],
        "calledBy": [
          "3831ab37da60"
        ],
        "complexity": 15,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get template input from user or arguments.",
        "body": "\ndef get_template_input(config, args=None):\n    \"\"\"Get template input from user or arguments.\"\"\"\n    if args and args.template:\n        template_name = args.template\n    else:\n        print(\"\\n--- Available Templates ---\")\n        for template in DEFAULT_TEMPLATES.keys():\n            print(f\"- {template}\")\n        template_name = input(\"Enter template name: \")\n    \n    if template_name not in DEFAULT_TEMPLATES:\n        print(f\"Template '{template_name}' not found.\")\n        return None, None, None, None\n    \n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    # Get variables\n    variables = {}\n    if args and args.variables:\n        # Parse variables from command line\n        var_pairs = args.variables.split(\",\")\n        for pair in var_pairs:\n            if \"=\" in pair:\n                key, value = pair.split(\"=\", 1)\n                variables[key.strip()] = value.strip()\n    \n    # Default variables\n    if \"PROJECT_NAME\" not in variables:\n        variables[\"PROJECT_NAME\"] = repo_name\n    if \"DESCRIPTION\" not in variables:\n        variables[\"DESCRIPTION\"] = \"Project created with PyGitUp template\"\n    if \"AUTHOR\" not in variables:\n        variables[\"AUTHOR\"] = get_github_username(config)\n    \n    return template_name, repo_name, variables, DEFAULT_TEMPLATES[template_name]\n"
      },
      "reasons": [
        "High logic density (37.5% complexity per line). Code may be too terse."
      ],
      "score": 5,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within get_template_input and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If get_template_input has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: get_template_input, keys, input, split, strip"
      ]
    },
    {
      "function": {
        "id": "2fbf4b070b23",
        "name": "run_audit",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "startLine": 34,
        "endLine": 54,
        "lineCount": 21,
        "parameters": [
          "github_username",
          "repo_name",
          "github_token"
        ],
        "calls": [
          "run_audit",
          "print_header",
          "print_info",
          "run",
          "print_success",
          "print_warning",
          "run_advanced_security_scan"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 7,
        "isExported": false,
        "isAsync": false,
        "docstring": "Run a security audit on the project dependencies.",
        "body": "\ndef run_audit(github_username=None, repo_name=None, github_token=None):\n    \"\"\"Run a security audit on the project dependencies.\"\"\"\n    print_header(\"Security Audit\")\n    \n    # Local pip-audit\n    print_info(\"Running local pip-audit on current environment...\")\n    try:\n        result = subprocess.run([\"pip-audit\"], capture_output=True, text=True)\n        if result.returncode == 0:\n            print_success(\"No known local vulnerabilities found via pip-audit.\")\n        else:\n            print_warning(\"Local vulnerabilities detected:\")\n            print(result.stdout)\n    except FileNotFoundError:\n        print_warning(\"'pip-audit' not found. Skipping local scan.\")\n\n    # Remote GitHub Security scan if context provided\n    if github_username and repo_name and github_token:\n        run_advanced_security_scan(github_username, repo_name, github_token)\n"
      },
      "reasons": [
        "High logic density (33.3% complexity per line). Code may be too terse."
      ],
      "score": 5,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within run_audit and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If run_audit has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: run_audit, print_header, print_info, run, print_success"
      ]
    },
    {
      "function": {
        "id": "5ac2e130bdf5",
        "name": "audit_files_and_prompt",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "startLine": 118,
        "endLine": 136,
        "lineCount": 19,
        "parameters": [
          "files"
        ],
        "calls": [
          "audit_files_and_prompt",
          "check_is_sensitive",
          "print_warning",
          "input"
        ],
        "calledBy": [
          "8aecc87cfbd7"
        ],
        "complexity": 12,
        "isExported": false,
        "isAsync": false,
        "docstring": "Scans a list of files for sensitive content.",
        "body": "\ndef audit_files_and_prompt(files):\n    \"\"\"Scans a list of files for sensitive content.\"\"\"\n    sensitive_matches = [f for f in files if check_is_sensitive(f)]\n    if not sensitive_matches:\n        return files\n\n    print_warning(f\"SECURITY WARNING: {len(sensitive_matches)} sensitive or heavy files detected!\")\n    for f in sensitive_matches[:5]:\n        print(f\" - {f}\")\n    \n    choice = input(\"\\nHow to proceed? (1: Skip them [Default], 2: Upload anyway, 3: Cancel): \") or \"1\"\n    \n    if choice == \"1\":\n        return [f for f in files if f not in sensitive_matches]\n    elif choice == \"2\":\n        return files\n    return []\n"
      },
      "reasons": [
        "Function name contains \"and\" - suggests multiple responsibilities."
      ],
      "score": 5,
      "suggestedSplits": [
        "Split by Name: Consider splitting into \"audit_files\" and \"prompt\" functions."
      ]
    },
    {
      "function": {
        "id": "e490fdc33eb5",
        "name": "scan_directory_for_sensitive_files",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "startLine": 136,
        "endLine": 158,
        "lineCount": 23,
        "parameters": [
          "directory"
        ],
        "calls": [
          "scan_directory_for_sensitive_files",
          "walk",
          "join",
          "check_is_sensitive",
          "append",
          "print_warning",
          "input",
          "open",
          "write",
          "relpath"
        ],
        "calledBy": [
          "44f568d20b70"
        ],
        "complexity": 8,
        "isExported": false,
        "isAsync": false,
        "docstring": "Scans a directory for sensitive files before git add.",
        "body": "\ndef scan_directory_for_sensitive_files(directory):\n    \"\"\"Scans a directory for sensitive files before git add.\"\"\"\n    detected = []\n    for root, dirs, files in os.walk(directory):\n        for name in dirs + files:\n            full_path = os.path.join(root, name)\n            if check_is_sensitive(full_path):\n                detected.append(full_path)\n\n    if not detected:\n        return True\n\n    print_warning(f\"Sensitive files found: {len(detected)}\")\n    choice = input(\"\\nAction? (1: Add to .gitignore, 2: Ignore warning, 3: Cancel): \")\n    \n    if choice == \"1\":\n        with open(\".gitignore\", \"a\") as f:\n            f.write(\"\\n# Added by PyGitUp Interceptor\\n\")\n            for item in detected:\n                f.write(f\"{os.path.relpath(item, directory)}\\n\")\n        return True\n    return choice == \"2\""
      },
      "reasons": [
        "High logic density (34.8% complexity per line). Code may be too terse."
      ],
      "score": 5,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within scan_directory_for_sensitive_files and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If scan_directory_for_sensitive_files has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: scan_directory_for_sensitive_files, walk, join, check_is_sensitive, append"
      ]
    },
    {
      "function": {
        "id": "2c296aa52879",
        "name": "print_success",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "startLine": 11,
        "endLine": 15,
        "lineCount": 5,
        "parameters": [
          "message"
        ],
        "calls": [
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece",
          "c5fcd19ff943",
          "78e970b9d9ad",
          "f1f948b57bf3",
          "c655144f401e",
          "ebb909c21ccf",
          "cae9e9daf651",
          "8037213f9b0d",
          "72913908c45b",
          "dd4bb98c5440",
          "ea6606b7620d",
          "e638d8d1a537",
          "9863eda17987",
          "9ec31c3178f8",
          "1d0f56ea40c1",
          "65c5d1c696bf",
          "df849b43f31d",
          "4ac56e6829e2",
          "402517011038",
          "b9152e2e05f3",
          "8aecc87cfbd7",
          "44098917418d",
          "6b700cc8d9be",
          "1f4213d37548",
          "d51b6e299e0d",
          "f696ef68591b",
          "46b90a5decb7",
          "d4cc0e31330b",
          "2fbf4b070b23",
          "8957cebef9b3",
          "ad7661271cb1"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Prints a success message in green.",
        "body": "\ndef print_success(message):\n    \"\"\"Prints a success message in green.\"\"\"\n    console.print(f\"[bold green]‚úî {message}[/bold green]\")\n"
      },
      "reasons": [
        "Function is called from 31 places (threshold: 30). High coupling - changes here will ripple."
      ],
      "score": 5,
      "suggestedSplits": []
    },
    {
      "function": {
        "id": "bc37dc58134c",
        "name": "print_error",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "startLine": 15,
        "endLine": 19,
        "lineCount": 5,
        "parameters": [
          "message"
        ],
        "calls": [
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece",
          "c5fcd19ff943",
          "78e970b9d9ad",
          "f1f948b57bf3",
          "c655144f401e",
          "ebb909c21ccf",
          "cae9e9daf651",
          "8037213f9b0d",
          "72913908c45b",
          "dd4bb98c5440",
          "51e6ef2a0fbb",
          "ea6606b7620d",
          "e638d8d1a537",
          "9863eda17987",
          "9ec31c3178f8",
          "f5e6adf207a0",
          "1d0f56ea40c1",
          "09b2167e8bce",
          "65c5d1c696bf",
          "df849b43f31d",
          "4ac56e6829e2",
          "402517011038",
          "44f568d20b70",
          "8cdb7133190e",
          "b9152e2e05f3",
          "b065ed988f67",
          "8aecc87cfbd7",
          "44098917418d",
          "6b700cc8d9be",
          "1f4213d37548",
          "dcae852f2920",
          "7c55c44cf67b",
          "d51b6e299e0d",
          "f696ef68591b",
          "be40efbe3e80",
          "46b90a5decb7",
          "d4cc0e31330b",
          "8957cebef9b3",
          "ad7661271cb1"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Prints an error message in red.",
        "body": "\ndef print_error(message):\n    \"\"\"Prints an error message in red.\"\"\"\n    console.print(f\"[bold red]‚úñ {message}[/bold red]\")\n"
      },
      "reasons": [
        "Function is called from 39 places (threshold: 30). High coupling - changes here will ripple."
      ],
      "score": 5,
      "suggestedSplits": []
    },
    {
      "function": {
        "id": "f3de7251ed0a",
        "name": "print_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "startLine": 23,
        "endLine": 27,
        "lineCount": 5,
        "parameters": [
          "message"
        ],
        "calls": [
          "print_info"
        ],
        "calledBy": [
          "cad67e0dcece",
          "c5fcd19ff943",
          "78e970b9d9ad",
          "f1f948b57bf3",
          "c655144f401e",
          "ebb909c21ccf",
          "cae9e9daf651",
          "8037213f9b0d",
          "dd4bb98c5440",
          "51e6ef2a0fbb",
          "ea6606b7620d",
          "e638d8d1a537",
          "9863eda17987",
          "9ec31c3178f8",
          "1d0f56ea40c1",
          "09b2167e8bce",
          "65c5d1c696bf",
          "df849b43f31d",
          "4ac56e6829e2",
          "402517011038",
          "44f568d20b70",
          "8cdb7133190e",
          "b9152e2e05f3",
          "8aecc87cfbd7",
          "44098917418d",
          "6b700cc8d9be",
          "1f4213d37548",
          "d51b6e299e0d",
          "be40efbe3e80",
          "46b90a5decb7",
          "d4cc0e31330b",
          "2fbf4b070b23",
          "8957cebef9b3",
          "ad7661271cb1"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Prints an info message in blue.",
        "body": "\ndef print_info(message):\n    \"\"\"Prints an info message in blue.\"\"\"\n    console.print(f\"[bold blue]‚Ñπ {message}[/bold blue]\")\n"
      },
      "reasons": [
        "Function is called from 34 places (threshold: 30). High coupling - changes here will ripple."
      ],
      "score": 5,
      "suggestedSplits": []
    },
    {
      "function": {
        "id": "dad53122bce0",
        "name": "check_for_updates",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
        "startLine": 23,
        "endLine": 45,
        "lineCount": 23,
        "parameters": [],
        "calls": [
          "check_for_updates",
          "get",
          "splitlines",
          "split",
          "strip",
          "is_newer",
          "print_warning",
          "input",
          "lower",
          "perform_update"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 9,
        "isExported": false,
        "isAsync": false,
        "docstring": "Checks GitHub for a newer version of PyGitUp by reading the raw source.",
        "body": "\ndef check_for_updates():\n    \"\"\"Checks GitHub for a newer version of PyGitUp by reading the raw source.\"\"\"\n    try:\n        # We check the raw __init__.py because it's the most \"real-time\" source\n        response = requests.get(GITHUB_RAW_VERSION_URL, timeout=3)\n        if response.status_code == 200:\n            content = response.text\n            latest_version = \"0.0.0\"\n            for line in content.splitlines():\n                if \"__version__\" in line:\n                    latest_version = line.split(\"=\")[1].strip().strip('\"').strip(\"'\")\n                    break\n            \n            if is_newer(latest_version, __version__):\n                print_warning(f\"üöÄ A new update is available: v{latest_version} (Current: v{__version__})\")\n                confirm = input(\"Would you like to auto-update now? (y/n): \").lower()\n                if confirm == 'y':\n                    perform_update()\n    except Exception:\n        # Fail silently to not disturb the user's workflow if offline\n        pass\n"
      },
      "reasons": [
        "High logic density (39.1% complexity per line). Code may be too terse."
      ],
      "score": 5,
      "suggestedSplits": [
        "Extract Method: Identify logical blocks within check_for_updates and extract them into smaller, focused functions.",
        "Replace Conditionals with Polymorphism: If check_for_updates has many branches based on type, consider using a strategy pattern or polymorphism.",
        "Extract Guard Clauses: Move validation and early-return logic to the top of the function to reduce nesting.",
        "Potential extraction candidates: check_for_updates, get, splitlines, split, strip"
      ]
    },
    {
      "function": {
        "id": "ea6606b7620d",
        "name": "create_release_tag",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
        "startLine": 96,
        "endLine": 131,
        "lineCount": 36,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "create_release_tag",
          "print_info",
          "get_release_input",
          "print_header",
          "isdir",
          "run",
          "print_success",
          "print_warning",
          "create_release",
          "json",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 9,
        "isExported": false,
        "isAsync": false,
        "docstring": "Create a new GitHub release with styled output.",
        "body": "\ndef create_release_tag(github_username, github_token, config, args=None):\n    \"\"\"Create a new GitHub release with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        repo_name, version, name, changelog = get_release_input(config, args, github_username, github_token)\n        print_info(f\"Would create release {version} for {repo_name}.\")\n        return\n\n    print_header(\"Create GitHub Release\")\n    repo_name, version, name, changelog = get_release_input(config, args, github_username, github_token)\n    \n    print_info(f\"Creating release {version} for {repo_name}...\")\n    \n    # 1. Automated Local Tagging\n    try:\n        # Check if we are in the target repo\n        if os.path.isdir(\".git\"):\n            print_info(\"Local Git repository detected. Synchronizing tags...\")\n            # Create tag\n            subprocess.run([\"git\", \"tag\", \"-a\", version, \"-m\", name], capture_output=True)\n            # Push tag\n            subprocess.run([\"git\", \"push\", \"origin\", version], capture_output=True)\n            print_success(f\"Local tag '{version}' pushed to origin.\")\n    except Exception as e:\n        print_warning(f\"Local tagging skipped/failed: {e}\")\n\n    # 2. GitHub API Release\n    response = create_release(github_username, repo_name, github_token, version, name, changelog)\n    \n    if response.status_code == 201:\n        release_data = response.json()\n        print_success(f\"Release created successfully!\")\n        print_info(f\"View release at: {release_data['html_url']}\")\n    else:\n        print_error(f\"Error creating release: {response.status_code} - {response.text}\")"
      },
      "reasons": [
        "Makes 11 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 4,
      "suggestedSplits": [
        "Apply Single Responsibility: Split create_release_tag into multiple functions, each handling one aspect.",
        "Potential extraction candidates: create_release_tag, print_info, get_release_input, print_header, isdir"
      ]
    },
    {
      "function": {
        "id": "6dcebe2d9f75",
        "name": "get_repo_health_metrics",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
        "startLine": 75,
        "endLine": 122,
        "lineCount": 48,
        "parameters": [
          "username",
          "repo_name",
          "token"
        ],
        "calls": [
          "get_repo_health_metrics",
          "get_commit_history",
          "json",
          "commits",
          "fromisoformat",
          "replace",
          "total_seconds",
          "round",
          "sum",
          "get_issues",
          "get_contributors"
        ],
        "calledBy": [
          "f5e6adf207a0"
        ],
        "complexity": 13,
        "isExported": false,
        "isAsync": false,
        "docstring": "Calculate repository health metrics.",
        "body": "\ndef get_repo_health_metrics(username, repo_name, token):\n    \"\"\"Calculate repository health metrics.\"\"\"\n    metrics = {}\n\n    # Get recent commits\n    try:\n        commits_response = get_commit_history(username, repo_name, token)\n        if commits_response.status_code == 200:\n            commits = commits_response.json()\n            metrics['recent_commits'] = len(commits)\n            if commits:\n                # Calculate median time between commits (Sophisticated Velocity Math)\n                from datetime import datetime\n                dates = [datetime.fromisoformat(c['commit']['author']['date'].replace('Z', '+00:00')) \n                         for c in commits[:20]] # Last 20 commits\n                if len(dates) > 1:\n                    time_diffs = sorted([(dates[i] - dates[i+1]).total_seconds() / 86400 for i in range(len(dates)-1)])\n                    # Use median to avoid outlier skew\n                    median_days = time_diffs[len(time_diffs)//2]\n                    metrics['development_velocity_days'] = round(median_days, 2)\n                    \n                    # Burst detection: comparing last 3 to last 20\n                    recent_burst = sum(time_diffs[:3]) / 3\n                    metrics['activity_status'] = \"Active/Bursting\" if recent_burst < median_days else \"Stable\"\n    except Exception:\n        pass\n\n    # Get closed issues\n    try:\n        issues_response = get_issues(username, repo_name, token, state='closed')\n        if issues_response.status_code == 200:\n            closed_issues = issues_response.json()\n            metrics['closed_issues'] = len(closed_issues)\n    except Exception:\n        pass\n\n    # Get contributors\n    try:\n        contrib_response = get_contributors(username, repo_name, token)\n        if contrib_response.status_code == 200:\n            contributors = contrib_response.json()\n            metrics['contributors_count'] = len(contributors)\n    except Exception:\n        pass\n\n    return metrics\n"
      },
      "reasons": [
        "Makes 11 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 4,
      "suggestedSplits": [
        "Apply Single Responsibility: Split get_repo_health_metrics into multiple functions, each handling one aspect.",
        "Potential extraction candidates: get_repo_health_metrics, get_commit_history, json, commits, fromisoformat"
      ]
    },
    {
      "function": {
        "id": "44f568d20b70",
        "name": "upload_project_directory",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 112,
        "endLine": 143,
        "lineCount": 32,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "upload_project_directory",
          "print_info",
          "print_header",
          "get_project_directory_input",
          "validate_file_path",
          "print_error",
          "validate_repo_name",
          "scan_directory_for_sensitive_files",
          "print_warning",
          "initialize_git_repository",
          "create_or_get_github_repository",
          "push_to_github"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 7,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handles the entire process of uploading/updating a project directory.",
        "body": "\ndef upload_project_directory(github_username, github_token, config, args=None):\n    \"\"\"Handles the entire process of uploading/updating a project directory.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would initialize git repository, create/get GitHub repository, and push to GitHub.\")\n        return\n\n    print_header(\"Upload Project Directory\")\n    project_path, repo_name, repo_description, is_private = get_project_directory_input(config, args)\n    \n    # Input Validation\n    is_valid_path, path_err = validate_file_path(project_path)\n    if not is_valid_path:\n        print_error(f\"Error: {path_err}\")\n        return\n\n    is_valid_repo, repo_err = validate_repo_name(repo_name)\n    if not is_valid_repo:\n        print_error(f\"Error: {repo_err}\")\n        return\n\n    # Run security scan on the directory\n    if not scan_directory_for_sensitive_files(project_path):\n        print_warning(\"Upload cancelled due to security check.\")\n        return\n\n    initialize_git_repository(project_path)\n    create_or_get_github_repository(repo_name, repo_description, is_private, github_username, github_token)\n    push_to_github(repo_name, github_username, github_token)\n    print_info(f\"You can find your repository at: https://github.com/{github_username}/{repo_name}\")\n"
      },
      "reasons": [
        "Makes 12 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 4,
      "suggestedSplits": [
        "Apply Single Responsibility: Split upload_project_directory into multiple functions, each handling one aspect.",
        "Potential extraction candidates: upload_project_directory, print_info, print_header, get_project_directory_input, validate_file_path"
      ]
    },
    {
      "function": {
        "id": "44098917418d",
        "name": "update_multiple_repos",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 408,
        "endLine": 468,
        "lineCount": 61,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "update_multiple_repos",
          "print_info",
          "get_multi_repo_input",
          "print_header",
          "check_is_sensitive",
          "print_warning",
          "input",
          "lower",
          "exists",
          "print_error",
          "open",
          "read",
          "get_file_info",
          "json",
          "get",
          "update_file",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 14,
        "isExported": false,
        "isAsync": false,
        "docstring": "Update the same file across multiple repositories with styled output.",
        "body": "\ndef update_multiple_repos(github_username, github_token, config, args=None):\n    \"\"\"Update the same file across multiple repositories with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        repo_names, file_path, repo_file_path, commit_message = get_multi_repo_input(config, args)\n        print_info(f\"Would update {file_path} in {len(repo_names)} repositories.\")\n        return\n\n    print_header(\"Multi-Repository Update\")\n    repo_names, file_path, repo_file_path, commit_message = get_multi_repo_input(config, args)\n    \n    # Security check\n    if check_is_sensitive(file_path):\n        print_warning(f\"'{file_path}' appears to be a sensitive file.\")\n        confirm = input(\"Are you sure you want to update this file across multiple repositories? (y/n): \").lower()\n        if confirm != 'y':\n            print_info(\"Multi-repo update cancelled.\")\n            return\n\n    # Filter out any empty repository names that might result from trailing commas\n    repo_names = [name for name in repo_names if name]\n\n    if not os.path.exists(file_path):\n        print_error(f\"File '{file_path}' not found.\")\n        return\n    \n    print_info(f\"Updating {file_path} in {len(repo_names)} repositories...\")\n    \n    try:\n        with open(file_path, \"rb\") as f:\n            file_content = f.read()\n    except Exception as e:\n        print_error(f\"Error reading file: {e}\")\n        return\n    \n    success_count = 0\n    for repo_name in repo_names:\n        try:\n            # Check if file exists to get SHA\n            response = get_file_info(github_username, repo_name, repo_file_path, github_token)\n            sha = None\n            if response.status_code == 200:\n                sha = response.json().get('sha')\n            \n            # Update file\n            update_response = update_file(\n                github_username, repo_name, repo_file_path,\n                file_content, github_token, commit_message, sha\n            )\n            \n            if update_response.status_code in [200, 201]:\n                print_success(f\"Updated {repo_file_path} in {repo_name}\")\n                success_count += 1\n            else:\n                print_error(f\"Failed to update {repo_file_path} in {repo_name}: {update_response.status_code}\")\n        except Exception as e:\n            print_error(f\"Error updating {repo_name}: {e}\")\n    \n    print_success(f\"Multi-repository update complete: {success_count}/{len(repo_names)} successful.\")\n"
      },
      "reasons": [
        "Makes 17 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 4,
      "suggestedSplits": [
        "Apply Single Responsibility: Split update_multiple_repos into multiple functions, each handling one aspect.",
        "Potential extraction candidates: update_multiple_repos, print_info, get_multi_repo_input, print_header, check_is_sensitive"
      ]
    },
    {
      "function": {
        "id": "1f4213d37548",
        "name": "manage_bulk_repositories",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 506,
        "endLine": 543,
        "lineCount": 38,
        "parameters": [
          "github_token"
        ],
        "calls": [
          "manage_bulk_repositories",
          "print_header",
          "print_info",
          "get_user_repos",
          "print_error",
          "json",
          "print_success",
          "get",
          "growth",
          "tanh",
          "max",
          "min"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 8,
        "isExported": false,
        "isAsync": false,
        "docstring": "List all repositories and show aggregated health scores.",
        "body": "\ndef manage_bulk_repositories(github_token):\n    \"\"\"List all repositories and show aggregated health scores.\"\"\"\n    print_header(\"Bulk Repository Management\")\n    print_info(\"Fetching all your repositories...\")\n    \n    try:\n        response = get_user_repos(github_token)\n        if response.status_code != 200:\n            print_error(f\"Failed to fetch repos: {response.status_code}\")\n            return\n            \n        repos = response.json()\n        print_success(f\"Found {len(repos)} repositories.\\n\")\n        \n        print(f\"{ 'Repository Name':<40} | {'Stars':<6} | {'Issues':<6} | {'Score':<6}\")\n        print(\"-\" * 65)\n        \n        import math\n        for r in repos:\n            stars = r.get('stargazers_count', 0)\n            issues = r.get('open_issues_count', 0)\n            \n            # Sophisticated Health Logic:\n            # 1. Star Weight: Logarithmic growth (tanh caps it)\n            # 2. Issue Penalty: Non-linear decay based on star-to-issue ratio\n            star_impact = math.tanh(stars / 50.0) * 70  # Max 70 points from stars\n            issue_ratio = issues / (stars + 1)\n            issue_penalty = math.tanh(issue_ratio) * 30 # Max 30 point penalty\n            \n            health_score = int(30 + star_impact - issue_penalty) # Baseline of 30\n            health_score = max(0, min(100, health_score))\n            \n            color = \"green\" if health_score > 75 else \"yellow\" if health_score > 45 else \"red\"\n            print(f\"{r['name']:<40} | {stars:<6} | {issues:<6} | [{color}]{health_score}%[/{color}]\")\n            \n    except Exception as e:\n        print_error(f\"Bulk operation failed: {e}\")"
      },
      "reasons": [
        "Makes 12 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 4,
      "suggestedSplits": [
        "Apply Single Responsibility: Split manage_bulk_repositories into multiple functions, each handling one aspect.",
        "Potential extraction candidates: manage_bulk_repositories, print_header, print_info, get_user_repos, print_error"
      ]
    },
    {
      "function": {
        "id": "dcae852f2920",
        "name": "generate_ai_commit_message",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
        "startLine": 17,
        "endLine": 64,
        "lineCount": 48,
        "parameters": [
          "api_key",
          "diff_text"
        ],
        "calls": [
          "generate_ai_commit_message",
          "print_error",
          "wizard",
          "standard",
          "line",
          "post",
          "json",
          "strip",
          "startswith",
          "join",
          "splitlines"
        ],
        "calledBy": [
          "d51b6e299e0d"
        ],
        "complexity": 11,
        "isExported": false,
        "isAsync": false,
        "docstring": "Uses Gemini API to generate a professional commit message from a diff.",
        "body": "\ndef generate_ai_commit_message(api_key, diff_text):\n    \"\"\"Uses Gemini API to generate a professional commit message from a diff.\"\"\"\n    if not api_key:\n        print_error(\"Gemini API Key missing. Please run the configuration wizard (Option 14).\")\n        return None\n\n    url = f\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={api_key}\"\n    \n    prompt = f\"\"\"\n    You are an expert software engineer and git specialist. \n    Analyze the following git diff and generate a professional commit message. \n    \n    CRITICAL RULES:\n    1. Follow the Conventional Commits standard (feat:, fix:, refactor:, chore:, docs:, style:, test:).\n    2. Start with a high-level summary line (max 50 chars).\n    3. Add a blank line, then a bulleted list of specific, meaningful changes.\n    4. Focus on the WHY and the IMPACT, not just the technical details.\n    5. Do not include any other text, only the commit message itself. \n    \n    DIFF DATA:\n    {diff_text[:10000]} # Truncate to 10k chars for safety\n    \"\"\"\n\n    payload = {\n        \"contents\": [{\"parts\": [{\"text\": prompt}]}]\n    }\n\n    try:\n        response = requests.post(url, json=payload, timeout=30)\n        if response.status_code == 200:\n            data = response.json()\n            try:\n                msg = data['candidates'][0]['content']['parts'][0]['text'].strip()\n                # Clean up markdown if the AI includes it\n                if msg.startswith(\"```\"):\n                    msg = \"\\n\".join(msg.splitlines()[1:-1])\n                return msg\n            except (KeyError, IndexError):\n                print_error(\"Could not parse AI response.\")\n                return None\n        else:\n            print_error(f\"Gemini API Error: {response.status_code} - {response.text}\")\n            return None\n    except Exception as e:\n        print_error(f\"Connection failed: {e}\")\n        return None\n"
      },
      "reasons": [
        "Makes 11 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 4,
      "suggestedSplits": [
        "Apply Single Responsibility: Split generate_ai_commit_message into multiple functions, each handling one aspect.",
        "Potential extraction candidates: generate_ai_commit_message, print_error, wizard, standard, line"
      ]
    },
    {
      "function": {
        "id": "d51b6e299e0d",
        "name": "ai_commit_workflow",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
        "startLine": 104,
        "endLine": 146,
        "lineCount": 43,
        "parameters": [
          "github_username",
          "github_token",
          "config"
        ],
        "calls": [
          "ai_commit_workflow",
          "get",
          "get_git_diff",
          "print_warning",
          "print_info",
          "generate_ai_commit_message",
          "Panel",
          "input",
          "action",
          "run",
          "print_success",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 7,
        "isExported": false,
        "isAsync": false,
        "docstring": "Orchestrates the AI commit process.",
        "body": "\ndef ai_commit_workflow(github_username, github_token, config):\n    \"\"\"Orchestrates the AI commit process.\"\"\"\n    api_key = config[\"github\"].get(\"ai_api_key\")\n    \n    diff = get_git_diff()\n    if not diff:\n        print_warning(\"No staged changes found. Use 'git add' to stage files before AI commit.\")\n        return False\n\n    print_info(\"ü§ñ AI is analyzing your changes...\")\n    \n    message = generate_ai_commit_message(api_key, diff)\n    if not message:\n        return False\n\n    console.print(Panel(message, title=\"[bold cyan]Generated Commit Message[/bold cyan]\", border_style=\"cyan\"))\n    \n    print(\"\\n[bold]Options:[/bold]\")\n    print(\"1: [green]Accept & Commit[/green]\")\n    print(\"2: [yellow]Edit manually[/yellow]\")\n    print(\"3: [red]Cancel[/red]\")\n    \n    choice = input(\"\\nüëâ Choose an action (1-3): \")\n    \n    if choice == '1':\n        try:\n            subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n            print_success(\"Changes committed successfully!\")\n            return True\n        except Exception as e:\n            print_error(f\"Commit failed: {e}\")\n            return False\n    elif choice == '2':\n        # Simple manual edit fallback\n        manual_msg = input(\"Enter new commit message: \")\n        if manual_msg:\n            subprocess.run([\"git\", \"commit\", \"-m\", manual_msg], check=True)\n            print_success(\"Changes committed successfully!\")\n            return True\n    \n    print_info(\"Commit cancelled.\")\n    return False"
      },
      "reasons": [
        "Makes 12 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 4,
      "suggestedSplits": [
        "Apply Single Responsibility: Split ai_commit_workflow into multiple functions, each handling one aspect.",
        "Potential extraction candidates: ai_commit_workflow, get, get_git_diff, print_warning, print_info"
      ]
    },
    {
      "function": {
        "id": "be40efbe3e80",
        "name": "generate_analytics",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
        "startLine": 53,
        "endLine": 121,
        "lineCount": 69,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "generate_analytics",
          "print_header",
          "input",
          "print_info",
          "now",
          "isoformat",
          "github_request",
          "print_error",
          "json",
          "get",
          "predict_growth",
          "get_contributors",
          "Table",
          "add_column",
          "add_row",
          "get_issues",
          "calculate_resolution_time",
          "Projection",
          "lower",
          "export_report"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 10,
        "isExported": false,
        "isAsync": false,
        "docstring": "Advanced Repository Intelligence & Predictive Analytics.",
        "body": "\ndef generate_analytics(github_username, github_token, config, args=None):\n    \"\"\"Advanced Repository Intelligence & Predictive Analytics.\"\"\"\n    print_header(\"Advanced Analytics & Reporting\")\n    \n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n\n    print_info(f\"Analyzing {repo_name}...\")\n    report_data = {\"repo_name\": repo_name, \"timestamp\": datetime.now().isoformat()}\n\n    try:\n        # 1. Fetch Core Data\n        repo_resp = github_request(\"GET\", f\"https://api.github.com/repos/{github_username}/{repo_name}\", github_token)\n        if repo_resp.status_code != 200:\n            print_error(f\"Failed to fetch repo data: {repo_resp.status_code}\")\n            return\n        \n        repo_data = repo_resp.json()\n        stars = repo_data.get('stargazers_count', 0)\n        \n        # 2. Predictive Growth\n        predicted_stars = predict_growth(stars, repo_data['created_at'])\n        report_data[\"current_stars\"] = stars\n        report_data[\"predicted_stars_90d\"] = predicted_stars\n\n        # 3. Contributor Metrics\n        contrib_resp = get_contributors(github_username, repo_name, github_token)\n        if contrib_resp.status_code == 200:\n            contributors = contrib_resp.json()\n            report_data[\"contributor_count\"] = len(contributors)\n            \n            # Weighted Impact Table\n            table = Table(title=\"Contributor Performance Metrics\", box=box.DOUBLE_EDGE)\n            table.add_column(\"User\", style=\"cyan\")\n            table.add_column(\"Impact Score\", justify=\"right\", style=\"green\")\n            \n            for c in contributors[:5]:\n                # Impact = Contributions * 1.5 (Advanced weighting logic)\n                impact_score = int(c['contributions'] * 1.5)\n                table.add_row(c['login'], str(impact_score))\n            console.print(table)\n\n        # 4. Issue Resolution Analytics\n        issue_resp = get_issues(github_username, repo_name, github_token, state='all')\n        if issue_resp.status_code == 200:\n            issues = issue_resp.json()\n            avg_res_hours = calculate_resolution_time(issues)\n            report_data[\"avg_resolution_hours\"] = avg_res_hours\n            \n            res_table = Table(title=\"Predictive Maintenance\", box=box.SIMPLE)\n            res_table.add_row(\"Avg Resolution Time\", f\"{avg_res_hours} Hours\")\n            res_table.add_row(\"Growth Projection (90d)\", f\"{predicted_stars} Stars\")\n            console.print(res_table)\n\n        # 5. Dashboard Summary\n        print_info(f\"\\n[bold]Summary for {repo_name}:[/bold]\")\n        print(f\"üåü Stars: {stars} -> Predicted: {predicted_stars}\")\n        print(f\"‚è±Ô∏è  Avg Fix Time: {avg_res_hours} hrs\")\n\n        # 6. Export Prompt\n        export = input(\"\\nüíæ Export report? (json/csv/n): \").lower()\n        if export in ['json', 'csv']:\n            export_report(repo_name, report_data, export)\n\n    except Exception as e:\n        print_error(f\"Analytics engine failure: {e}\")"
      },
      "reasons": [
        "Makes 20 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 4,
      "suggestedSplits": [
        "Apply Single Responsibility: Split generate_analytics into multiple functions, each handling one aspect.",
        "Potential extraction candidates: generate_analytics, print_header, input, print_info, now"
      ]
    },
    {
      "function": {
        "id": "ad7661271cb1",
        "name": "perform_update",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
        "startLine": 45,
        "endLine": 77,
        "lineCount": 33,
        "parameters": [],
        "calls": [
          "perform_update",
          "print_info",
          "PyGitUp",
          "abspath",
          "dirname",
          "getcwd",
          "exists",
          "join",
          "chdir",
          "run",
          "print_success",
          "exit",
          "print_error"
        ],
        "calledBy": [
          "dad53122bce0"
        ],
        "complexity": 5,
        "isExported": false,
        "isAsync": false,
        "docstring": "Executes a safe update by finding the package source and pulling.",
        "body": "\ndef perform_update():\n    \"\"\"Executes a safe update by finding the package source and pulling.\"\"\"\n    print_info(\"Initiating self-update sequence...\")\n    \n    # 1. Find the root of the PyGitUp installation\n    # pygitup/utils/update.py -> pygitup/utils -> pygitup -> PyGitUp (root)\n    try:\n        current_file_path = os.path.abspath(__file__)\n        package_root = os.path.dirname(os.path.dirname(os.path.dirname(current_file_path)))\n        \n        original_cwd = os.getcwd()\n        \n        if os.path.exists(os.path.join(package_root, \".git\")):\n            print_info(f\"Updating source at: {package_root}\")\n            os.chdir(package_root)\n            \n            # 2. Perform the pull\n            result = subprocess.run([\"git\", \"pull\", \"origin\", \"main\"], capture_output=True, text=True)\n            \n            if result.returncode == 0:\n                print_success(\"PyGitUp updated to the latest version!\")\n                print_info(\"Please restart the tool to apply changes.\")\n                os.chdir(original_cwd)\n                sys.exit(0)\n            else:\n                print_error(f\"Git Pull Failed: {result.stderr}\")\n        else:\n            print_error(\"This installation is not managed by Git. Please update manually via 'pip install --upgrade .'\")\n            \n        os.chdir(original_cwd)\n    except Exception as e:\n        print_error(f\"Update sequence failed: {e}\")"
      },
      "reasons": [
        "Makes 13 local function calls. May be an orchestration function that should be simplified."
      ],
      "score": 4,
      "suggestedSplits": [
        "Apply Single Responsibility: Split perform_update into multiple functions, each handling one aspect.",
        "Potential extraction candidates: perform_update, print_info, PyGitUp, abspath, dirname"
      ]
    },
    {
      "function": {
        "id": "5285545074d8",
        "name": "main",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
        "startLine": 40,
        "endLine": 43,
        "lineCount": 4,
        "parameters": [],
        "calls": [
          "main"
        ],
        "calledBy": [],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "body": "\ndef main():\n    print(\"Hello from {{PROJECT_NAME}}!\")\n"
      },
      "reasons": [
        "Generic function name \"main\" often indicates a catch-all function."
      ],
      "score": 3,
      "suggestedSplits": []
    }
  ],
  "deadCode": [
    {
      "item": {
        "id": "470391cb22b0",
        "name": "list_profiles",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "startLine": 126,
        "endLine": 128,
        "lineCount": 3,
        "parameters": [],
        "calls": [],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "body": "\n\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"list_profiles\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "c5fcd19ff943",
        "name": "manage_branches",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/branch.py",
        "startLine": 4,
        "endLine": 57,
        "lineCount": 54,
        "parameters": [
          "args"
        ],
        "calls": [
          "manage_branches",
          "print_header",
          "List",
          "prompt",
          "Text",
          "print_info",
          "run",
          "print_error",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 18,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle branch management operations with styled output.",
        "body": "\ndef manage_branches(args):\n    \"\"\"Handle branch management operations with styled output.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    branch_name = args.branch_name if hasattr(args, 'branch_name') and args.branch_name else None\n\n    if not action:\n        print_header(\"Branch Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What branch operation would you like to perform?\",\n                choices=[\"list\", \"create\", \"delete\", \"switch\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if action in [\"create\", \"delete\", \"switch\"]:\n            branch_questions = [\n                inquirer.Text(\"branch_name\", message=f\"Enter the name of the branch to {action}\")\n            ]\n            branch_answers = inquirer.prompt(branch_questions)\n            branch_name = branch_answers[\"branch_name\"]\n\n    try:\n        if action == \"list\":\n            print_info(\"Listing all local branches:\")\n            subprocess.run([\"git\", \"branch\"], check=True)\n        elif action == \"create\":\n            if not branch_name:\n                print_error(\"Branch name is required.\")\n                return\n            print_info(f\"Creating new branch: {branch_name}\")\n            subprocess.run([\"git\", \"branch\", branch_name], check=True)\n            print_success(f\"Branch '{branch_name}' created.\")\n        elif action == \"delete\":\n            if not branch_name:\n                print_error(\"Branch name is required.\")\n                return\n            print_info(f\"Deleting branch: {branch_name}\")\n            subprocess.run([\"git\", \"branch\", \"-d\", branch_name], check=True)\n            print_success(f\"Branch '{branch_name}' deleted.\")\n        elif action == \"switch\":\n            if not branch_name:\n                print_error(\"Branch name is required.\")\n                return\n            print_info(f\"Switching to branch: {branch_name}\")\n            subprocess.run([\"git\", \"checkout\", branch_name], check=True)\n            print_success(f\"Switched to branch '{branch_name}'.\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"manage_branches\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "f1f948b57bf3",
        "name": "smart_push",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/push.py",
        "startLine": 3,
        "endLine": 74,
        "lineCount": 72,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "smart_push",
          "print_info",
          "input",
          "split",
          "squash",
          "run",
          "strip",
          "lower",
          "append",
          "print_success",
          "join",
          "print_warning",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 20,
        "isExported": false,
        "isAsync": false,
        "docstring": "Smart push that squashes meaningless commits with styled output.",
        "body": "\ndef smart_push(github_username, github_token, config, args=None):\n    \"\"\"Smart push that squashes meaningless commits with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would perform a smart push with commit squashing.\")\n        return\n\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n\n    # Get squash patterns\n    if args and args.squash_pattern:\n        patterns = args.squash_pattern.split(\",\")\n    else:\n        patterns_input = input(\"Enter commit message patterns to squash (comma-separated): \")\n        patterns = patterns_input.split(\",\") if patterns_input else [\"typo\", \"fix\", \"update\"]\n\n    print_info(f\"Smart pushing to {repo_name} with squash patterns: {patterns}\")\n\n    try:\n        # Get the last 10 commits\n        log_result = subprocess.run([\"git\", \"log\", \"--oneline\", \"-n\", \"10\"], capture_output=True, text=True, check=True)\n        commits = log_result.stdout.strip().split(\"\\n\")\n\n        # Identify commits to squash\n        commits_to_squash = []\n        for commit in commits:\n            parts = commit.split(\" \", 1)\n            if len(parts) < 2: continue\n            commit_hash, commit_message = parts\n            for pattern in patterns:\n                if pattern.lower() in commit_message.lower():\n                    commits_to_squash.append(commit_hash)\n                    break\n\n        if not commits_to_squash:\n            print_info(\"No commits to squash. Pushing normally.\")\n            subprocess.run([\"git\", \"push\"], check=True)\n            print_success(\"Pushed to GitHub.\")\n            return\n\n        print_info(f\"Found {len(commits_to_squash)} commits to squash: {commits_to_squash}\")\n\n        # The parent of the oldest commit to be squashed\n        squash_base = f\"{commits_to_squash[-1]}~\"\n\n        # Get the messages of the commits being squashed for the new commit message\n        squashed_messages = []\n        for commit_hash in reversed(commits_to_squash):\n            msg = subprocess.run([\"git\", \"log\", \"--format=%B\", \"-n\", \"1\", commit_hash], capture_output=True, text=True, check=True).stdout.strip()\n            squashed_messages.append(msg)\n\n        new_commit_message = f\"Squashed {len(squashed_messages)} commits\\n\\n\" + \"\\n\".join(f\"- {msg}\" for msg in squashed_messages)\n\n        print_info(f\"Resetting to {squash_base} and preparing to squash.\")\n        subprocess.run([\"git\", \"reset\", \"--soft\", squash_base], check=True)\n\n        print_info(\"Creating new squashed commit.\")\n        subprocess.run([\"git\", \"commit\", \"-m\", new_commit_message], check=True)\n\n        print_warning(\"Force-pushing the new history. This will overwrite the remote history.\")\n        subprocess.run([\"git\", \"push\", \"--force-with-lease\"], check=True)\n\n        print_success(\"Smart push complete.\")\n\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"smart_push\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "c655144f401e",
        "name": "manage_stashes",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/stash.py",
        "startLine": 4,
        "endLine": 55,
        "lineCount": 52,
        "parameters": [
          "args"
        ],
        "calls": [
          "manage_stashes",
          "print_header",
          "List",
          "prompt",
          "Text",
          "append",
          "print_info",
          "run",
          "print_success",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 19,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle stash management operations with styled output.",
        "body": "\ndef manage_stashes(args):\n    \"\"\"Handle stash management operations with styled output.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    message = args.message if hasattr(args, 'message') and args.message else None\n\n    if not action:\n        print_header(\"Stash Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What stash operation would you like to perform?\",\n                choices=[\"save\", \"list\", \"apply\", \"pop\", \"drop\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if action == \"save\":\n            stash_questions = [\n                inquirer.Text(\"message\", message=\"Enter an optional message for the stash\")\n            ]\n            stash_answers = inquirer.prompt(stash_questions)\n            message = stash_answers[\"message\"]\n\n    try:\n        if action == \"save\":\n            command = [\"git\", \"stash\", \"save\"]\n            if message:\n                command.append(message)\n            print_info(\"Saving current changes to a new stash.\")\n            subprocess.run(command, check=True)\n            print_success(\"Changes stashed.\")\n        elif action == \"list\":\n            print_info(\"Listing all stashes:\")\n            subprocess.run([\"git\", \"stash\", \"list\"], check=True)\n        elif action == \"apply\":\n            print_info(\"Applying the latest stash.\")\n            subprocess.run([\"git\", \"stash\", \"apply\"], check=True)\n            print_success(\"Stash applied.\")\n        elif action == \"pop\":\n            print_info(\"Applying the latest stash and dropping it from the list.\")\n            subprocess.run([\"git\", \"stash\", \"pop\"], check=True)\n            print_success(\"Stash popped.\")\n        elif action == \"drop\":\n            print_info(\"Dropping the latest stash.\")\n            subprocess.run([\"git\", \"stash\", \"drop\"], check=True)\n            print_success(\"Stash dropped.\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"manage_stashes\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "ebb909c21ccf",
        "name": "manage_tags",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/tag.py",
        "startLine": 4,
        "endLine": 63,
        "lineCount": 60,
        "parameters": [
          "args"
        ],
        "calls": [
          "manage_tags",
          "print_header",
          "List",
          "prompt",
          "Text",
          "print_info",
          "run",
          "print_error",
          "extend",
          "append",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 22,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle tag management operations with styled output.",
        "body": "\ndef manage_tags(args):\n    \"\"\"Handle tag management operations with styled output.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    tag_name = args.tag_name if hasattr(args, 'tag_name') and args.tag_name else None\n    message = args.message if hasattr(args, 'message') and args.message else None\n\n    if not action:\n        print_header(\"Tag Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What tag operation would you like to perform?\",\n                choices=[\"list\", \"create\", \"delete\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if action in [\"create\", \"delete\"]:\n            tag_questions = [\n                inquirer.Text(\"tag_name\", message=f\"Enter the name of the tag to {action}\")\n            ]\n            tag_answers = inquirer.prompt(tag_questions)\n            tag_name = tag_answers[\"tag_name\"]\n\n        if action == \"create\":\n            message_questions = [\n                inquirer.Text(\"message\", message=\"Enter an optional annotation message for the tag\")\n            ]\n            message_answers = inquirer.prompt(message_questions)\n            message = message_answers[\"message\"]\n\n    try:\n        if action == \"list\":\n            print_info(\"Listing all tags:\")\n            subprocess.run([\"git\", \"tag\"], check=True)\n        elif action == \"create\":\n            if not tag_name:\n                print_error(\"Tag name is required.\")\n                return\n            command = [\"git\", \"tag\"]\n            if message:\n                command.extend([\"-a\", tag_name, \"-m\", message])\n            else:\n                command.append(tag_name)\n            print_info(f\"Creating new tag: {tag_name}\")\n            subprocess.run(command, check=True)\n            print_success(f\"Tag '{tag_name}' created.\")\n        elif action == \"delete\":\n            if not tag_name:\n                print_error(\"Tag name is required.\")\n                return\n            print_info(f\"Deleting tag: {tag_name}\")\n            subprocess.run([\"git\", \"tag\", \"-d\", tag_name], check=True)\n            print_success(f\"Tag '{tag_name}' deleted.\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"manage_tags\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "cae9e9daf651",
        "name": "manage_actions",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/actions.py",
        "startLine": 4,
        "endLine": 84,
        "lineCount": 81,
        "parameters": [
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "manage_actions",
          "print_header",
          "List",
          "prompt",
          "Text",
          "github_request",
          "json",
          "get",
          "print_error",
          "input",
          "ref",
          "print_success",
          "print_info",
          "fromisoformat",
          "replace",
          "divmod",
          "total_seconds",
          "Rate",
          "lower",
          "toggle_workflow_api"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 26,
        "isExported": false,
        "isAsync": false,
        "docstring": "Advanced GitHub Actions Control Center.",
        "body": "\ndef manage_actions(args, github_username, github_token):\n    \"\"\"Advanced GitHub Actions Control Center.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n\n    if not action:\n        print_header(\"CI/CD Control Center\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"Select an Actions operation\",\n                choices=[\"Trigger Workflow\", \"Monitor Status & Metrics\", \"Enable Workflow\", \"Disable Workflow\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n    if not repo_name:\n        repo_name = inquirer.prompt([inquirer.Text(\"repo\", message=\"Enter the repository name\")])[\"repo\"]\n\n    base_url = f\"https://api.github.com/repos/{github_username}/{repo_name}/actions\"\n\n    try:\n        if action == \"Trigger Workflow\":\n            # List workflows first to let user choose\n            w_resp = github_request(\"GET\", f\"{base_url}/workflows\", github_token)\n            workflows = w_resp.json().get(\"workflows\", [])\n            if not workflows:\n                print_error(\"No workflows found.\")\n                return\n            \n            choices = [(w['name'], w['id']) for w in workflows]\n            w_choice = inquirer.prompt([inquirer.List(\"w\", message=\"Select workflow to trigger\", choices=choices)])[\"w\"]\n            ref = input(\"Enter ref (branch/tag) [main]: \") or \"main\"\n            \n            trigger_url = f\"{base_url}/workflows/{w_choice}/dispatches\"\n            github_request(\"POST\", trigger_url, github_token, json={\"ref\": ref})\n            print_success(f\"Successfully triggered workflow run on {ref}\")\n\n        elif action == \"Monitor Status & Metrics\":\n            print_info(f\"Fetching execution metrics for {repo_name}...\")\n            run_resp = github_request(\"GET\", f\"{base_url}/runs\", github_token, params={\"per_page\": 10})\n            runs = run_resp.json().get(\"workflow_runs\", [])\n            \n            if not runs:\n                print_info(\"No recent runs found.\")\n                return\n\n            print(\"\\n[bold]Recent Workflow Runs & Metrics:[/bold]\")\n            success_count = 0\n            from datetime import datetime\n            for run in runs:\n                status_icon = \"üü¢\" if run['conclusion'] == \"success\" else \"üî¥\" if run['conclusion'] == \"failure\" else \"‚è≥\"\n                if run['conclusion'] == \"success\": success_count += 1\n                \n                duration_str = \"N/A\"\n                if run.get('updated_at') and run.get('run_started_at'):\n                    start = datetime.fromisoformat(run['run_started_at'].replace('Z', '+00:00'))\n                    end = datetime.fromisoformat(run['updated_at'].replace('Z', '+00:00'))\n                    diff = end - start\n                    minutes, seconds = divmod(diff.total_seconds(), 60)\n                    duration_str = f\"{int(minutes)}m {int(seconds)}s\"\n\n                print(f\"{status_icon} ID: {run['id']} | {run['name']} | Time: {duration_str} | Result: {run['conclusion']}\")\n            \n            success_rate = (success_count / len(runs)) * 100\n            print(f\"\\n[bold cyan]Success Rate (Last 10): {success_rate:.0f}%[/bold cyan]\")\n\n        elif \"Workflow\" in action:\n            enable = \"Enable\" in action\n            w_resp = github_request(\"GET\", f\"{base_url}/workflows\", github_token)\n            workflows = w_resp.json().get(\"workflows\", [])\n            choices = [(w['name'], w['id']) for w in workflows]\n            w_choice = inquirer.prompt([inquirer.List(\"w\", message=f\"Select workflow to {action.lower()}\", choices=choices)])[\"w\"]\n            \n            toggle_workflow_api(github_username, repo_name, github_token, w_choice, enable=enable)\n            print_success(f\"Workflow {action.lower()}d successfully.\")\n\n    except Exception as e:\n        print_error(f\"Actions operation failed: {e}\")"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"manage_actions\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "8037213f9b0d",
        "name": "manage_gists",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
        "startLine": 5,
        "endLine": 84,
        "lineCount": 80,
        "parameters": [
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "manage_gists",
          "print_header",
          "List",
          "prompt",
          "print_info",
          "Text",
          "Confirm",
          "check_is_sensitive",
          "print_warning",
          "input",
          "lower",
          "github_request",
          "raise_for_status",
          "json",
          "print_success",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 32,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle Gist management operations with rate-limiting support.",
        "body": "\ndef manage_gists(args, github_username, github_token):\n    \"\"\"Handle Gist management operations with rate-limiting support.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    filename = args.filename if hasattr(args, 'filename') and args.filename else None\n    content = args.content if hasattr(args, 'content') and args.content else None\n    description = args.description if hasattr(args, 'description') and args.description else None\n    public = args.public if hasattr(args, 'public') and args.public else False\n\n    if not action:\n        print_header(\"Gist Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What Gist operation would you like to perform?\",\n                choices=[\"create\", \"list\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        if not answers:\n            print_info(\"Operation cancelled.\")\n            return\n        action = answers[\"action\"]\n\n        if action == \"create\":\n            gist_questions = [\n                inquirer.Text(\"filename\", message=\"Enter the filename for the Gist\"),\n                inquirer.Text(\"content\", message=\"Enter the content of the Gist\"),\n                inquirer.Text(\"description\", message=\"Enter an optional description for the Gist\"),\n                inquirer.Confirm(\"public\", message=\"Make the Gist public?\", default=False),\n            ]\n            gist_answers = inquirer.prompt(gist_questions)\n            if not gist_answers:\n                print_info(\"Operation cancelled.\")\n                return\n            filename = gist_answers[\"filename\"]\n            content = gist_answers[\"content\"]\n            description = gist_answers[\"description\"]\n            public = gist_answers[\"public\"]\n\n    try:\n        if action == \"create\":\n            # Security check for Gist content/filename\n            if check_is_sensitive(filename):\n                print_warning(f\"'{filename}' appears to be a sensitive filename pattern.\")\n                confirm = input(\"Are you sure you want to create this Gist? (y/n): \").lower()\n                if confirm != 'y':\n                    print_info(\"Gist creation cancelled.\")\n                    return\n\n            data = {\n                \"description\": description or \"\",\n                \"public\": public,\n                \"files\": {\n                    filename: {\n                        \"content\": content\n                    }\n                }\n            }\n            response = github_request(\"POST\", \"https://api.github.com/gists\", github_token, json=data)\n            response.raise_for_status()\n            gist_data = response.json()\n            print_success(\"Gist created successfully!\")\n            print_info(f\"View it here: {gist_data['html_url']}\")\n\n        elif action == \"list\":\n            url = f\"https://api.github.com/users/{github_username}/gists\"\n            response = github_request(\"GET\", url, github_token)\n            response.raise_for_status()\n            gists = response.json()\n            if gists:\n                print_info(\"Your Gists:\")\n                for gist in gists:\n                    gist_desc = gist['description'] or \"No description\"\n                    print(f\"- {gist['html_url']} ({gist_desc})\")\n            else:\n                print_info(\"You don't have any Gists.\")\n\n    except Exception as e:\n        print_error(f\"Gist operation failed: {e}\")"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"manage_gists\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "72913908c45b",
        "name": "manage_pull_requests",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
        "startLine": 7,
        "endLine": 70,
        "lineCount": 64,
        "parameters": [
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "manage_pull_requests",
          "print_header",
          "List",
          "prompt",
          "Text",
          "print_error",
          "github_request",
          "raise_for_status",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 23,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle pull request management operations with rate-limiting support.",
        "body": "\ndef manage_pull_requests(args, github_username, github_token):\n    \"\"\"Handle pull request management operations with rate-limiting support.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n    pr_number = args.pr_number if hasattr(args, 'pr_number') and args.pr_number else None\n    comment = args.comment if hasattr(args, 'comment') and args.comment else None\n\n    if not action:\n        print_header(\"Pull Request Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What pull request operation would you like to perform?\",\n                choices=[\"merge\", \"close\", \"comment\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if not repo_name:\n            repo_questions = [inquirer.Text(\"repo\", message=\"Enter the repository name\")]\n            repo_answers = inquirer.prompt(repo_questions)\n            repo_name = repo_answers[\"repo\"]\n\n        pr_number_questions = [inquirer.Text(\"pr_number\", message=\"Enter the pull request number\")]\n        pr_number_answers = inquirer.prompt(pr_number_questions)\n        pr_number = int(pr_number_answers[\"pr_number\"])\n\n        if action == \"comment\":\n            comment_questions = [inquirer.Text(\"comment\", message=\"Enter your comment\")]\n            comment_answers = inquirer.prompt(comment_questions)\n            comment = comment_answers[\"comment\"]\n\n    if not repo_name or not pr_number:\n        print_error(\"Repository name and pull request number are required.\")\n        return\n\n    base_url = f\"https://api.github.com/repos/{github_username}/{repo_name}\"\n\n    try:\n        if action == \"merge\":\n            url = f\"{base_url}/pulls/{pr_number}/merge\"\n            response = github_request(\"PUT\", url, github_token)\n            response.raise_for_status()\n            print_success(\"Pull request merged successfully!\")\n\n        elif action == \"close\":\n            url = f\"{base_url}/pulls/{pr_number}\"\n            data = {\"state\": \"closed\"}\n            response = github_request(\"PATCH\", url, github_token, json=data)\n            response.raise_for_status()\n            print_success(\"Pull request closed successfully!\")\n\n        elif action == \"comment\":\n            url = f\"{base_url}/issues/{pr_number}/comments\"\n            data = {\"body\": comment}\n            response = github_request(\"POST\", url, github_token, json=data)\n            response.raise_for_status()\n            print_success(\"Comment added successfully!\")\n\n    except Exception as e:\n        print_error(f\"Pull request operation failed: {e}\")\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"manage_pull_requests\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "dd4bb98c5440",
        "name": "request_code_review",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
        "startLine": 70,
        "endLine": 143,
        "lineCount": 74,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "request_code_review",
          "print_info",
          "prompt",
          "Text",
          "time",
          "run",
          "split",
          "input",
          "review",
          "join",
          "reviewers",
          "create_pull_request",
          "json",
          "print_success",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 28,
        "isExported": false,
        "isAsync": false,
        "docstring": "Request code reviews for specific files.",
        "body": "\ndef request_code_review(github_username, github_token, config, args=None):\n    \"\"\"Request code reviews for specific files.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would request a code review.\")\n        return\n\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = inquirer.prompt([inquirer.Text(\"repo\", message=\"Enter the repository name\")])[\"repo\"]\n\n    # Create a new branch for the review\n    branch_name = f\"review-{int(time.time())}\"\n\n    try:\n        # Create and switch to the new branch\n        subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n        print_info(f\"Created and switched to new branch: {branch_name}\")\n\n        if args and args.files:\n            files = args.files.split(\",\")\n        else:\n            files_input = input(\"Enter files to review (comma-separated): \")\n            files = files_input.split(\",\") if files_input else []\n\n        if files:\n            # Add the specified files to the branch\n            subprocess.run([\"git\", \"add\"] + files, check=True)\n            print_info(f\"Added files to the branch: {files}\")\n\n            # Commit the changes\n            commit_message = f\"Code review request for: {', '.join(files)}\"\n            subprocess.run([\"git\", \"commit\", \"-m\", commit_message], check=True)\n            print_info(\"Committed changes to the branch.\")\n\n        # Push the new branch to GitHub\n        subprocess.run([\"git\", \"push\", \"-u\", \"origin\", branch_name], check=True)\n        print_info(\"Pushed the new branch to GitHub.\")\n\n        reviewers = []\n        if args and args.reviewers:\n            reviewers = args.reviewers.split(\",\")\n        else:\n            reviewers_input = input(\"Enter reviewers (comma-separated GitHub usernames): \")\n            reviewers = reviewers_input.split(\",\") if reviewers_input else []\n\n        # Create a pull request\n        pr_title = f\"Code Review Request: {', '.join(files) if files else 'General Review'}\"\n        pr_body = f\"This PR is requesting code review for the following files:\\n\"\n        for file in files:\n            pr_body += f\"- {file}\\n\"\n\n        if reviewers:\n            pr_body += f\"\\nRequested reviewers: {', '.join(reviewers)}\"\n\n        response = create_pull_request(github_username, repo_name, github_token, pr_title, branch_name, \"main\", pr_body)\n\n        if response.status_code == 201:\n            pr_data = response.json()\n            print_success(\"\\nPull request created successfully!\")\n            print_info(f\"View it here: {pr_data['html_url']}\")\n        else:\n            print_error(f\"\\nError creating pull request: {response.status_code} - {response.text}\")\n\n    except subprocess.CalledProcessError as e:\n        print_error(f\"An error occurred while running a git command: {e}\")\n    except Exception as e:\n        print_error(f\"An error occurred: {e}\")\n    finally:\n        # Switch back to the main branch\n        subprocess.run([\"git\", \"checkout\", \"main\"], check=True)\n        print_info(\"Switched back to the main branch.\")"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"request_code_review\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "e638d8d1a537",
        "name": "manage_repo_visibility",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
        "startLine": 5,
        "endLine": 61,
        "lineCount": 57,
        "parameters": [
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "manage_repo_visibility",
          "print_header",
          "append",
          "Text",
          "List",
          "prompt",
          "print_error",
          "print_info",
          "update_repo_visibility",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 23,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle repository visibility changes with styled output.",
        "body": "\ndef manage_repo_visibility(args, github_username, github_token):\n    \"\"\"Handle repository visibility changes with styled output.\"\"\"\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n    \n    # Determine desired state from args\n    target_private = None\n    if hasattr(args, 'private') and args.private:\n        target_private = True\n    elif hasattr(args, 'public') and args.public:\n        target_private = False\n\n    # Interactive mode if info is missing\n    if (not repo_name or target_private is None):\n        print_header(\"Repository Visibility\")\n        questions = []\n        if not repo_name:\n            questions.append(inquirer.Text(\"repo\", message=\"Enter the repository name\"))\n        \n        if target_private is None:\n            questions.append(inquirer.List(\n                \"visibility\",\n                message=\"Select new visibility\",\n                choices=[\"Private\", \"Public\"],\n            ))\n            \n        answers = inquirer.prompt(questions)\n        \n        if not repo_name:\n            repo_name = answers[\"repo\"]\n        \n        if target_private is None:\n            target_private = answers[\"visibility\"] == \"Private\"\n\n    if not repo_name:\n        print_error(\"Repository name is required.\")\n        return\n\n    if target_private is None:\n        print_error(\"You must specify --private or --public, or select an option.\")\n        return\n\n    visibility_str = \"PRIVATE\" if target_private else \"PUBLIC\"\n    print_info(f\"Changing visibility of '{repo_name}' to {visibility_str}...\")\n\n    try:\n        response = update_repo_visibility(github_username, repo_name, github_token, target_private)\n        \n        if response.status_code == 200:\n            print_success(f\"Successfully changed '{repo_name}' to {visibility_str}.\")\n        else:\n            print_error(f\"Failed to change visibility: {response.status_code} - {response.text}\")\n            print_info(\"Note: You need admin access to the repository to change its visibility.\")\n            \n    except Exception as e:\n        print_error(f\"An error occurred: {e}\")\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"manage_repo_visibility\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "1d0f56ea40c1",
        "name": "manage_webhooks",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/webhooks.py",
        "startLine": 4,
        "endLine": 86,
        "lineCount": 83,
        "parameters": [
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "manage_webhooks",
          "print_header",
          "List",
          "prompt",
          "Text",
          "to",
          "strip",
          "split",
          "print_error",
          "github_request",
          "raise_for_status",
          "json",
          "print_info",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 33,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handle webhook management operations with rate-limiting support.",
        "body": "\ndef manage_webhooks(args, github_username, github_token):\n    \"\"\"Handle webhook management operations with rate-limiting support.\"\"\"\n    action = args.action if hasattr(args, 'action') and args.action else None\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n    hook_id = args.hook_id if hasattr(args, 'hook_id') and args.hook_id else None\n    url = args.url if hasattr(args, 'url') and args.url else None\n    events = args.events if hasattr(args, 'events') and args.events else ['push']\n\n    if not action:\n        print_header(\"Webhook Management\")\n        questions = [\n            inquirer.List(\n                \"action\",\n                message=\"What webhook operation would you like to perform?\",\n                choices=[\"list\", \"create\", \"delete\"],\n            )\n        ]\n        answers = inquirer.prompt(questions)\n        action = answers[\"action\"]\n\n        if not repo_name:\n            repo_questions = [inquirer.Text(\"repo\", message=\"Enter the repository name\")]\n            repo_answers = inquirer.prompt(repo_questions)\n            repo_name = repo_answers[\"repo\"]\n\n        if action == \"create\":\n            webhook_questions = [\n                inquirer.Text(\"url\", message=\"Enter the webhook URL\"),\n                inquirer.Text(\"events\", message=\"Enter events to subscribe to (comma-separated)\", default=\"push\"),\n            ]\n            webhook_answers = inquirer.prompt(webhook_questions)\n            url = webhook_answers[\"url\"]\n            events = [e.strip() for e in webhook_answers[\"events\"].split(\",\")]\n\n        elif action == \"delete\":\n            hook_id_questions = [inquirer.Text(\"hook_id\", message=\"Enter the ID of the webhook to delete\")]\n            hook_id_answers = inquirer.prompt(hook_id_questions)\n            hook_id = hook_id_answers[\"hook_id\"]\n\n    if not repo_name:\n        print_error(\"Repository name is required for webhook operations.\")\n        return\n\n    base_url = f\"https://api.github.com/repos/{github_username}/{repo_name}/hooks\"\n\n    try:\n        if action == \"list\":\n            response = github_request(\"GET\", base_url, github_token)\n            response.raise_for_status()\n            hooks = response.json()\n            if hooks:\n                print_info(f\"Webhooks for {repo_name}:\")\n                for hook in hooks:\n                    print(f\"- ID: {hook['id']}, URL: {hook['config']['url']}, Events: {hook['events']}\")\n            else:\n                print_info(f\"No webhooks found for {repo_name}.\")\n\n        elif action == \"create\":\n            data = {\n                \"name\": \"web\",\n                \"active\": True,\n                \"events\": events,\n                \"config\": {\n                    \"url\": url,\n                    \"content_type\": \"json\"\n                }\n            }\n            response = github_request(\"POST\", base_url, github_token, json=data)\n            response.raise_for_status()\n            print_success(\"Webhook created successfully!\")\n\n        elif action == \"delete\":\n            if not hook_id:\n                print_error(\"Hook ID is required for deletion.\")\n                return\n            delete_url = f\"{base_url}/{hook_id}\"\n            response = github_request(\"DELETE\", delete_url, github_token)\n            response.raise_for_status()\n            print_success(\"Webhook deleted successfully!\")\n\n    except Exception as e:\n        print_error(f\"Webhook operation failed: {e}\")"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"manage_webhooks\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "893f9c1b4076",
        "name": "extract_python_docs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "startLine": 9,
        "endLine": 62,
        "lineCount": 54,
        "parameters": [
          "content",
          "filename"
        ],
        "calls": [
          "extract_python_docs",
          "parse",
          "get_docstring",
          "append",
          "join",
          "print_warning"
        ],
        "calledBy": [
          "cdf0160ec029",
          "c50e2b3c1ae7",
          "c2cd9c47dd19"
        ],
        "complexity": 18,
        "isExported": false,
        "isAsync": false,
        "docstring": "Extract documentation from Python code using AST.",
        "body": "\ndef extract_python_docs(content, filename):\n    \"\"\"Extract documentation from Python code using AST.\"\"\"\n    docs = {\n        'module_docstring': '',\n        'functions': [],\n        'classes': [],\n        'constants': []\n    }\n    \n    try:\n        tree = ast.parse(content)\n        \n        # Module docstring\n        docs['module_docstring'] = ast.get_docstring(tree) or ''\n        \n        for node in tree.body:\n            if isinstance(node, ast.FunctionDef):\n                func_doc = ast.get_docstring(node) or ''\n                args = [arg.arg for arg in node.args.args]\n                docs['functions'].append({\n                    'name': node.name,\n                    'params': ', '.join(args),\n                    'docstring': func_doc\n                })\n            elif isinstance(node, ast.ClassDef):\n                class_doc = ast.get_docstring(node) or ''\n                bases = [base.id for base in node.bases if isinstance(base, ast.Name)]\n                class_info = {\n                    'name': node.name,\n                    'parent': ', '.join(bases) if bases else 'object',\n                    'docstring': class_doc,\n                    'methods': []\n                }\n                \n                for item in node.body:\n                    if isinstance(item, ast.FunctionDef):\n                        method_doc = ast.get_docstring(item) or ''\n                        method_args = [arg.arg for arg in item.args.args]\n                        class_info['methods'].append({\n                            'name': item.name,\n                            'params': ', '.join(method_args),\n                            'docstring': method_doc\n                        })\n                \n                docs['classes'].append(class_info)\n                \n    except SyntaxError:\n        print_warning(f\"Could not parse {filename} (SyntaxError). Skipping.\")\n    except Exception as e:\n        print_warning(f\"Error parsing {filename}: {e}\")\n    \n    return docs\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"extract_python_docs\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "09b2167e8bce",
        "name": "generate_documentation",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "startLine": 150,
        "endLine": 187,
        "lineCount": 38,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "generate_documentation",
          "print_info",
          "print_header",
          "input",
          "directory",
          "makedirs",
          "get_repo_contents",
          "print_error",
          "json",
          "search"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 14,
        "isExported": false,
        "isAsync": false,
        "docstring": "Generate documentation from code comments with styled output.",
        "body": "\ndef generate_documentation(github_username, github_token, config, args=None):\n    \"\"\"Generate documentation from code comments with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would generate documentation from code comments.\")\n        return\n\n    print_header(\"Documentation Generator\")\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    output_dir = \"docs\"\n    if args and args.output:\n        output_dir = args.output\n    else:\n        output_dir_input = input(f\"Enter output directory (default: {output_dir}): \")\n        output_dir = output_dir_input if output_dir_input else output_dir\n    \n    print_info(f\"Generating documentation for {repo_name}...\")\n    print_info(f\"Output directory: {output_dir}\")\n    \n    # Create output directory if it doesn't exist\n    os.makedirs(output_dir, exist_ok=True)\n    \n    # Get repository contents\n    try:\n        response = get_repo_contents(github_username, repo_name, github_token)\n        if response.status_code != 200:\n            print_error(f\"Error accessing repository: {response.status_code}\")\n            return\n        \n        contents = response.json()\n        doc_content = f\"# Documentation for {repo_name}\\n\\n\"\n        doc_content += '''<input type=\"text\" id=\"search-bar\" onkeyup=\"search()\" placeholder=\"Search for names..\">\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"generate_documentation\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "65c5d1c696bf",
        "name": "scan_todos",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
        "startLine": 33,
        "endLine": 129,
        "lineCount": 97,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "scan_todos",
          "print_info",
          "input",
          "patterns",
          "split",
          "get_issues",
          "json",
          "print_warning",
          "strip",
          "glob",
          "isfile",
          "open",
          "search",
          "group",
          "get_git_author",
          "get_code_context",
          "append",
          "print_success",
          "search_user_by_email",
          "get",
          "create_issue",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 39,
        "isExported": false,
        "isAsync": false,
        "docstring": "Advanced TODO scanner with Git Blame and Context support.",
        "body": "\ndef scan_todos(github_username, github_token, config, args=None):\n    \"\"\"Advanced TODO scanner with Git Blame and Context support.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: Scanning but not creating issues. ***\")\n\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    pattern_input = args.pattern if args and args.pattern else input(\"Enter file patterns (e.g., *.py,*.js) [*.py]: \")\n    file_patterns = pattern_input.split(\",\") if pattern_input else [\"*.py\"]\n    \n    print_info(f\"Scanning for TODOs in {repo_name} using patterns {file_patterns}...\")\n\n    # Fetch existing issues to avoid duplicates\n    print_info(\"Checking existing issues to prevent duplicates...\")\n    existing_titles = []\n    try:\n        issue_resp = get_issues(github_username, repo_name, github_token, state='all')\n        if issue_resp.status_code == 200:\n            existing_titles = [i['title'] for i in issue_resp.json()]\n    except Exception:\n        print_warning(\"Could not fetch existing issues. Duplicate detection disabled.\")\n\n    found_todos = []\n    for pattern in file_patterns:\n        # Clean pattern for glob\n        clean_pattern = pattern.strip()\n        for file_path in glob.glob(clean_pattern, recursive=True):\n            if os.path.isfile(file_path) and \".git\" not in file_path:\n                try:\n                    with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                        for line_num, line in enumerate(f, 1):\n                            if \"TODO\" in line:\n                                match = re.search(r'TODO:(.*)', line, re.IGNORECASE)\n                                if match:\n                                    comment = match.group(1).strip()\n                                    author = get_git_author(file_path, line_num)\n                                    context = get_code_context(file_path, line_num)\n                                    found_todos.append({\n                                        \"file\": file_path,\n                                        \"line\": line_num,\n                                        \"comment\": comment,\n                                        \"author\": author,\n                                        \"context\": context\n                                    })\n                except Exception as e:\n                    print_warning(f\"Skipping {file_path}: {e}\")\n\n    if not found_todos:\n        print_success(\"Clean sweep! No TODOs found.\")\n        return\n\n    print_info(f\"Found {len(found_todos)} TODOs. Processing...\")\n    \n    created_count = 0\n    for todo in found_todos:\n        title = f\"TODO: {todo['comment'][:50]}\" # Cap title length\n        if title in existing_titles:\n            print_warning(f\"Skipping duplicate issue: {title}\")\n            continue\n\n        body = f\"### Description\\n{todo['comment']}\\n\\n\"\n        body += f\"### Location\\n- **File:** `{todo['file']}`\\n- **Line:** {todo['line']}\\n\"\n        if todo['author']:\n            body += f\"- **Blame:** {todo['author']}\\n\"\n        \n        body += f\"\\n### Context\\n{todo['context']}\\n\\n\"\n        body += \"_Generated automatically by PyGitUp Smart Issue engine._\"\n\n        if args and args.dry_run:\n            print(f\"[DRY-RUN] Would create issue: {title}\")\n            created_count += 1\n            continue\n\n        # Real-Time Identity Resolution: Map email to actual GitHub username\n        resolved_assignees = [name.strip() for name in args.assign.split(\",\")] if args and args.assign else []\n        if todo['author']:\n            user_resp = search_user_by_email(todo['author'], github_token)\n            if user_resp.status_code == 200:\n                items = user_resp.json().get('items', [])\n                if items:\n                    gh_username = items[0]['login']\n                    if gh_username not in resolved_assignees:\n                        resolved_assignees.append(gh_username)\n                        print_info(f\"Resolved author email {todo['author']} to @{gh_username}\")\n\n        response = create_issue(github_username, repo_name, github_token, title, body, resolved_assignees)\n        if response.status_code == 201:\n            print_success(f\"Created issue: {title}\")\n            created_count += 1\n        else:\n            print_error(f\"Failed to create issue '{title}': {response.status_code}\")\n\n    print_success(f\"Operation complete. {created_count} new issues processed.\")"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"scan_todos\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "b9152e2e05f3",
        "name": "upload_single_file",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 204,
        "endLine": 277,
        "lineCount": 74,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "upload_single_file",
          "print_info",
          "get_single_file_input",
          "print_header",
          "validate_file_path",
          "print_error",
          "validate_repo_name",
          "check_is_sensitive",
          "print_warning",
          "input",
          "lower",
          "open",
          "getsize",
          "tqdm",
          "read",
          "update",
          "exit",
          "get_file_info",
          "json",
          "update_file",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 23,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handles the entire process of uploading/updating a single file.",
        "body": "\ndef upload_single_file(github_username, github_token, config, args=None):\n    \"\"\"Handles the entire process of uploading/updating a single file.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        repo_name, local_file_path, repo_file_path, commit_message = get_single_file_input(config, args)\n        print_info(f\"Would upload {local_file_path} to {repo_name}/{repo_file_path} with message: {commit_message}\")\n        return\n\n    print_header(\"Upload Single File\")\n    repo_name, local_file_path, repo_file_path, commit_message = get_single_file_input(config, args)\n\n    # Input Validation\n    is_valid_path, path_err = validate_file_path(local_file_path)\n    if not is_valid_path:\n        print_error(f\"Error: {path_err}\")\n        return False\n\n    is_valid_repo, repo_err = validate_repo_name(repo_name)\n    if not is_valid_repo:\n        print_error(f\"Error: {repo_err}\")\n        return False\n\n    if check_is_sensitive(local_file_path):\n        print_warning(f\"'{local_file_path}' appears to be a sensitive file.\")\n        confirm = input(\"Are you sure you want to upload it? (y/n): \").lower()\n        if confirm != 'y':\n            print_info(\"Upload cancelled.\")\n            return False\n\n    try:\n        with open(local_file_path, \"rb\") as f:\n            if TQDM_AVAILABLE:\n                file_size = os.path.getsize(local_file_path)\n                with tqdm(total=file_size, unit='B', unit_scale=True, desc=\"Reading file\") as pbar:\n                    content = f.read()\n                    pbar.update(len(content))\n            else:\n                content = f.read()\n    except FileNotFoundError:\n        print_error(f\"Error: The local file '{local_file_path}' was not found.\")\n        if not args or not args.batch:\n            sys.exit(1)\n        return False\n    except Exception as e:\n        print_error(f\"Error reading file: {e}\")\n        if not args or not args.batch:\n            sys.exit(1)\n        return False\n\n    sha = None\n    response = get_file_info(github_username, repo_name, repo_file_path, github_token)\n    if response.status_code == 200:\n        print_info(\"File exists in the repository. It will be overwritten.\")\n        sha = response.json()['sha']\n    elif response.status_code != 404:\n        print_error(f\"Error checking for file: {response.status_code} - {response.text}\")\n        if not args or not args.batch:\n            sys.exit(1)\n        return False\n\n    response = update_file(github_username, repo_name, repo_file_path, content, github_token, commit_message, sha)\n    if response.status_code == 201:\n        print_success(f\"Successfully created file '{repo_file_path}' in '{repo_name}'.\")\n    elif response.status_code == 200:\n        print_success(f\"Successfully updated file '{repo_file_path}' in '{repo_name}'.\")\n    else:\n        print_error(f\"Error uploading file: {response.status_code} - {response.text}\")\n        if not args or not args.batch:\n            sys.exit(1)\n        return False\n    print_info(f\"View the file at: {response.json()['content']['html_url']}\")\n    return True\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"upload_single_file\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "8aecc87cfbd7",
        "name": "upload_batch_files",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 318,
        "endLine": 381,
        "lineCount": 64,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "upload_batch_files",
          "print_info",
          "get_batch_files_input",
          "audit_files_and_prompt",
          "print_warning",
          "tqdm",
          "join",
          "basename",
          "replace",
          "open",
          "read",
          "get_file_info",
          "json",
          "update_file",
          "print_error",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 17,
        "isExported": false,
        "isAsync": false,
        "docstring": "Upload multiple files in batch with styled output.",
        "body": "\ndef upload_batch_files(github_username, github_token, config, args=None):\n    \"\"\"Upload multiple files in batch with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        files, repo_name, repo_base_path, commit_message = get_batch_files_input(config, args)\n        print_info(f\"Would upload {len(files)} files to {repo_name} in batch.\")\n        return\n\n    files, repo_name, repo_base_path, commit_message = get_batch_files_input(config, args)\n    \n    if not files:\n        return\n\n    # Security check for batch files\n    files = audit_files_and_prompt(files)\n    if not files:\n        print_warning(\"No files to upload after security check.\")\n        return\n    \n    print_info(f\"\\nUploading {len(files)} files to {repo_name}...\")\n    \n    file_iterator = tqdm(files, desc=\"Uploading files\") if TQDM_AVAILABLE else files\n    \n    success_count = 0\n    fail_count = 0\n    \n    for local_file in file_iterator:\n        try:\n            if repo_base_path:\n                repo_file_path = os.path.join(repo_base_path, os.path.basename(local_file)).replace(\"\\\\\", \"/\")\n            else:\n                repo_file_path = os.path.basename(local_file)\n            \n            # Use upload_single_file logic but adapted for batch\n            # We skip some input gathering and validation already done\n            \n            with open(local_file, \"rb\") as f:\n                content = f.read()\n            \n            sha = None\n            f_info = get_file_info(github_username, repo_name, repo_file_path, github_token)\n            if f_info.status_code == 200:\n                sha = f_info.json()['sha']\n            \n            response = update_file(github_username, repo_name, repo_file_path, content, github_token, commit_message, sha)\n            \n            if response.status_code in [200, 201]:\n                success_count += 1\n            else:\n                print_error(f\"Failed to upload {local_file}: {response.status_code}\")\n                fail_count += 1\n                if not config[\"batch\"][\"continue_on_error\"]:\n                    print_warning(\"Stopping batch upload due to error.\")\n                    break\n                    \n        except Exception as e:\n            print_error(f\"Error uploading {local_file}: {e}\")\n            fail_count += 1\n            if not config[\"batch\"][\"continue_on_error\"]:\n                break\n    \n    print_success(f\"\\nBatch upload complete: {success_count} succeeded, {fail_count} failed.\")\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"upload_batch_files\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "6b700cc8d9be",
        "name": "migrate_repository",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 472,
        "endLine": 506,
        "lineCount": 35,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "migrate_repository",
          "print_header",
          "input",
          "URL",
          "lower",
          "print_info",
          "create_or_get_github_repository",
          "mkdtemp",
          "clone",
          "run",
          "chdir",
          "GitHub",
          "print_success",
          "print_error",
          "rmtree",
          "dirname",
          "abspath"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 15,
        "isExported": false,
        "isAsync": false,
        "docstring": "Mirror a repository from any source to GitHub with full history.",
        "body": "\ndef migrate_repository(github_username, github_token, config, args=None):\n    \"\"\"Mirror a repository from any source to GitHub with full history.\"\"\"\n    print_header(\"The Great Migration Porter\")\n    \n    src_url = args.url if args and hasattr(args, 'url') and args.url else input(\"üîó Enter Source Repository URL (GitLab/Bitbucket/etc): \")\n    dest_name = args.repo if args and hasattr(args, 'repo') and args.repo else input(\"üì¶ Enter Destination GitHub Repository Name: \")\n    \n    is_private = args.private if args and hasattr(args, 'private') else input(\"üîí Make destination private? (y/n) [y]: \").lower() != 'n'\n\n    print_info(f\"Establishing destination on GitHub...\")\n    # Ensure dest exists\n    create_or_get_github_repository(dest_name, f\"Mirrored from {src_url}\", is_private, github_username, github_token)\n    \n    dest_url = f\"https://{github_username}:{github_token}@github.com/{github_username}/{dest_name}.git\"\n    \n    # Use a temporary directory for the mirror operation\n    temp_dir = tempfile.mkdtemp()\n    try:\n        print_info(\"Performing mirror clone (this may take time for large repos)...\")\n        subprocess.run([\"git\", \"clone\", \"--mirror\", src_url, temp_dir], check=True)\n        \n        os.chdir(temp_dir)\n        print_info(\"Pushing mirror to GitHub (preserving all branches/tags)...\")\n        subprocess.run([\"git\", \"push\", \"--mirror\", dest_url], check=True)\n        \n        print_success(f\"\\nMigration Successful! üöÄ\")\n        print_info(f\"View it at: https://github.com/{github_username}/{dest_name}\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Migration failed during git operation: {e}\")\n    finally:\n        # Cleanup\n        shutil.rmtree(temp_dir, ignore_errors=True)\n        os.chdir(os.path.dirname(os.path.abspath(__file__))) # Back to relative safety\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"migrate_repository\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "dcae852f2920",
        "name": "generate_ai_commit_message",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
        "startLine": 17,
        "endLine": 64,
        "lineCount": 48,
        "parameters": [
          "api_key",
          "diff_text"
        ],
        "calls": [
          "generate_ai_commit_message",
          "print_error",
          "wizard",
          "standard",
          "line",
          "post",
          "json",
          "strip",
          "startswith",
          "join",
          "splitlines"
        ],
        "calledBy": [
          "d51b6e299e0d"
        ],
        "complexity": 11,
        "isExported": false,
        "isAsync": false,
        "docstring": "Uses Gemini API to generate a professional commit message from a diff.",
        "body": "\ndef generate_ai_commit_message(api_key, diff_text):\n    \"\"\"Uses Gemini API to generate a professional commit message from a diff.\"\"\"\n    if not api_key:\n        print_error(\"Gemini API Key missing. Please run the configuration wizard (Option 14).\")\n        return None\n\n    url = f\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={api_key}\"\n    \n    prompt = f\"\"\"\n    You are an expert software engineer and git specialist. \n    Analyze the following git diff and generate a professional commit message. \n    \n    CRITICAL RULES:\n    1. Follow the Conventional Commits standard (feat:, fix:, refactor:, chore:, docs:, style:, test:).\n    2. Start with a high-level summary line (max 50 chars).\n    3. Add a blank line, then a bulleted list of specific, meaningful changes.\n    4. Focus on the WHY and the IMPACT, not just the technical details.\n    5. Do not include any other text, only the commit message itself. \n    \n    DIFF DATA:\n    {diff_text[:10000]} # Truncate to 10k chars for safety\n    \"\"\"\n\n    payload = {\n        \"contents\": [{\"parts\": [{\"text\": prompt}]}]\n    }\n\n    try:\n        response = requests.post(url, json=payload, timeout=30)\n        if response.status_code == 200:\n            data = response.json()\n            try:\n                msg = data['candidates'][0]['content']['parts'][0]['text'].strip()\n                # Clean up markdown if the AI includes it\n                if msg.startswith(\"```\"):\n                    msg = \"\\n\".join(msg.splitlines()[1:-1])\n                return msg\n            except (KeyError, IndexError):\n                print_error(\"Could not parse AI response.\")\n                return None\n        else:\n            print_error(f\"Gemini API Error: {response.status_code} - {response.text}\")\n            return None\n    except Exception as e:\n        print_error(f\"Connection failed: {e}\")\n        return None\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"generate_ai_commit_message\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "ce0d190b4a4f",
        "name": "show_banner",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/banner.py",
        "startLine": 274,
        "endLine": 293,
        "lineCount": 20,
        "parameters": [],
        "calls": [
          "show_banner",
          "system",
          "choice",
          "write",
          "flush",
          "sleep"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 6,
        "isExported": false,
        "isAsync": false,
        "docstring": "Displays a random animated banner from the collection.",
        "body": "\ndef show_banner():\n    \"\"\"Displays a random animated banner from the collection.\"\"\"\n    # Clear screen based on OS\n    os.system('cls' if os.name == 'nt' else 'clear')\n    \n    # Pick a random banner\n    banner = random.choice(BANNERS)\n    \n    # Print the ASCII art directly\n    print(banner)\n    \n    # Typewriter effect for the subtitle\n    subtitle = f\"{WHITE}>>> Effortless GitHub Workflow Automation <<<{RESET}\\n\"\n    for char in subtitle:\n        sys.stdout.write(char)\n        sys.stdout.flush()\n        time.sleep(0.01) # Slightly faster for variety\n    \n    print(\"-\" * 50)"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"show_banner\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "46b90a5decb7",
        "name": "queue_offline_commit",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
        "startLine": 9,
        "endLine": 71,
        "lineCount": 63,
        "parameters": [
          "config",
          "args"
        ],
        "calls": [
          "queue_offline_commit",
          "print_info",
          "print_header",
          "input",
          "check_is_sensitive",
          "print_warning",
          "lower",
          "now",
          "isoformat",
          "exists",
          "open",
          "load",
          "append",
          "dump",
          "print_success",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 18,
        "isExported": false,
        "isAsync": false,
        "docstring": "Queue a commit for when online with styled output.",
        "body": "\ndef queue_offline_commit(config, args=None):\n    \"\"\"Queue a commit for when online with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would queue a commit for the next online session.\")\n        return\n\n    print_header(\"Offline Commit Queue\")\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    if args and args.message:\n        commit_message = args.message\n    else:\n        commit_message = input(\"Enter commit message: \")\n    \n    if args and args.file:\n        file_path = args.file\n    else:\n        file_path = input(\"Enter file to commit: \")\n    \n    # Security check\n    if check_is_sensitive(file_path):\n        print_warning(f\"'{file_path}' appears to be a sensitive file.\")\n        confirm = input(\"Are you sure you want to queue this file for upload? (y/n): \").lower()\n        if confirm != 'y':\n            print_info(\"Queuing cancelled.\")\n            return\n    \n    # Create queue entry\n    queue_entry = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"repo\": repo_name,\n        \"message\": commit_message,\n        \"file\": file_path,\n        \"status\": \"queued\"\n    }\n    \n    # Load existing queue\n    queue_file = config[\"scheduling\"][\"offline_queue_file\"]\n    queue = []\n    if os.path.exists(queue_file):\n        try:\n            with open(queue_file, 'r') as f:\n                queue = json.load(f)\n        except Exception as e:\n            print_warning(f\"Could not load queue file: {e}\")\n    \n    # Add new entry\n    queue.append(queue_entry)\n    \n    # Save queue\n    try:\n        with open(queue_file, 'w') as f:\n            json.dump(queue, f, indent=2)\n        print_success(\"Commit queued for next online session.\")\n        print_info(f\"Queue file: {queue_file}\")\n    except Exception as e:\n        print_error(f\"Error saving queue: {e}\")\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"queue_offline_commit\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "c165c3a5a54d",
        "name": "scrape_repo_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/scraper.py",
        "startLine": 5,
        "endLine": 112,
        "lineCount": 108,
        "parameters": [
          "url"
        ],
        "calls": [
          "scrape_repo_info",
          "print_warning",
          "get",
          "BeautifulSoup",
          "strip",
          "split",
          "find",
          "get_text",
          "found",
          "endswith",
          "Unknown",
          "By",
          "find_all",
          "append"
        ],
        "calledBy": [
          "f5e6adf207a0"
        ],
        "complexity": 41,
        "isExported": false,
        "isAsync": false,
        "docstring": "Scrapes public repository information from its GitHub HTML page.\n    Returns a dictionary structure similar to the API response.",
        "body": "\ndef scrape_repo_info(url):\n    \"\"\"\n    Scrapes public repository information from its GitHub HTML page.\n    Returns a dictionary structure similar to the API response.\n    \"\"\"\n    print_warning(f\"API failed. Attempting to scrape data from {url}...\")\n    \n    try:\n        response = requests.get(url)\n        if response.status_code != 200:\n            return None\n            \n        soup = BeautifulSoup(response.text, 'html.parser')\n        data = {}\n        \n        # Extract Owner and Name\n        path_parts = url.strip(\"/\").split(\"/\")\n        if len(path_parts) >= 2:\n            data['owner'] = {'login': path_parts[-2]}\n            data['name'] = path_parts[-1]\n            data['full_name'] = f\"{path_parts[-2]}/{path_parts[-1]}\"\n            \n        # Extract Description\n        # GitHub usually puts description in 'p.f4' inside the border grid or layout\n        desc_tag = soup.find('p', class_='f4 my-3')\n        data['description'] = desc_tag.get_text(strip=True) if desc_tag else \"No description found (scraped)\"\n        \n        # Extract Stars\n        # Looking for the star count in the sidebar or header\n        # Current GitHub layout often uses a span with id 'repo-stars-counter-star' \n        # or an 'a' tag with specific href\n        star_tag = soup.find(id='repo-stars-counter-star')\n        if star_tag:\n             data['stargazers_count'] = star_tag.get('title') or star_tag.get_text(strip=True)\n        else:\n             # Fallback: finding the 'a' tag with 'stargazers' in href\n             star_link = soup.find('a', href=lambda x: x and x.endswith('/stargazers'))\n             if star_link:\n                 # The count is usually in a span inside or just the text\n                 count_span = star_link.find('span', class_='Counter')\n                 data['stargazers_count'] = count_span.get('title') if count_span else star_link.get_text(strip=True)\n             else:\n                 data['stargazers_count'] = \"N/A\"\n\n        # Extract Forks\n        fork_tag = soup.find(id='repo-network-counter')\n        if fork_tag:\n            data['forks_count'] = fork_tag.get('title') or fork_tag.get_text(strip=True)\n        else:\n             fork_link = soup.find('a', href=lambda x: x and x.endswith('/forks'))\n             if fork_link:\n                 count_span = fork_link.find('span', class_='Counter')\n                 data['forks_count'] = count_span.get('title') if count_span else fork_link.get_text(strip=True)\n             else:\n                 data['forks_count'] = \"N/A\"\n                 \n        # Extract Issues\n        issues_tab = soup.find(id='issues-tab')\n        if issues_tab:\n            count_span = issues_tab.find('span', class_='Counter')\n            data['open_issues_count'] = count_span.get('title') if count_span else \"N/A\"\n        else:\n            data['open_issues_count'] = \"N/A\"\n            \n        # Extract Language\n        # Found in the 'Languages' section of the sidebar\n        lang_header = soup.find('h2', string='Languages')\n        if lang_header:\n            # The list is usually in a ul following the header, but specific class structures vary.\n            # A common reliable pattern is finding the list of languages progress bar or the stats list.\n            # Trying to find the first language span in the sidebar stats.\n            lang_item = soup.find('span', class_='color-fg-default text-bold mr-1')\n            data['language'] = lang_item.get_text(strip=True) if lang_item else \"Unknown\"\n        else:\n             data['language'] = \"Unknown\"\n             \n        # Metadata\n        data['private'] = False # If we can scrape it publicly, it's public\n        data['clone_url'] = f\"{url}.git\"\n        data['created_at'] = \"Unknown (Scraped)\" # Hard to scrape reliably without parsing timestamps\n        \n        # OSINT: Used By (Dependents)\n        used_by_tag = soup.find('a', href=lambda x: x and '/network/dependents' in x)\n        if used_by_tag:\n            count_span = used_by_tag.find('span', class_='Counter')\n            data['used_by'] = count_span.get('title') if count_span else used_by_tag.get_text(strip=True)\n        \n        # OSINT: Sponsorship Status\n        sponsor_btn = soup.find('a', href=lambda x: x and '/sponsors/' in x)\n        data['is_sponsored'] = True if sponsor_btn else False\n\n        # OSINT: Topics/Tags\n        topics = []\n        topic_tags = soup.find_all('a', class_='topic-tag')\n        for t in topic_tags:\n            topics.append(t.get_text(strip=True))\n        data['topics'] = topics\n\n        # OSINT: Social Preview Image\n        og_image = soup.find('meta', property='og:image')\n        data['social_preview'] = og_image.get('content') if og_image else None\n        \n        return data\n        \n    except Exception as e:\n        print_warning(f\"Scraping failed: {e}\")\n        return None"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"scrape_repo_info\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "a4e88c00c9d1",
        "name": "check_is_sensitive",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "startLine": 88,
        "endLine": 118,
        "lineCount": 31,
        "parameters": [
          "file_path"
        ],
        "calls": [
          "check_is_sensitive",
          "basename",
          "exists",
          "open",
          "strip",
          "startswith",
          "fnmatch",
          "Analysis",
          "isfile",
          "getsize",
          "read",
          "splitlines",
          "split",
          "calculate_entropy"
        ],
        "calledBy": [
          "8037213f9b0d",
          "b9152e2e05f3",
          "44098917418d",
          "46b90a5decb7",
          "5ac2e130bdf5",
          "e490fdc33eb5"
        ],
        "complexity": 17,
        "isExported": false,
        "isAsync": false,
        "docstring": "Checks if a file path matches any sensitive patterns or has high entropy contents.",
        "body": "\ndef check_is_sensitive(file_path):\n    \"\"\"Checks if a file path matches any sensitive patterns or has high entropy contents.\"\"\"\n    name = os.path.basename(file_path)\n    \n    # 1. Filename Pattern Check\n    gitignore_patterns = []\n    if os.path.exists(\".gitignore\"):\n        with open(\".gitignore\", \"r\") as f:\n            gitignore_patterns = [line.strip() for line in f if line.strip() and not line.startswith(\"#\")]\n\n    all_patterns = SENSITIVE_PATTERNS + gitignore_patterns\n    for pattern in all_patterns:\n        if fnmatch.fnmatch(name, pattern) or fnmatch.fnmatch(file_path, pattern):\n            return True\n\n    # 2. Sophisticated Content Analysis (High Entropy Detection)\n    if os.path.isfile(file_path) and os.path.getsize(file_path) < 1024 * 500:\n        try:\n            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                content = f.read()\n                for line in content.splitlines():\n                    words = line.split()\n                    for word in words:\n                        if len(word) > 20 and calculate_entropy(word) > 4.5:\n                            return True\n        except Exception:\n            pass\n\n    return False\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"check_is_sensitive\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "5ac2e130bdf5",
        "name": "audit_files_and_prompt",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "startLine": 118,
        "endLine": 136,
        "lineCount": 19,
        "parameters": [
          "files"
        ],
        "calls": [
          "audit_files_and_prompt",
          "check_is_sensitive",
          "print_warning",
          "input"
        ],
        "calledBy": [
          "8aecc87cfbd7"
        ],
        "complexity": 12,
        "isExported": false,
        "isAsync": false,
        "docstring": "Scans a list of files for sensitive content.",
        "body": "\ndef audit_files_and_prompt(files):\n    \"\"\"Scans a list of files for sensitive content.\"\"\"\n    sensitive_matches = [f for f in files if check_is_sensitive(f)]\n    if not sensitive_matches:\n        return files\n\n    print_warning(f\"SECURITY WARNING: {len(sensitive_matches)} sensitive or heavy files detected!\")\n    for f in sensitive_matches[:5]:\n        print(f\" - {f}\")\n    \n    choice = input(\"\\nHow to proceed? (1: Skip them [Default], 2: Upload anyway, 3: Cancel): \") or \"1\"\n    \n    if choice == \"1\":\n        return [f for f in files if f not in sensitive_matches]\n    elif choice == \"2\":\n        return files\n    return []\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"audit_files_and_prompt\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "6e59d2e3fee0",
        "name": "display_repo_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "startLine": 70,
        "endLine": 188,
        "lineCount": 119,
        "parameters": [
          "data"
        ],
        "calls": [
          "display_repo_info",
          "grid",
          "add_column",
          "get",
          "join",
          "items",
          "add_row",
          "sum",
          "values",
          "strip",
          "Velocity",
          "Analytics",
          "Clones",
          "Views",
          "Table",
          "Panel"
        ],
        "calledBy": [
          "f5e6adf207a0"
        ],
        "complexity": 44,
        "isExported": false,
        "isAsync": false,
        "docstring": "Displays repository info in a rich panel with traffic analytics.",
        "body": "\ndef display_repo_info(data):\n    \"\"\"Displays repository info in a rich panel with traffic analytics.\"\"\"\n    grid = Table.grid(expand=True)\n    grid.add_column(justify=\"left\", style=\"cyan\", no_wrap=True)\n    grid.add_column(justify=\"left\", style=\"white\")\n\n    fields = {\n        \"Name\": data.get(\"name\"),\n        \"Owner\": data.get(\"owner\", {}).get(\"login\"),\n        \"Visibility\": \"Private\" if data.get(\"private\") else \"Public\",\n        \"Language\": data.get(\"language\"),\n        \"Stars\": str(data.get(\"stargazers_count\")),\n        \"Forks\": str(data.get(\"forks_count\")),\n        \"Issues\": f\"{data.get('open_issues_count')} open\",\n        \"Created\": data.get(\"created_at\"),\n        \"Clone URL\": data.get(\"clone_url\"),\n        \"Used By\": data.get(\"used_by\", \"0\"),\n        \"Sponsors\": \"üíñ Active\" if data.get(\"is_sponsored\") else \"None\"\n    }\n\n    if data.get(\"topics\"):\n        fields[\"Topics\"] = \", \".join(data.get(\"topics\"))\n\n    for label, value in fields.items():\n        grid.add_row(f\"{label}:\", str(value))\n\n    # OSINT: Languages Section\n    if 'osint_languages' in data and data['osint_languages']:\n        langs = data['osint_languages']\n        total_bytes = sum(langs.values())\n        lang_str = \"\"\n        for name, bytes_count in sorted(langs.items(), key=lambda x: x[1], reverse=True)[:5]:\n            percentage = (bytes_count / total_bytes) * 100\n            lang_str += f\"{name} ({percentage:.1f}%) \"\n        grid.add_row(\"Languages:\", lang_str.strip())\n\n    # OSINT: Community Profile\n    if 'osint_community' in data and data['osint_community']:\n        comm = data['osint_community']\n        grid.add_row(\"\", \"\")\n        grid.add_row(\"[bold]Community Intelligence[/bold]\", f\"Health Score: [bold green]{comm.get('health_percentage')}%[/bold green]\")\n        \n        files = comm.get('files', {})\n        readme = \"‚úÖ\" if files.get('readme') else \"‚ùå\"\n        license = \"‚úÖ\" if files.get('license') else \"‚ùå\"\n        coc = \"‚úÖ\" if files.get('code_of_conduct') else \"‚ùå\"\n        grid.add_row(\"Documentation:\", f\"README: {readme} | LICENSE: {license} | CoC: {coc}\")\n\n    # OSINT: Release Summary\n    if 'osint_release' in data and data['osint_release']:\n        rel = data['osint_release']\n        grid.add_row(\"\", \"\")\n        grid.add_row(\"[bold]Latest Intelligence[/bold]\", \"\")\n        grid.add_row(\"Version:\", f\"{rel.get('tag_name')} ({rel.get('name')})\")\n        grid.add_row(\"Released:\", rel.get('published_at', '')[:10])\n\n    # Health & Activity Section\n    if 'health' in data and data['health']:\n        health = data['health']\n        grid.add_row(\"\", \"\")\n        grid.add_row(\"[bold]Health & Activity[/bold]\", \"\")\n        \n        if 'development_velocity_days' in health:\n            grid.add_row(\"Dev Velocity (Median):\", f\"{health['development_velocity_days']} days/commit\")\n        \n        if 'activity_status' in health:\n            status_color = \"green\" if health['activity_status'] == \"Active/Bursting\" else \"white\"\n            grid.add_row(\"Activity Status:\", f\"[{status_color}]{health['activity_status']}[/{status_color}]\")\n            \n        if 'closed_issues' in health:\n            grid.add_row(\"Closed Issues:\", str(health['closed_issues']))\n            \n        if 'contributors_count' in health:\n            grid.add_row(\"Total Contributors:\", str(health['contributors_count']))\n\n    # Traffic analytics section if available\n    if 'traffic' in data and data['traffic']:\n        traffic = data['traffic']\n        grid.add_row(\"\", \"\") # Spacer\n        grid.add_row(\"[bold]Traffic Analytics (Admin Only)[/bold]\", \"\")\n\n        if 'clones' in traffic and traffic['clones'].get('clones'):\n            # Safely get the last element or use defaults\n            clones_list = traffic['clones']['clones']\n            if clones_list:\n                latest_clones = clones_list[-1]\n                grid.add_row(\"Clones (Last recorded):\", f\"{latest_clones['count']} ({latest_clones['uniques']} unique)\")\n\n        if 'views' in traffic and traffic['views'].get('views'):\n            views_list = traffic['views']['views']\n            if views_list:\n                latest_views = views_list[-1]\n                grid.add_row(\"Views (Last recorded):\", f\"{latest_views['count']} ({latest_views['uniques']} unique)\")\n\n        if 'referrers' in traffic and traffic['referrers']:\n            referrer_table = Table(title=\"Top Referrers\", box=box.SIMPLE)\n            referrer_table.add_column(\"Referrer\", style=\"cyan\")\n            referrer_table.add_column(\"Visits\", style=\"green\")\n            referrer_table.add_column(\"Unique\", style=\"yellow\")\n\n            for referrer in traffic['referrers'][:5]:\n                referrer_table.add_row(\n                    referrer['referrer'],\n                    str(referrer['count']),\n                    str(referrer['uniques'])\n                )\n            \n            grid.add_row(\"\", \"\")\n            grid.add_row(\"Traffic Sources:\", referrer_table)\n\n    panel = Panel(\n        grid,\n        title=f\"[bold]{data.get('full_name')}[/bold]\",\n        border_style=\"green\" if not data.get(\"private\") else \"red\",\n        subtitle=data.get(\"description\") or \"No description\"\n    )\n    console.print(panel)\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"display_repo_info\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "dad53122bce0",
        "name": "check_for_updates",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
        "startLine": 23,
        "endLine": 45,
        "lineCount": 23,
        "parameters": [],
        "calls": [
          "check_for_updates",
          "get",
          "splitlines",
          "split",
          "strip",
          "is_newer",
          "print_warning",
          "input",
          "lower",
          "perform_update"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 9,
        "isExported": false,
        "isAsync": false,
        "docstring": "Checks GitHub for a newer version of PyGitUp by reading the raw source.",
        "body": "\ndef check_for_updates():\n    \"\"\"Checks GitHub for a newer version of PyGitUp by reading the raw source.\"\"\"\n    try:\n        # We check the raw __init__.py because it's the most \"real-time\" source\n        response = requests.get(GITHUB_RAW_VERSION_URL, timeout=3)\n        if response.status_code == 200:\n            content = response.text\n            latest_version = \"0.0.0\"\n            for line in content.splitlines():\n                if \"__version__\" in line:\n                    latest_version = line.split(\"=\")[1].strip().strip('\"').strip(\"'\")\n                    break\n            \n            if is_newer(latest_version, __version__):\n                print_warning(f\"üöÄ A new update is available: v{latest_version} (Current: v{__version__})\")\n                confirm = input(\"Would you like to auto-update now? (y/n): \").lower()\n                if confirm == 'y':\n                    perform_update()\n    except Exception:\n        # Fail silently to not disturb the user's workflow if offline\n        pass\n"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"check_for_updates\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "ad7661271cb1",
        "name": "perform_update",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
        "startLine": 45,
        "endLine": 77,
        "lineCount": 33,
        "parameters": [],
        "calls": [
          "perform_update",
          "print_info",
          "PyGitUp",
          "abspath",
          "dirname",
          "getcwd",
          "exists",
          "join",
          "chdir",
          "run",
          "print_success",
          "exit",
          "print_error"
        ],
        "calledBy": [
          "dad53122bce0"
        ],
        "complexity": 5,
        "isExported": false,
        "isAsync": false,
        "docstring": "Executes a safe update by finding the package source and pulling.",
        "body": "\ndef perform_update():\n    \"\"\"Executes a safe update by finding the package source and pulling.\"\"\"\n    print_info(\"Initiating self-update sequence...\")\n    \n    # 1. Find the root of the PyGitUp installation\n    # pygitup/utils/update.py -> pygitup/utils -> pygitup -> PyGitUp (root)\n    try:\n        current_file_path = os.path.abspath(__file__)\n        package_root = os.path.dirname(os.path.dirname(os.path.dirname(current_file_path)))\n        \n        original_cwd = os.getcwd()\n        \n        if os.path.exists(os.path.join(package_root, \".git\")):\n            print_info(f\"Updating source at: {package_root}\")\n            os.chdir(package_root)\n            \n            # 2. Perform the pull\n            result = subprocess.run([\"git\", \"pull\", \"origin\", \"main\"], capture_output=True, text=True)\n            \n            if result.returncode == 0:\n                print_success(\"PyGitUp updated to the latest version!\")\n                print_info(\"Please restart the tool to apply changes.\")\n                os.chdir(original_cwd)\n                sys.exit(0)\n            else:\n                print_error(f\"Git Pull Failed: {result.stderr}\")\n        else:\n            print_error(\"This installation is not managed by Git. Please update manually via 'pip install --upgrade .'\")\n            \n        os.chdir(original_cwd)\n    except Exception as e:\n        print_error(f\"Update sequence failed: {e}\")"
      },
      "type": "function",
      "confidence": 1,
      "reason": "Function \"perform_update\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "3c1a6af0a676",
        "name": "my_method",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "startLine": 24,
        "endLine": 32,
        "lineCount": 9,
        "parameters": [
          "value"
        ],
        "calls": [
          "my_method"
        ],
        "calledBy": [],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "body": "\n    def my_method(self, value):\n        \\\"\\\"\\\"\n        A sample method within MyClass.\n        :param value: A value to process.\n        :return: A processed value.\n        \\\"\\\"\\\"\n        return value * 2\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"my_method\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "319deeaf08b2",
        "name": "my_function",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "startLine": 32,
        "endLine": 40,
        "lineCount": 9,
        "parameters": [
          "arg1",
          "arg2"
        ],
        "calls": [
          "my_function"
        ],
        "calledBy": [],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "body": "\ndef my_function(arg1, arg2='default'):\n    \\\"\\\"\\\"\n    A sample function outside any class.\n    :param arg1: The first argument.\n    :param arg2: The second argument with a default.\n    \\\"\\\"\\\"\n    return arg1 + arg2\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"my_function\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "ffdece382d71",
        "name": "hello_world",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
        "startLine": 5,
        "endLine": 17,
        "lineCount": 13,
        "parameters": [
          "name"
        ],
        "calls": [
          "hello_world",
          "name"
        ],
        "calledBy": [],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Print a greeting to the specified name.\n    \n    Args:\n        name (str): The name to greet\n        \n    Returns:\n        None",
        "body": "\ndef hello_world(name):\n    \"\"\"\n    Print a greeting to the specified name.\n    \n    Args:\n        name (str): The name to greet\n        \n    Returns:\n        None\n    \"\"\"\n    print(f\"Hello, {name}!\")\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"hello_world\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "8e386020b8b3",
        "name": "add_numbers",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
        "startLine": 17,
        "endLine": 30,
        "lineCount": 14,
        "parameters": [
          "a",
          "b"
        ],
        "calls": [
          "add_numbers",
          "a",
          "b"
        ],
        "calledBy": [],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Add two numbers together.\n    \n    Args:\n        a (int): First number\n        b (int): Second number\n        \n    Returns:\n        int: The sum of a and b",
        "body": "\ndef add_numbers(a, b):\n    \"\"\"\n    Add two numbers together.\n    \n    Args:\n        a (int): First number\n        b (int): Second number\n        \n    Returns:\n        int: The sum of a and b\n    \"\"\"\n    return a + b\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"add_numbers\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "843942cc1c44",
        "name": "multiply",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
        "startLine": 39,
        "endLine": 40,
        "lineCount": 2,
        "parameters": [
          "x",
          "y"
        ],
        "calls": [
          "multiply"
        ],
        "calledBy": [],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "body": "    \n    def multiply(self, x, y):"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"multiply\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "76fd775187dc",
        "name": "load_config",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "startLine": 136,
        "endLine": 138,
        "lineCount": 3,
        "parameters": [
          "config_path"
        ],
        "calls": [],
        "calledBy": [
          "cad67e0dcece",
          "900ceb8b2016",
          "d58b10bba610"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "body": "\n\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"load_config\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "4c3d0e0cf92c",
        "name": "configuration_wizard",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "startLine": 244,
        "endLine": 246,
        "lineCount": 3,
        "parameters": [
          "profile_name"
        ],
        "calls": [],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "body": "\n\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"configuration_wizard\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "78e970b9d9ad",
        "name": "cherry_pick_commit",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/cherry_pick.py",
        "startLine": 4,
        "endLine": 27,
        "lineCount": 24,
        "parameters": [
          "args"
        ],
        "calls": [
          "cherry_pick_commit",
          "print_header",
          "Text",
          "prompt",
          "print_error",
          "print_info",
          "run",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 5,
        "isExported": false,
        "isAsync": false,
        "docstring": "Cherry-pick a commit with styled output.",
        "body": "\ndef cherry_pick_commit(args):\n    \"\"\"Cherry-pick a commit with styled output.\"\"\"\n    commit_hash = args.commit_hash\n    if not commit_hash:\n        print_header(\"Cherry-Pick Commit\")\n        questions = [\n            inquirer.Text(\"commit_hash\", message=\"Enter the hash of the commit to cherry-pick\")\n        ]\n        answers = inquirer.prompt(questions)\n        commit_hash = answers[\"commit_hash\"]\n\n    if not commit_hash:\n        print_error(\"No commit hash provided. Exiting.\")\n        return\n\n    try:\n        print_info(f\"Cherry-picking commit: {commit_hash}\")\n        subprocess.run([\"git\", \"cherry-pick\", commit_hash], check=True)\n        print_success(f\"Successfully cherry-picked {commit_hash}\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"Git command failed: {e}\")\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"cherry_pick_commit\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "04ec89b8dcdb",
        "name": "github_request",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 11,
        "endLine": 36,
        "lineCount": 26,
        "parameters": [
          "method",
          "url",
          "token",
          "**kwargs"
        ],
        "calls": [
          "github_request",
          "get_github_headers",
          "update",
          "pop",
          "request",
          "get",
          "time",
          "max",
          "sleep"
        ],
        "calledBy": [
          "cae9e9daf651",
          "22799e5e935b",
          "729bde7aebfc",
          "59cce6cbf9ef",
          "f288fcba775c",
          "a05438a21c94",
          "ed46502e03e4",
          "9f5b6b9d7027",
          "304c2f42440f",
          "0be2041124b1",
          "2940e06f8c6f",
          "e598644894fc",
          "1a4cd86312dd",
          "8af97186e8e2",
          "f21215245cf7",
          "cc1f5fc47297",
          "851ca2aa04d6",
          "7aba7221be60",
          "2cc012b3cc34",
          "c05b776fcc1c",
          "4b3f28ce9e27",
          "4350d6620c0f",
          "6e8a9abe9285",
          "3007556417ad",
          "bfb968263df8",
          "f16e5c44fb5b",
          "596d2eb4e17c",
          "8037213f9b0d",
          "72913908c45b",
          "9ec31c3178f8",
          "f5e6adf207a0",
          "1d0f56ea40c1",
          "be40efbe3e80"
        ],
        "complexity": 8,
        "isExported": false,
        "isAsync": false,
        "docstring": "Centralized GitHub API request handler with rate-limiting support.",
        "body": "\ndef github_request(method, url, token, **kwargs):\n    \"\"\"Centralized GitHub API request handler with rate-limiting support.\"\"\"\n    headers = get_github_headers(token)\n    if 'headers' in kwargs:\n        headers.update(kwargs.pop('headers'))\n    \n    while True:\n        try:\n            response = requests.request(method, url, headers=headers, **kwargs)\n            \n            # Handle rate limiting\n            if response.status_code == 403 and 'X-RateLimit-Remaining' in response.headers:\n                remaining = int(response.headers.get('X-RateLimit-Remaining', 1))\n                if remaining == 0:\n                    reset_time = int(response.headers.get('X-RateLimit-Reset', time.time() + 60))\n                    sleep_duration = max(reset_time - time.time() + 1, 1)\n                    print(f\"\\n[!] Rate limit reached. Sleeping for {sleep_duration:.0f}s until reset...\")\n                    time.sleep(sleep_duration)\n                    continue\n            \n            return response\n        except requests.exceptions.RequestException as e:\n            print(f\"Request failed: {e}\")\n            raise\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"github_request\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "22799e5e935b",
        "name": "graphql_request",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 36,
        "endLine": 43,
        "lineCount": 8,
        "parameters": [
          "query",
          "variables",
          "token"
        ],
        "calls": [
          "graphql_request",
          "GraphQL",
          "github_request"
        ],
        "calledBy": [],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Execute a GitHub GraphQL (v4) API request with rate-limiting support.",
        "body": "\ndef graphql_request(query, variables, token):\n    \"\"\"Execute a GitHub GraphQL (v4) API request with rate-limiting support.\"\"\"\n    url = \"https://api.github.com/graphql\"\n    payload = {\"query\": query, \"variables\": variables}\n    # GraphQL always uses POST\n    return github_request(\"POST\", url, token, json=payload)\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"graphql_request\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "f21215245cf7",
        "name": "compare_commits",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 139,
        "endLine": 144,
        "lineCount": 6,
        "parameters": [
          "owner",
          "repo",
          "base",
          "head",
          "token"
        ],
        "calls": [
          "compare_commits",
          "github_request"
        ],
        "calledBy": [],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Compare two commits/branches/refs.",
        "body": "\ndef compare_commits(owner, repo, base, head, token):\n    \"\"\"Compare two commits/branches/refs.\"\"\"\n    url = f\"https://api.github.com/repos/{owner}/{repo}/compare/{base}...{head}\"\n    return github_request(\"GET\", url, token)\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"compare_commits\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "c05b776fcc1c",
        "name": "search_user_by_email",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 165,
        "endLine": 170,
        "lineCount": 6,
        "parameters": [
          "email",
          "token"
        ],
        "calls": [
          "search_user_by_email",
          "github_request"
        ],
        "calledBy": [
          "65c5d1c696bf"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Find a GitHub user by their email address.",
        "body": "\ndef search_user_by_email(email, token):\n    \"\"\"Find a GitHub user by their email address.\"\"\"\n    url = f\"https://api.github.com/search/users\"\n    return github_request(\"GET\", url, token, params={\"q\": f\"{email} in:email\"})\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"search_user_by_email\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "bfb968263df8",
        "name": "toggle_workflow_api",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 193,
        "endLine": 199,
        "lineCount": 7,
        "parameters": [
          "username",
          "repo_name",
          "token",
          "workflow_id",
          "enable"
        ],
        "calls": [
          "toggle_workflow_api",
          "github_request"
        ],
        "calledBy": [
          "cae9e9daf651"
        ],
        "complexity": 4,
        "isExported": false,
        "isAsync": false,
        "docstring": "Enable or disable a specific workflow.",
        "body": "\ndef toggle_workflow_api(username, repo_name, token, workflow_id, enable=True):\n    \"\"\"Enable or disable a specific workflow.\"\"\"\n    status = \"enable\" if enable else \"disable\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/actions/workflows/{workflow_id}/{status}\"\n    return github_request(\"PUT\", url, token)\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"toggle_workflow_api\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "daedf59a9872",
        "name": "open_editor",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
        "startLine": 7,
        "endLine": 23,
        "lineCount": 17,
        "parameters": [
          "initial_content"
        ],
        "calls": [
          "open_editor",
          "get",
          "NamedTemporaryFile",
          "write",
          "run",
          "open",
          "read",
          "strip",
          "exists",
          "remove"
        ],
        "calledBy": [
          "51e6ef2a0fbb"
        ],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Opens the system default editor to edit release notes.",
        "body": "\ndef open_editor(initial_content=\"\"):\n    \"\"\"Opens the system default editor to edit release notes.\"\"\"\n    editor = os.environ.get('EDITOR', 'nano')\n    with tempfile.NamedTemporaryFile(suffix=\".md\", mode='w+', delete=False) as tf:\n        tf.write(initial_content)\n        temp_path = tf.name\n    \n    try:\n        subprocess.run([editor, temp_path], check=True)\n        with open(temp_path, 'r') as f:\n            content = f.read()\n        return content.strip()\n    finally:\n        if os.path.exists(temp_path):\n            os.remove(temp_path)\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"open_editor\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "ed9e81d9ba4e",
        "name": "generate_changelog",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
        "startLine": 78,
        "endLine": 96,
        "lineCount": 19,
        "parameters": [
          "username",
          "repo_name",
          "token",
          "version"
        ],
        "calls": [
          "generate_changelog",
          "get_commit_history",
          "json",
          "split"
        ],
        "calledBy": [
          "2e314dc6c749",
          "51e6ef2a0fbb"
        ],
        "complexity": 5,
        "isExported": false,
        "isAsync": false,
        "docstring": "Generate a changelog from commit history.",
        "body": "\ndef generate_changelog(username, repo_name, token, version):\n    \"\"\"Generate a changelog from commit history.\"\"\"\n    try:\n        response = get_commit_history(username, repo_name, token)\n        if response.status_code == 200:\n            commits = response.json()\n            changelog = f\"## Changelog for {version}\\n\\n\"\n            for commit in commits[:20]:  # Last 20 commits\n                message = commit['commit']['message'].split('\\n')[0]\n                author = commit['commit']['author']['name']\n                date = commit['commit']['author']['date'][:10]\n                changelog += f\"- {message} ({author} on {date})\\n\"\n            return changelog\n        else:\n            return \"Changelog generation failed.\"\n    except Exception as e:\n        return f\"Changelog generation failed: {e}\"\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"generate_changelog\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "ac5fff938bb6",
        "name": "parse_github_url",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
        "startLine": 61,
        "endLine": 75,
        "lineCount": 15,
        "parameters": [
          "url"
        ],
        "calls": [
          "parse_github_url",
          "urlparse",
          "strip",
          "split"
        ],
        "calledBy": [
          "cad67e0dcece",
          "f5e6adf207a0"
        ],
        "complexity": 5,
        "isExported": false,
        "isAsync": false,
        "docstring": "Extract owner and repo name from a GitHub URL.",
        "body": "\ndef parse_github_url(url):\n    \"\"\"Extract owner and repo name from a GitHub URL.\"\"\"\n    try:\n        parsed = urlparse(url)\n        # Handle cases like https://github.com/owner/repo or github.com/owner/repo\n        path = parsed.path\n             \n        parts = path.strip(\"/\").split(\"/\")\n        if len(parts) >= 2:\n            return parts[0], parts[1]\n    except Exception:\n        pass\n    return None, None\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"parse_github_url\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "913449720a31",
        "name": "extract_javascript_docs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "startLine": 62,
        "endLine": 89,
        "lineCount": 28,
        "parameters": [
          "content",
          "filename"
        ],
        "calls": [
          "extract_javascript_docs",
          "n",
          "finditer",
          "groups",
          "append",
          "strip"
        ],
        "calledBy": [],
        "complexity": 4,
        "isExported": false,
        "isAsync": false,
        "docstring": "Extract documentation from JavaScript code.",
        "body": "\ndef extract_javascript_docs(content, filename):\n    \"\"\"Extract documentation from JavaScript code.\"\"\"\n    docs = {\n        'module_description': '',\n        'functions': [],\n        'classes': []\n    }\n    \n    # Extract JSDoc comments\n    jsdoc_pattern = r'/\\*\\*\\s*\\n(\\s*\\*\\s*[^\\n]*\\n)*\\s*\\*/\\s*\\n\\s*(?:function\\s+(\\w+)|class\\s+(\\w+))'\n    for match in re.finditer(jsdoc_pattern, content, re.DOTALL):\n        jsdoc, func_name, class_name = match.groups()\n        if func_name:\n            # Extract the function\n            docs['functions'].append({\n                'name': func_name,\n                'jsdoc': jsdoc.strip()\n            })\n        elif class_name:\n            # Extract the class\n            docs['classes'].append({\n                'name': class_name,\n                'jsdoc': jsdoc.strip()\n            })\n    \n    return docs\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"extract_javascript_docs\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "afdb468ca665",
        "name": "extract_go_docs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "startLine": 89,
        "endLine": 106,
        "lineCount": 18,
        "parameters": [
          "content",
          "filename"
        ],
        "calls": [
          "extract_go_docs",
          "finditer",
          "groups",
          "append",
          "strip"
        ],
        "calledBy": [],
        "complexity": 3,
        "isExported": false,
        "isAsync": false,
        "docstring": "Extract documentation from Go code.",
        "body": "\ndef extract_go_docs(content, filename):\n    \"\"\"Extract documentation from Go code.\"\"\"\n    docs = {\n        'functions': []\n    }\n\n    # Extract Go-style comments for functions\n    func_pattern = r'//\\s*(\\w+)\\s*.*\\nfunc\\s+(\\w+)\\s*\\([^)]*\\)'\n    for match in re.finditer(func_pattern, content, re.DOTALL):\n        go_doc, func_name = match.groups()\n        docs['functions'].append({\n            'name': func_name,\n            'go_doc': go_doc.strip()\n        })\n\n    return docs\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"extract_go_docs\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "17ba90ca870a",
        "name": "extract_cpp_docs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "startLine": 106,
        "endLine": 133,
        "lineCount": 28,
        "parameters": [
          "content",
          "filename"
        ],
        "calls": [
          "extract_cpp_docs",
          "n",
          "finditer",
          "groups",
          "append",
          "strip"
        ],
        "calledBy": [],
        "complexity": 5,
        "isExported": false,
        "isAsync": false,
        "docstring": "Extract documentation from C++ code.",
        "body": "\ndef extract_cpp_docs(content, filename):\n    \"\"\"Extract documentation from C++ code.\"\"\"\n    docs = {\n        'functions': [],\n        'classes': []\n    }\n\n    # Extract Doxygen-style comments for functions\n    func_pattern = r'/\\*!\\s*\\n(\\s*\\*\\s*[^\\n]*\\n)*\\s*\\*/\\s*\\n\\s*(?:[\\w\\s]+)\\s+(\\w+)\\s*\\([^)]*\\)'\n    for match in re.finditer(func_pattern, content, re.DOTALL):\n        doxygen, func_name = match.groups()\n        docs['functions'].append({\n            'name': func_name,\n            'doxygen': doxygen.strip()\n        })\n\n    # Extract Doxygen-style comments for classes\n    class_pattern = r'/\\*!\\s*\\n(\\s*\\*\\s*[^\\n]*\\n)*\\s*\\*/\\s*\\n\\s*class\\s+(\\w+)'\n    for match in re.finditer(class_pattern, content, re.DOTALL):\n        doxygen, class_name = match.groups()\n        docs['classes'].append({\n            'name': class_name,\n            'doxygen': doxygen.strip()\n        })\n\n    return docs\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"extract_cpp_docs\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "06d13057d835",
        "name": "extract_java_docs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "startLine": 133,
        "endLine": 150,
        "lineCount": 18,
        "parameters": [
          "content",
          "filename"
        ],
        "calls": [
          "extract_java_docs",
          "n",
          "finditer",
          "groups",
          "append",
          "strip"
        ],
        "calledBy": [],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Extract documentation from Java code.",
        "body": "\ndef extract_java_docs(content, filename):\n    \"\"\"Extract documentation from Java code.\"\"\"\n    docs = {\n        'classes': []\n    }\n\n    # Extract Javadoc comments\n    javadoc_pattern = r'/\\*\\*\\s*\\n(\\s*\\*\\s*[^\\n]*\\n)*\\s*\\*/\\s*\\n\\s*(?:public|private|protected)?\\s*(?:static\\s+)?(?:final\\s+)?class\\s+(\\w+)'\n    for match in re.finditer(javadoc_pattern, content, re.DOTALL):\n        javadoc, class_name = match.groups()\n        docs['classes'].append({\n            'name': class_name,\n            'javadoc': javadoc.strip()\n        })\n\n    return docs\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"extract_java_docs\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "df849b43f31d",
        "name": "initialize_git_repository",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 48,
        "endLine": 73,
        "lineCount": 26,
        "parameters": [
          "project_path"
        ],
        "calls": [
          "initialize_git_repository",
          "chdir",
          "print_info",
          "isdir",
          "run",
          "print_success",
          "print_error",
          "exit"
        ],
        "calledBy": [
          "44f568d20b70"
        ],
        "complexity": 6,
        "isExported": false,
        "isAsync": false,
        "docstring": "Initializes a git repository in the specified directory.",
        "body": "\ndef initialize_git_repository(project_path):\n    \"\"\"Initializes a git repository in the specified directory.\"\"\"\n    try:\n        os.chdir(project_path)\n        print_info(f\"Changed directory to {project_path}\")\n        if not os.path.isdir(\".git\"):\n            subprocess.run([\"git\", \"init\"], check=True)\n            print_success(\"Initialized empty Git repository.\")\n        else:\n            print_info(\"This is already a git repository.\")\n        subprocess.run([\"git\", \"add\", \".\"], check=True)\n        print_info(\"Staged all files.\")\n        status_result = subprocess.run([\"git\", \"status\", \"--porcelain\"], capture_output=True, text=True)\n        if status_result.stdout:\n             subprocess.run([\"git\", \"commit\", \"-m\", \"Initial commit\"], check=True)\n             print_success(\"Committed files.\")\n        else:\n            print_info(\"No changes to commit. Working tree clean.\")\n    except FileNotFoundError:\n        print_error(f\"Error: The directory '{project_path}' does not exist.\")\n        sys.exit(1)\n    except subprocess.CalledProcessError as e:\n        print_error(f\"An error occurred while running a git command: {e}\")\n        sys.exit(1)\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"initialize_git_repository\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "402517011038",
        "name": "push_to_github",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 88,
        "endLine": 112,
        "lineCount": 25,
        "parameters": [
          "repo_name",
          "github_username",
          "github_token"
        ],
        "calls": [
          "push_to_github",
          "run",
          "splitlines",
          "strip",
          "print_info",
          "print_success",
          "print_error",
          "exit"
        ],
        "calledBy": [
          "44f568d20b70"
        ],
        "complexity": 8,
        "isExported": false,
        "isAsync": false,
        "docstring": "Adds the remote and force pushes to the new repository.",
        "body": "\ndef push_to_github(repo_name, github_username, github_token):\n    \"\"\"Adds the remote and force pushes to the new repository.\"\"\"\n    remote_url = f\"https://{github_username}:{github_token}@github.com/{github_username}/{repo_name}.git\"\n    safe_remote_url = f\"https://github.com/{github_username}/{repo_name}.git\"\n    try:\n        result = subprocess.run([\"git\", \"remote\"], capture_output=True, text=True)\n        if \"origin\" in result.stdout.splitlines():\n            existing_url_result = subprocess.run([\"git\", \"remote\", \"get-url\", \"origin\"], capture_output=True, text=True, check=True)\n            if existing_url_result.stdout.strip() != remote_url and existing_url_result.stdout.strip() != safe_remote_url:\n                subprocess.run([\"git\", \"remote\", \"set-url\", \"origin\", remote_url], check=True)\n            else:\n                subprocess.run([\"git\", \"remote\", \"set-url\", \"origin\", remote_url], check=True)\n        else:\n            subprocess.run([\"git\", \"remote\", \"add\", \"origin\", remote_url], check=True)\n        branch_result = subprocess.run([\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"], capture_output=True, text=True, check=True)\n        if branch_result.stdout.strip() != \"main\":\n            subprocess.run([\"git\", \"branch\", \"-M\", \"main\"], check=True)\n        print_info(\"Pushing to GitHub with force...\")\n        subprocess.run([\"git\", \"push\", \"-u\", \"--force\", \"origin\", \"main\"], check=True)\n        print_success(\"Pushed to GitHub.\")\n    except subprocess.CalledProcessError as e:\n        print_error(f\"An error occurred while pushing to GitHub: {e}\")\n        sys.exit(1)\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"push_to_github\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "44f568d20b70",
        "name": "upload_project_directory",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 112,
        "endLine": 143,
        "lineCount": 32,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "upload_project_directory",
          "print_info",
          "print_header",
          "get_project_directory_input",
          "validate_file_path",
          "print_error",
          "validate_repo_name",
          "scan_directory_for_sensitive_files",
          "print_warning",
          "initialize_git_repository",
          "create_or_get_github_repository",
          "push_to_github"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 7,
        "isExported": false,
        "isAsync": false,
        "docstring": "Handles the entire process of uploading/updating a project directory.",
        "body": "\ndef upload_project_directory(github_username, github_token, config, args=None):\n    \"\"\"Handles the entire process of uploading/updating a project directory.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would initialize git repository, create/get GitHub repository, and push to GitHub.\")\n        return\n\n    print_header(\"Upload Project Directory\")\n    project_path, repo_name, repo_description, is_private = get_project_directory_input(config, args)\n    \n    # Input Validation\n    is_valid_path, path_err = validate_file_path(project_path)\n    if not is_valid_path:\n        print_error(f\"Error: {path_err}\")\n        return\n\n    is_valid_repo, repo_err = validate_repo_name(repo_name)\n    if not is_valid_repo:\n        print_error(f\"Error: {repo_err}\")\n        return\n\n    # Run security scan on the directory\n    if not scan_directory_for_sensitive_files(project_path):\n        print_warning(\"Upload cancelled due to security check.\")\n        return\n\n    initialize_git_repository(project_path)\n    create_or_get_github_repository(repo_name, repo_description, is_private, github_username, github_token)\n    push_to_github(repo_name, github_username, github_token)\n    print_info(f\"You can find your repository at: https://github.com/{github_username}/{repo_name}\")\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"upload_project_directory\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "1f4213d37548",
        "name": "manage_bulk_repositories",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 506,
        "endLine": 543,
        "lineCount": 38,
        "parameters": [
          "github_token"
        ],
        "calls": [
          "manage_bulk_repositories",
          "print_header",
          "print_info",
          "get_user_repos",
          "print_error",
          "json",
          "print_success",
          "get",
          "growth",
          "tanh",
          "max",
          "min"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 8,
        "isExported": false,
        "isAsync": false,
        "docstring": "List all repositories and show aggregated health scores.",
        "body": "\ndef manage_bulk_repositories(github_token):\n    \"\"\"List all repositories and show aggregated health scores.\"\"\"\n    print_header(\"Bulk Repository Management\")\n    print_info(\"Fetching all your repositories...\")\n    \n    try:\n        response = get_user_repos(github_token)\n        if response.status_code != 200:\n            print_error(f\"Failed to fetch repos: {response.status_code}\")\n            return\n            \n        repos = response.json()\n        print_success(f\"Found {len(repos)} repositories.\\n\")\n        \n        print(f\"{ 'Repository Name':<40} | {'Stars':<6} | {'Issues':<6} | {'Score':<6}\")\n        print(\"-\" * 65)\n        \n        import math\n        for r in repos:\n            stars = r.get('stargazers_count', 0)\n            issues = r.get('open_issues_count', 0)\n            \n            # Sophisticated Health Logic:\n            # 1. Star Weight: Logarithmic growth (tanh caps it)\n            # 2. Issue Penalty: Non-linear decay based on star-to-issue ratio\n            star_impact = math.tanh(stars / 50.0) * 70  # Max 70 points from stars\n            issue_ratio = issues / (stars + 1)\n            issue_penalty = math.tanh(issue_ratio) * 30 # Max 30 point penalty\n            \n            health_score = int(30 + star_impact - issue_penalty) # Baseline of 30\n            health_score = max(0, min(100, health_score))\n            \n            color = \"green\" if health_score > 75 else \"yellow\" if health_score > 45 else \"red\"\n            print(f\"{r['name']:<40} | {stars:<6} | {issues:<6} | [{color}]{health_score}%[/{color}]\")\n            \n    except Exception as e:\n        print_error(f\"Bulk operation failed: {e}\")"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"manage_bulk_repositories\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "7c55c44cf67b",
        "name": "generate_ai_release_notes",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
        "startLine": 64,
        "endLine": 104,
        "lineCount": 41,
        "parameters": [
          "api_key",
          "repo_name",
          "commit_history"
        ],
        "calls": [
          "generate_ai_release_notes",
          "print_error",
          "join",
          "splitlines",
          "categories",
          "post",
          "json",
          "strip"
        ],
        "calledBy": [
          "51e6ef2a0fbb"
        ],
        "complexity": 8,
        "isExported": false,
        "isAsync": false,
        "docstring": "Uses Gemini to summarize recent history into a professional release announcement.",
        "body": "\ndef generate_ai_release_notes(api_key, repo_name, commit_history):\n    \"\"\"Uses Gemini to summarize recent history into a professional release announcement.\"\"\"\n    if not api_key:\n        print_error(\"Gemini API Key missing.\")\n        return None\n\n    url = f\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={api_key}\"\n    \n    # Format history for the AI\n    history_text = \"\\n\".join([f\"- {c['commit']['message'].splitlines()[0]}\" for c in commit_history[:30]])\n    \n    prompt = f\"\"\"\n    You are a professional Product Manager. \n    Write a high-quality Release Announcement for the repository '{repo_name}' based on these recent commits:\n    \n    {history_text}\n    \n    RULES:\n    1. Start with a catchy 'What's New' or 'Highlights' section.\n    2. Group technical changes into logical categories (UI, Core, Security, etc.).\n    3. Use a professional yet exciting tone.\n    4. Keep it in clean Markdown format.\n    5. Do not include meta-text, only the release notes.\n    \"\"\"\n\n    payload = {\n        \"contents\": [{\n            \"parts\": [{\"text\": prompt}]\n        }]\n    }\n\n    try:\n        response = requests.post(url, json=payload, timeout=30)\n        if response.status_code == 200:\n            data = response.json()\n            return data['candidates'][0]['content']['parts'][0]['text'].strip()\n        return None\n    except Exception:\n        return None\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"generate_ai_release_notes\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "d51b6e299e0d",
        "name": "ai_commit_workflow",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
        "startLine": 104,
        "endLine": 146,
        "lineCount": 43,
        "parameters": [
          "github_username",
          "github_token",
          "config"
        ],
        "calls": [
          "ai_commit_workflow",
          "get",
          "get_git_diff",
          "print_warning",
          "print_info",
          "generate_ai_commit_message",
          "Panel",
          "input",
          "action",
          "run",
          "print_success",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 7,
        "isExported": false,
        "isAsync": false,
        "docstring": "Orchestrates the AI commit process.",
        "body": "\ndef ai_commit_workflow(github_username, github_token, config):\n    \"\"\"Orchestrates the AI commit process.\"\"\"\n    api_key = config[\"github\"].get(\"ai_api_key\")\n    \n    diff = get_git_diff()\n    if not diff:\n        print_warning(\"No staged changes found. Use 'git add' to stage files before AI commit.\")\n        return False\n\n    print_info(\"ü§ñ AI is analyzing your changes...\")\n    \n    message = generate_ai_commit_message(api_key, diff)\n    if not message:\n        return False\n\n    console.print(Panel(message, title=\"[bold cyan]Generated Commit Message[/bold cyan]\", border_style=\"cyan\"))\n    \n    print(\"\\n[bold]Options:[/bold]\")\n    print(\"1: [green]Accept & Commit[/green]\")\n    print(\"2: [yellow]Edit manually[/yellow]\")\n    print(\"3: [red]Cancel[/red]\")\n    \n    choice = input(\"\\nüëâ Choose an action (1-3): \")\n    \n    if choice == '1':\n        try:\n            subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n            print_success(\"Changes committed successfully!\")\n            return True\n        except Exception as e:\n            print_error(f\"Commit failed: {e}\")\n            return False\n    elif choice == '2':\n        # Simple manual edit fallback\n        manual_msg = input(\"Enter new commit message: \")\n        if manual_msg:\n            subprocess.run([\"git\", \"commit\", \"-m\", manual_msg], check=True)\n            print_success(\"Changes committed successfully!\")\n            return True\n    \n    print_info(\"Commit cancelled.\")\n    return False"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"ai_commit_workflow\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "26c995cec5f3",
        "name": "calculate_resolution_time",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
        "startLine": 8,
        "endLine": 23,
        "lineCount": 16,
        "parameters": [
          "issues"
        ],
        "calls": [
          "calculate_resolution_time",
          "get",
          "fromisoformat",
          "replace",
          "total_seconds",
          "round"
        ],
        "calledBy": [
          "be40efbe3e80"
        ],
        "complexity": 6,
        "isExported": false,
        "isAsync": false,
        "docstring": "Calculates average time to close an issue in hours.",
        "body": "\ndef calculate_resolution_time(issues):\n    \"\"\"Calculates average time to close an issue in hours.\"\"\"\n    closed_issues = [i for i in issues if i['state'] == 'closed' and i.get('closed_at')]\n    if not closed_issues:\n        return 0\n    \n    total_hours = 0\n    for issue in closed_issues:\n        created = datetime.fromisoformat(issue['created_at'].replace('Z', '+00:00'))\n        closed = datetime.fromisoformat(issue['closed_at'].replace('Z', '+00:00'))\n        duration = closed - created\n        total_hours += duration.total_seconds() / 3600\n        \n    return round(total_hours / len(closed_issues), 1)\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"calculate_resolution_time\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "e84e77973a97",
        "name": "predict_growth",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
        "startLine": 23,
        "endLine": 36,
        "lineCount": 14,
        "parameters": [
          "current_count",
          "created_at_str"
        ],
        "calls": [
          "predict_growth",
          "fromisoformat",
          "replace",
          "now"
        ],
        "calledBy": [
          "be40efbe3e80"
        ],
        "complexity": 4,
        "isExported": false,
        "isAsync": false,
        "docstring": "Simple linear projection for repository growth.",
        "body": "\ndef predict_growth(current_count, created_at_str):\n    \"\"\"Simple linear projection for repository growth.\"\"\"\n    try:\n        created_at = datetime.fromisoformat(created_at_str.replace('Z', '+00:00'))\n        days_old = (datetime.now(created_at.tzinfo) - created_at).days\n        if days_old <= 0: return current_count\n        \n        growth_rate = current_count / days_old\n        prediction_90_days = int(current_count + (growth_rate * 90))\n        return prediction_90_days\n    except Exception:\n        return current_count\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"predict_growth\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "f696ef68591b",
        "name": "export_report",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
        "startLine": 36,
        "endLine": 53,
        "lineCount": 18,
        "parameters": [
          "repo_name",
          "data",
          "format"
        ],
        "calls": [
          "export_report",
          "now",
          "strftime",
          "open",
          "dump",
          "writer",
          "writerow",
          "items",
          "print_success",
          "print_error"
        ],
        "calledBy": [
          "be40efbe3e80"
        ],
        "complexity": 5,
        "isExported": false,
        "isAsync": false,
        "docstring": "Exports analytics data to a file.",
        "body": "\ndef export_report(repo_name, data, format='json'):\n    \"\"\"Exports analytics data to a file.\"\"\"\n    filename = f\"{repo_name}_analytics_{datetime.now().strftime('%Y%m%d')}.{format}\"\n    try:\n        if format == 'json':\n            with open(filename, 'w') as f:\n                json.dump(data, f, indent=4)\n        elif format == 'csv':\n            with open(filename, 'w', newline='') as f:\n                writer = csv.writer(f)\n                writer.writerow([\"Metric\", \"Value\"])\n                for k, v in data.items():\n                    writer.writerow([k, v])\n        print_success(f\"Report exported to {filename}\")\n    except Exception as e:\n        print_error(f\"Export failed: {e}\")\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"export_report\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "be40efbe3e80",
        "name": "generate_analytics",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
        "startLine": 53,
        "endLine": 121,
        "lineCount": 69,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "generate_analytics",
          "print_header",
          "input",
          "print_info",
          "now",
          "isoformat",
          "github_request",
          "print_error",
          "json",
          "get",
          "predict_growth",
          "get_contributors",
          "Table",
          "add_column",
          "add_row",
          "get_issues",
          "calculate_resolution_time",
          "Projection",
          "lower",
          "export_report"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 10,
        "isExported": false,
        "isAsync": false,
        "docstring": "Advanced Repository Intelligence & Predictive Analytics.",
        "body": "\ndef generate_analytics(github_username, github_token, config, args=None):\n    \"\"\"Advanced Repository Intelligence & Predictive Analytics.\"\"\"\n    print_header(\"Advanced Analytics & Reporting\")\n    \n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n\n    print_info(f\"Analyzing {repo_name}...\")\n    report_data = {\"repo_name\": repo_name, \"timestamp\": datetime.now().isoformat()}\n\n    try:\n        # 1. Fetch Core Data\n        repo_resp = github_request(\"GET\", f\"https://api.github.com/repos/{github_username}/{repo_name}\", github_token)\n        if repo_resp.status_code != 200:\n            print_error(f\"Failed to fetch repo data: {repo_resp.status_code}\")\n            return\n        \n        repo_data = repo_resp.json()\n        stars = repo_data.get('stargazers_count', 0)\n        \n        # 2. Predictive Growth\n        predicted_stars = predict_growth(stars, repo_data['created_at'])\n        report_data[\"current_stars\"] = stars\n        report_data[\"predicted_stars_90d\"] = predicted_stars\n\n        # 3. Contributor Metrics\n        contrib_resp = get_contributors(github_username, repo_name, github_token)\n        if contrib_resp.status_code == 200:\n            contributors = contrib_resp.json()\n            report_data[\"contributor_count\"] = len(contributors)\n            \n            # Weighted Impact Table\n            table = Table(title=\"Contributor Performance Metrics\", box=box.DOUBLE_EDGE)\n            table.add_column(\"User\", style=\"cyan\")\n            table.add_column(\"Impact Score\", justify=\"right\", style=\"green\")\n            \n            for c in contributors[:5]:\n                # Impact = Contributions * 1.5 (Advanced weighting logic)\n                impact_score = int(c['contributions'] * 1.5)\n                table.add_row(c['login'], str(impact_score))\n            console.print(table)\n\n        # 4. Issue Resolution Analytics\n        issue_resp = get_issues(github_username, repo_name, github_token, state='all')\n        if issue_resp.status_code == 200:\n            issues = issue_resp.json()\n            avg_res_hours = calculate_resolution_time(issues)\n            report_data[\"avg_resolution_hours\"] = avg_res_hours\n            \n            res_table = Table(title=\"Predictive Maintenance\", box=box.SIMPLE)\n            res_table.add_row(\"Avg Resolution Time\", f\"{avg_res_hours} Hours\")\n            res_table.add_row(\"Growth Projection (90d)\", f\"{predicted_stars} Stars\")\n            console.print(res_table)\n\n        # 5. Dashboard Summary\n        print_info(f\"\\n[bold]Summary for {repo_name}:[/bold]\")\n        print(f\"üåü Stars: {stars} -> Predicted: {predicted_stars}\")\n        print(f\"‚è±Ô∏è  Avg Fix Time: {avg_res_hours} hrs\")\n\n        # 6. Export Prompt\n        export = input(\"\\nüíæ Export report? (json/csv/n): \").lower()\n        if export in ['json', 'csv']:\n            export_report(repo_name, report_data, export)\n\n    except Exception as e:\n        print_error(f\"Analytics engine failure: {e}\")"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"generate_analytics\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "c935af5c11fe",
        "name": "calculate_entropy",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "startLine": 23,
        "endLine": 34,
        "lineCount": 12,
        "parameters": [
          "data"
        ],
        "calls": [
          "calculate_entropy",
          "count",
          "chr",
          "log"
        ],
        "calledBy": [
          "a4e88c00c9d1"
        ],
        "complexity": 4,
        "isExported": false,
        "isAsync": false,
        "docstring": "Calculates the Shannon entropy of a string.",
        "body": "\ndef calculate_entropy(data):\n    \"\"\"Calculates the Shannon entropy of a string.\"\"\"\n    if not data:\n        return 0\n    entropy = 0\n    for x in range(256):\n        p_x = float(data.count(chr(x))) / len(data)\n        if p_x > 0:\n            entropy += - p_x * math.log(p_x, 2)\n    return entropy\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"calculate_entropy\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "e490fdc33eb5",
        "name": "scan_directory_for_sensitive_files",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "startLine": 136,
        "endLine": 158,
        "lineCount": 23,
        "parameters": [
          "directory"
        ],
        "calls": [
          "scan_directory_for_sensitive_files",
          "walk",
          "join",
          "check_is_sensitive",
          "append",
          "print_warning",
          "input",
          "open",
          "write",
          "relpath"
        ],
        "calledBy": [
          "44f568d20b70"
        ],
        "complexity": 8,
        "isExported": false,
        "isAsync": false,
        "docstring": "Scans a directory for sensitive files before git add.",
        "body": "\ndef scan_directory_for_sensitive_files(directory):\n    \"\"\"Scans a directory for sensitive files before git add.\"\"\"\n    detected = []\n    for root, dirs, files in os.walk(directory):\n        for name in dirs + files:\n            full_path = os.path.join(root, name)\n            if check_is_sensitive(full_path):\n                detected.append(full_path)\n\n    if not detected:\n        return True\n\n    print_warning(f\"Sensitive files found: {len(detected)}\")\n    choice = input(\"\\nAction? (1: Add to .gitignore, 2: Ignore warning, 3: Cancel): \")\n    \n    if choice == \"1\":\n        with open(\".gitignore\", \"a\") as f:\n            f.write(\"\\n# Added by PyGitUp Interceptor\\n\")\n            for item in detected:\n                f.write(f\"{os.path.relpath(item, directory)}\\n\")\n        return True\n    return choice == \"2\""
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"scan_directory_for_sensitive_files\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "2c296aa52879",
        "name": "print_success",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "startLine": 11,
        "endLine": 15,
        "lineCount": 5,
        "parameters": [
          "message"
        ],
        "calls": [
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece",
          "c5fcd19ff943",
          "78e970b9d9ad",
          "f1f948b57bf3",
          "c655144f401e",
          "ebb909c21ccf",
          "cae9e9daf651",
          "8037213f9b0d",
          "72913908c45b",
          "dd4bb98c5440",
          "ea6606b7620d",
          "e638d8d1a537",
          "9863eda17987",
          "9ec31c3178f8",
          "1d0f56ea40c1",
          "65c5d1c696bf",
          "df849b43f31d",
          "4ac56e6829e2",
          "402517011038",
          "b9152e2e05f3",
          "8aecc87cfbd7",
          "44098917418d",
          "6b700cc8d9be",
          "1f4213d37548",
          "d51b6e299e0d",
          "f696ef68591b",
          "46b90a5decb7",
          "d4cc0e31330b",
          "2fbf4b070b23",
          "8957cebef9b3",
          "ad7661271cb1"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Prints a success message in green.",
        "body": "\ndef print_success(message):\n    \"\"\"Prints a success message in green.\"\"\"\n    console.print(f\"[bold green]‚úî {message}[/bold green]\")\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"print_success\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "bc37dc58134c",
        "name": "print_error",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "startLine": 15,
        "endLine": 19,
        "lineCount": 5,
        "parameters": [
          "message"
        ],
        "calls": [
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece",
          "c5fcd19ff943",
          "78e970b9d9ad",
          "f1f948b57bf3",
          "c655144f401e",
          "ebb909c21ccf",
          "cae9e9daf651",
          "8037213f9b0d",
          "72913908c45b",
          "dd4bb98c5440",
          "51e6ef2a0fbb",
          "ea6606b7620d",
          "e638d8d1a537",
          "9863eda17987",
          "9ec31c3178f8",
          "f5e6adf207a0",
          "1d0f56ea40c1",
          "09b2167e8bce",
          "65c5d1c696bf",
          "df849b43f31d",
          "4ac56e6829e2",
          "402517011038",
          "44f568d20b70",
          "8cdb7133190e",
          "b9152e2e05f3",
          "b065ed988f67",
          "8aecc87cfbd7",
          "44098917418d",
          "6b700cc8d9be",
          "1f4213d37548",
          "dcae852f2920",
          "7c55c44cf67b",
          "d51b6e299e0d",
          "f696ef68591b",
          "be40efbe3e80",
          "46b90a5decb7",
          "d4cc0e31330b",
          "8957cebef9b3",
          "ad7661271cb1"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Prints an error message in red.",
        "body": "\ndef print_error(message):\n    \"\"\"Prints an error message in red.\"\"\"\n    console.print(f\"[bold red]‚úñ {message}[/bold red]\")\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"print_error\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "58f8d186c498",
        "name": "print_warning",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "startLine": 19,
        "endLine": 23,
        "lineCount": 5,
        "parameters": [
          "message"
        ],
        "calls": [
          "print_warning"
        ],
        "calledBy": [
          "f1f948b57bf3",
          "8037213f9b0d",
          "ea6606b7620d",
          "9863eda17987",
          "9ec31c3178f8",
          "f5e6adf207a0",
          "893f9c1b4076",
          "65c5d1c696bf",
          "44f568d20b70",
          "b9152e2e05f3",
          "8aecc87cfbd7",
          "44098917418d",
          "d51b6e299e0d",
          "46b90a5decb7",
          "c165c3a5a54d",
          "2fbf4b070b23",
          "8957cebef9b3",
          "5ac2e130bdf5",
          "e490fdc33eb5",
          "dad53122bce0"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Prints a warning message in yellow.",
        "body": "\ndef print_warning(message):\n    \"\"\"Prints a warning message in yellow.\"\"\"\n    console.print(f\"[bold yellow]‚ö† {message}[/bold yellow]\")\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"print_warning\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "f3de7251ed0a",
        "name": "print_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "startLine": 23,
        "endLine": 27,
        "lineCount": 5,
        "parameters": [
          "message"
        ],
        "calls": [
          "print_info"
        ],
        "calledBy": [
          "cad67e0dcece",
          "c5fcd19ff943",
          "78e970b9d9ad",
          "f1f948b57bf3",
          "c655144f401e",
          "ebb909c21ccf",
          "cae9e9daf651",
          "8037213f9b0d",
          "dd4bb98c5440",
          "51e6ef2a0fbb",
          "ea6606b7620d",
          "e638d8d1a537",
          "9863eda17987",
          "9ec31c3178f8",
          "1d0f56ea40c1",
          "09b2167e8bce",
          "65c5d1c696bf",
          "df849b43f31d",
          "4ac56e6829e2",
          "402517011038",
          "44f568d20b70",
          "8cdb7133190e",
          "b9152e2e05f3",
          "8aecc87cfbd7",
          "44098917418d",
          "6b700cc8d9be",
          "1f4213d37548",
          "d51b6e299e0d",
          "be40efbe3e80",
          "46b90a5decb7",
          "d4cc0e31330b",
          "2fbf4b070b23",
          "8957cebef9b3",
          "ad7661271cb1"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Prints an info message in blue.",
        "body": "\ndef print_info(message):\n    \"\"\"Prints an info message in blue.\"\"\"\n    console.print(f\"[bold blue]‚Ñπ {message}[/bold blue]\")\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"print_info\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "2c4e51c8e43d",
        "name": "print_header",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "startLine": 27,
        "endLine": 31,
        "lineCount": 5,
        "parameters": [
          "text"
        ],
        "calls": [
          "print_header",
          "Panel",
          "Text"
        ],
        "calledBy": [
          "cad67e0dcece",
          "c5fcd19ff943",
          "78e970b9d9ad",
          "c655144f401e",
          "ebb909c21ccf",
          "cae9e9daf651",
          "8037213f9b0d",
          "72913908c45b",
          "ea6606b7620d",
          "e638d8d1a537",
          "9863eda17987",
          "9ec31c3178f8",
          "1d0f56ea40c1",
          "09b2167e8bce",
          "44f568d20b70",
          "8cdb7133190e",
          "b9152e2e05f3",
          "b065ed988f67",
          "44098917418d",
          "6b700cc8d9be",
          "1f4213d37548",
          "be40efbe3e80",
          "46b90a5decb7",
          "d4cc0e31330b",
          "2fbf4b070b23"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Prints a styled header.",
        "body": "\ndef print_header(text):\n    \"\"\"Prints a styled header.\"\"\"\n    console.print(Panel(Text(text, justify=\"center\", style=\"bold white\"), border_style=\"blue\", expand=False))\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"print_header\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "5ca874d53204",
        "name": "display_menu",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "startLine": 42,
        "endLine": 70,
        "lineCount": 29,
        "parameters": [
          "options"
        ],
        "calls": [
          "display_menu",
          "Table",
          "add_column",
          "items",
          "category",
          "add_row"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 4,
        "isExported": false,
        "isAsync": false,
        "docstring": "Displays the main menu options in a grid.",
        "body": "\ndef display_menu(options):\n    \"\"\"Displays the main menu options in a grid.\"\"\"\n    table = Table(title=\"[bold blue]PyGitUp Main Menu[/bold blue]\", box=box.ROUNDED, show_header=True, header_style=\"bold cyan\")\n    table.add_column(\"ID\", justify=\"center\", style=\"green\", no_wrap=True)\n    table.add_column(\"Feature\", style=\"white\")\n    table.add_column(\"Category\", style=\"dim\")\n\n    categories = {\n        \"Core\": [\"project\", \"file\", \"batch\", \"template\", \"migrate\"],\n        \"Git\": [\"branch\", \"stash\", \"tag\", \"cherry-pick\", \"smart-push\"],\n        \"GitHub\": [\"release\", \"multi-repo\", \"request-review\", \"gist\", \"webhook\", \"actions\", \"pr\", \"visibility\", \"delete-repo\", \"repo-info\", \"bulk-mgmt\", \"fork-intel\"],\n        \"Tools\": [\"scan-todos\", \"offline-queue\", \"process-queue\", \"generate-docs\", \"analytics\", \"audit\", \"configure\", \"ai-commit\", \"accounts\"]\n    }\n\n    for key, value in options.items():\n        # Determine category (naive approach, could be passed in)\n        cat = \"Misc\"\n        mode_guess = value[1] # Assuming value is tuple (desc, mode)\n        \n        for c_name, c_items in categories.items():\n            if mode_guess in c_items:\n                cat = c_name\n                break\n        \n        table.add_row(key, value[0], cat)\n\n    console.print(table)\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"display_menu\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "520e12ce0f39",
        "name": "display_traffic_trends",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "startLine": 188,
        "endLine": 225,
        "lineCount": 38,
        "parameters": [
          "traffic_data"
        ],
        "calls": [
          "display_traffic_trends",
          "get",
          "Table",
          "Trends",
          "add_column",
          "add_row",
          "append",
          "Group"
        ],
        "calledBy": [
          "f5e6adf207a0"
        ],
        "complexity": 9,
        "isExported": false,
        "isAsync": false,
        "docstring": "Display traffic trends in a tabular format.",
        "body": "\ndef display_traffic_trends(traffic_data):\n    \"\"\"Display traffic trends in a tabular format.\"\"\"\n    if not traffic_data:\n        return\n\n    groups = []\n\n    if 'clones' in traffic_data and traffic_data['clones'].get('clones'):\n        clones_table = Table(title=\"Clone Trends (Last 14 Days)\", box=box.MINIMAL)\n        clones_table.add_column(\"Date\", style=\"cyan\")\n        clones_table.add_column(\"Clones\", style=\"green\")\n        clones_table.add_column(\"Unique\", style=\"yellow\")\n\n        for clone_data in traffic_data['clones']['clones']:\n            clones_table.add_row(\n                clone_data['timestamp'][:10],\n                str(clone_data['count']),\n                str(clone_data['uniques'])\n            )\n        groups.append(clones_table)\n\n    if 'views' in traffic_data and traffic_data['views'].get('views'):\n        views_table = Table(title=\"View Trends (Last 14 Days)\", box=box.MINIMAL)\n        views_table.add_column(\"Date\", style=\"cyan\")\n        views_table.add_column(\"Views\", style=\"green\")\n        views_table.add_column(\"Unique\", style=\"yellow\")\n\n        for view_data in traffic_data['views']['views']:\n            views_table.add_row(\n                view_data['timestamp'][:10],\n                str(view_data['count']),\n                str(view_data['uniques'])\n            )\n        groups.append(views_table)\n\n    if groups:\n        console.print(Group(*groups))"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"display_traffic_trends\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "3a3c89f865e0",
        "name": "is_newer",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
        "startLine": 10,
        "endLine": 23,
        "lineCount": 14,
        "parameters": [
          "latest",
          "current"
        ],
        "calls": [
          "is_newer",
          "split",
          "parts"
        ],
        "calledBy": [
          "dad53122bce0"
        ],
        "complexity": 7,
        "isExported": false,
        "isAsync": false,
        "docstring": "Simple semantic version comparison.",
        "body": "\ndef is_newer(latest, current):\n    \"\"\"Simple semantic version comparison.\"\"\"\n    try:\n        l_parts = [int(x) for x in latest.split(\".\")]\n        c_parts = [int(x) for x in current.split(\".\")]\n        # Compare parts (1.5.0 > 1.4.0)\n        for l, c in zip(l_parts, c_parts):\n            if l > c: return True\n            if l < c: return False\n        return len(l_parts) > len(c_parts)\n    except Exception:\n        return False\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"is_newer\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "02fd6a9cefdc",
        "name": "validate_repo_name",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
        "startLine": 4,
        "endLine": 20,
        "lineCount": 17,
        "parameters": [
          "name"
        ],
        "calls": [
          "validate_repo_name",
          "match",
          "long"
        ],
        "calledBy": [
          "44f568d20b70",
          "b9152e2e05f3"
        ],
        "complexity": 6,
        "isExported": false,
        "isAsync": false,
        "docstring": "Validates a GitHub repository name.\n    Rules: Only alphanumeric characters, hyphens, and underscores.",
        "body": "\ndef validate_repo_name(name):\n    \"\"\"\n    Validates a GitHub repository name.\n    Rules: Only alphanumeric characters, hyphens, and underscores.\n    \"\"\"\n    if not name:\n        return False, \"Repository name cannot be empty.\"\n    \n    if not re.match(r'^[a-zA-Z0-9\\-_.]+$', name):\n        return False, \"Invalid repository name. Use only letters, numbers, hyphens, dots, and underscores.\"\n    \n    if len(name) > 100:\n        return False, \"Repository name is too long (max 100 characters).\"\n        \n    return True, \"\"\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"validate_repo_name\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "923970dfa901",
        "name": "validate_file_path",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
        "startLine": 20,
        "endLine": 32,
        "lineCount": 13,
        "parameters": [
          "path",
          "must_exist"
        ],
        "calls": [
          "validate_file_path",
          "exists"
        ],
        "calledBy": [
          "44f568d20b70",
          "b9152e2e05f3"
        ],
        "complexity": 5,
        "isExported": false,
        "isAsync": false,
        "docstring": "Validates a local file path.",
        "body": "\ndef validate_file_path(path, must_exist=True):\n    \"\"\"\n    Validates a local file path.\n    \"\"\"\n    if not path:\n        return False, \"File path cannot be empty.\"\n    \n    if must_exist and not os.path.exists(path):\n        return False, f\"File or directory does not exist: {path}\"\n        \n    return True, \"\"\n"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"validate_file_path\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "723f41af521e",
        "name": "sanitize_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
        "startLine": 32,
        "endLine": 40,
        "lineCount": 9,
        "parameters": [
          "text"
        ],
        "calls": [
          "sanitize_input",
          "strip"
        ],
        "calledBy": [],
        "complexity": 3,
        "isExported": false,
        "isAsync": false,
        "docstring": "Basic sanitization for string inputs.\n    Removes leading/trailing whitespace.",
        "body": "\ndef sanitize_input(text):\n    \"\"\"\n    Basic sanitization for string inputs.\n    Removes leading/trailing whitespace.\n    \"\"\"\n    if text is None:\n        return \"\"\n    return str(text).strip()"
      },
      "type": "function",
      "confidence": 0.9500000000000001,
      "reason": "Function \"sanitize_input\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "8ecc4f2a4045",
        "name": "create_parser",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/args.py",
        "startLine": 3,
        "endLine": 9,
        "lineCount": 7,
        "parameters": [],
        "calls": [
          "create_parser",
          "ArgumentParser"
        ],
        "calledBy": [
          "cad67e0dcece",
          "c187ab92c4f2"
        ],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Create and configure the argument parser.",
        "body": "\ndef create_parser():\n    \"\"\"Create and configure the argument parser.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"PyGitUp - Effortless GitHub Uploads\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\""
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"create_parser\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "d65e9cd040cc",
        "name": "get_config_dir",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "startLine": 44,
        "endLine": 64,
        "lineCount": 21,
        "parameters": [],
        "calls": [
          "get_config_dir",
          "expanduser",
          "join",
          "exists",
          "makedirs"
        ],
        "calledBy": [],
        "complexity": 3,
        "isExported": false,
        "isAsync": false,
        "docstring": "Returns the platform-specific hidden directory for PyGitUp config.",
        "body": "\ndef get_config_dir():\n\n    \"\"\"Returns the platform-specific hidden directory for PyGitUp config.\"\"\"\n\n    home = os.path.expanduser(\"~\")\n\n    config_dir = os.path.join(home, \".pygitup_config\")\n\n    profiles_dir = os.path.join(config_dir, \"profiles\")\n\n    \n\n    if not os.path.exists(profiles_dir):\n\n        os.makedirs(profiles_dir, exist_ok=True)\n\n    return config_dir\n\n\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"get_config_dir\" is very likely dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "f3bb89e569dd",
        "name": "get_active_profile_path",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "startLine": 62,
        "endLine": 64,
        "lineCount": 3,
        "parameters": [],
        "calls": [],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "body": "\n\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"get_active_profile_path\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "51e6ef2a0fbb",
        "name": "get_release_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
        "startLine": 23,
        "endLine": 78,
        "lineCount": 56,
        "parameters": [
          "config",
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "get_release_input",
          "input",
          "tag",
          "name",
          "Changelog",
          "Editor",
          "print_info",
          "get_commit_history",
          "get",
          "generate_ai_release_notes",
          "json",
          "lower",
          "open_editor",
          "print_error",
          "generate_changelog"
        ],
        "calledBy": [
          "ea6606b7620d"
        ],
        "complexity": 20,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get release input from user or arguments with AI support.",
        "body": "\ndef get_release_input(config, args, github_username, github_token):\n    \"\"\"Get release input from user or arguments with AI support.\"\"\"\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    if args and args.version:\n        version = args.version\n    else:\n        version = input(\"Enter version tag (e.g., v1.0.0): \")\n    \n    if args and args.name:\n        name = args.name\n    else:\n        default_name = f\"Release {version}\"\n        name_input = input(f\"Enter release name (default: {default_name}): \")\n        name = name_input if name_input else default_name\n    \n    # Release Notes Logic\n    changelog = \"\"\n    print(\"\\n[bold]Release Notes Options:[/bold]\")\n    print(\"1: [cyan]AI-Generated Summary[/cyan]\")\n    print(\"2: [green]Auto-Changelog (Commit list)[/green]\")\n    print(\"3: [yellow]Manual Editor (Nano/Vim)[/yellow]\")\n    print(\"4: [white]Skip / Basic prompt[/white]\")\n    \n    note_choice = input(\"\\nüëâ Choice: \")\n    \n    if note_choice == '1':\n        print_info(\"ü§ñ AI is analyzing your project history...\")\n        resp = get_commit_history(github_username, repo_name, github_token)\n        if resp.status_code == 200:\n            ai_key = config[\"github\"].get(\"ai_api_key\")\n            changelog = generate_ai_release_notes(ai_key, repo_name, resp.json())\n            # Let user tweak the AI's output\n            if changelog:\n                confirm = input(\"AI notes generated. Edit them before publishing? (y/n): \").lower()\n                if confirm == 'y':\n                    changelog = open_editor(changelog)\n        else:\n            print_error(\"Failed to fetch history for AI.\")\n            \n    elif note_choice == '2':\n        changelog = generate_changelog(github_username, repo_name, github_token, version)\n    elif note_choice == '3':\n        changelog = open_editor(\"# Release Notes for \" + version + \"\\n\\n\")\n    else:\n        if args and args.message:\n            changelog = args.message\n        else:\n            changelog = input(\"Enter release notes: \")\n    \n    return repo_name, version, name, changelog\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"get_release_input\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "9863eda17987",
        "name": "delete_repository",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
        "startLine": 61,
        "endLine": 98,
        "lineCount": 38,
        "parameters": [
          "args",
          "github_username",
          "github_token"
        ],
        "calls": [
          "delete_repository",
          "print_header",
          "Text",
          "prompt",
          "print_error",
          "input",
          "print_warning",
          "print_info",
          "delete_repo_api",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 11,
        "isExported": false,
        "isAsync": false,
        "docstring": "Delete a GitHub repository with safety confirmation and styled output.",
        "body": "\ndef delete_repository(args, github_username, github_token):\n    \"\"\"Delete a GitHub repository with safety confirmation and styled output.\"\"\"\n    repo_name = args.repo if hasattr(args, 'repo') and args.repo else None\n\n    if not repo_name:\n        print_header(\"Delete Repository\")\n        questions = [inquirer.Text(\"repo\", message=\"Enter the name of the repository to DELETE\")]\n        answers = inquirer.prompt(questions)\n        repo_name = answers[\"repo\"]\n\n    if not repo_name:\n        print_error(\"Repository name is required.\")\n        return\n\n    print(\"\\n\" + \"!\" * 50)\n    print_error(f\"DANGER: You are about to PERMANENTLY DELETE '{repo_name}'\")\n    print(\"!\" * 50 + \"\\n\")\n    \n    confirmation = input(f\"To confirm, type '{repo_name}': \")\n    \n    if confirmation != repo_name:\n        print_warning(\"Verification failed. Repository deletion cancelled.\")\n        return\n\n    print_info(f\"Deleting repository '{repo_name}'...\")\n    \n    try:\n        response = delete_repo_api(github_username, repo_name, github_token)\n        \n        if response.status_code == 204:\n            print_success(f\"Successfully deleted repository '{repo_name}'.\")\n        else:\n            print_error(f\"Failed to delete repository: {response.status_code} - {response.text}\")\n            print_info(\"Note: You need 'delete_repo' scope in your token or admin access.\")\n            \n    except Exception as e:\n        print_error(f\"An error occurred: {e}\")"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"delete_repository\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "9ec31c3178f8",
        "name": "get_fork_intelligence",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
        "startLine": 6,
        "endLine": 61,
        "lineCount": 56,
        "parameters": [
          "owner",
          "repo",
          "token"
        ],
        "calls": [
          "get_fork_intelligence",
          "print_header",
          "print_info",
          "get_repo_forks",
          "print_error",
          "json",
          "github_request",
          "get",
          "print_success",
          "print_warning",
          "forks"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 16,
        "isExported": false,
        "isAsync": false,
        "docstring": "Deep scan of the Forks Network to find hidden community improvements.",
        "body": "\ndef get_fork_intelligence(owner, repo, token):\n    \"\"\"Deep scan of the Forks Network to find hidden community improvements.\"\"\"\n    print_header(\"Network & Fork Intelligence\")\n    print_info(f\"Scanning community forks for {owner}/{repo}...\")\n    \n    try:\n        forks_resp = get_repo_forks(owner, repo, token)\n        if forks_resp.status_code != 200:\n            print_error(\"Failed to fetch forks list.\")\n            return\n            \n        forks = forks_resp.json()\n        if not forks:\n            print_info(\"No forks found for this repository.\")\n            return\n            \n        print_info(f\"Analyzing {len(forks)} forks for unique activity...\")\n        \n        found_unique = False\n        for fork in forks:\n            f_owner = fork['owner']['login']\n            f_name = fork['name']\n            f_default_branch = fork['default_branch']\n            \n            print(f\"  üîç Checking @{f_owner}/{f_name} [{f_default_branch}]...\")\n            \n            # Compare the fork's default branch against the upstream's default branch\n            compare_url = f\"https://api.github.com/repos/{owner}/{repo}/compare/{owner}:{f_default_branch}...{f_owner}:{f_default_branch}\"\n            compare_resp = github_request(\"GET\", compare_url, token)\n            \n            if compare_resp.status_code == 200:\n                data = compare_resp.json()\n                ahead = data.get('ahead_by', 0)\n                behind = data.get('behind_by', 0)\n                \n                status = \"Synced\"\n                if ahead > 0 and behind > 0: status = \"Diverged\"\n                elif ahead > 0: status = \"Ahead\"\n                elif behind > 0: status = \"Behind\"\n                \n                print(f\"     ‚îî‚îÄ Status: {status} | Ahead: {ahead} | Behind: {behind}\")\n                \n                if ahead > 0:\n                    found_unique = True\n                    print_success(f\"     üåü Discovery: Unique code found in @{f_owner}!\")\n                    print(f\"        View Diff: {data.get('html_url')}\")\n            else:\n                print_warning(f\"     ‚ö†Ô∏è  Could not compare: {compare_resp.status_code}\")\n        \n        if not found_unique:\n            print_info(\"No unique community work detected in forks (all forks are in-sync or behind).\")\n            \n    except Exception as e:\n        print_error(f\"Fork intelligence scan failed: {e}\")\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"get_fork_intelligence\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "6dcebe2d9f75",
        "name": "get_repo_health_metrics",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
        "startLine": 75,
        "endLine": 122,
        "lineCount": 48,
        "parameters": [
          "username",
          "repo_name",
          "token"
        ],
        "calls": [
          "get_repo_health_metrics",
          "get_commit_history",
          "json",
          "commits",
          "fromisoformat",
          "replace",
          "total_seconds",
          "round",
          "sum",
          "get_issues",
          "get_contributors"
        ],
        "calledBy": [
          "f5e6adf207a0"
        ],
        "complexity": 13,
        "isExported": false,
        "isAsync": false,
        "docstring": "Calculate repository health metrics.",
        "body": "\ndef get_repo_health_metrics(username, repo_name, token):\n    \"\"\"Calculate repository health metrics.\"\"\"\n    metrics = {}\n\n    # Get recent commits\n    try:\n        commits_response = get_commit_history(username, repo_name, token)\n        if commits_response.status_code == 200:\n            commits = commits_response.json()\n            metrics['recent_commits'] = len(commits)\n            if commits:\n                # Calculate median time between commits (Sophisticated Velocity Math)\n                from datetime import datetime\n                dates = [datetime.fromisoformat(c['commit']['author']['date'].replace('Z', '+00:00')) \n                         for c in commits[:20]] # Last 20 commits\n                if len(dates) > 1:\n                    time_diffs = sorted([(dates[i] - dates[i+1]).total_seconds() / 86400 for i in range(len(dates)-1)])\n                    # Use median to avoid outlier skew\n                    median_days = time_diffs[len(time_diffs)//2]\n                    metrics['development_velocity_days'] = round(median_days, 2)\n                    \n                    # Burst detection: comparing last 3 to last 20\n                    recent_burst = sum(time_diffs[:3]) / 3\n                    metrics['activity_status'] = \"Active/Bursting\" if recent_burst < median_days else \"Stable\"\n    except Exception:\n        pass\n\n    # Get closed issues\n    try:\n        issues_response = get_issues(username, repo_name, token, state='closed')\n        if issues_response.status_code == 200:\n            closed_issues = issues_response.json()\n            metrics['closed_issues'] = len(closed_issues)\n    except Exception:\n        pass\n\n    # Get contributors\n    try:\n        contrib_response = get_contributors(username, repo_name, token)\n        if contrib_response.status_code == 200:\n            contributors = contrib_response.json()\n            metrics['contributors_count'] = len(contributors)\n    except Exception:\n        pass\n\n    return metrics\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"get_repo_health_metrics\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "f5e6adf207a0",
        "name": "get_detailed_repo_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
        "startLine": 122,
        "endLine": 226,
        "lineCount": 105,
        "parameters": [
          "args",
          "github_token"
        ],
        "calls": [
          "get_detailed_repo_info",
          "Text",
          "prompt",
          "parse_github_url",
          "print_error",
          "get_repo_info",
          "print_warning",
          "scrape_repo_info",
          "display_repo_info",
          "json",
          "get",
          "get_repo_languages",
          "get_community_profile",
          "get_latest_release",
          "analytics",
          "github_request",
          "get_repo_health_metrics",
          "display_traffic_trends"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 30,
        "isExported": false,
        "isAsync": false,
        "docstring": "Fetch and display comprehensive repository information with insights.",
        "body": "\ndef get_detailed_repo_info(args, github_token):\n    \"\"\"Fetch and display comprehensive repository information with insights.\"\"\"\n    url = args.url if hasattr(args, 'url') and args.url else None\n\n    if not url:\n        questions = [\n            inquirer.Text(\"url\", message=\"Enter the GitHub repository URL\")\n        ]\n        answers = inquirer.prompt(questions)\n        url = answers[\"url\"]\n\n    owner, repo_name = parse_github_url(url)\n    \n    if not owner or not repo_name:\n        print_error(\"Error: Could not parse repository owner and name from the URL.\")\n        print(\"Please ensure the URL is in the format: https://github.com/owner/repo\")\n        return\n\n    print(f\"\\nFetching comprehensive report for '{owner}/{repo_name}'...\")\n    \n    try:\n        # Get basic repo info\n        repo_response = get_repo_info(owner, repo_name, github_token)\n        if repo_response.status_code != 200:\n            print_warning(f\"API Error: {repo_response.status_code} - {repo_response.text}\")\n            print_warning(\"Attempting to fallback to HTML scraping...\")\n            \n            scraped_data = scrape_repo_info(url)\n            if scraped_data:\n                display_repo_info(scraped_data)\n                return\n            else:\n                print_error(\"Failed to fetch repository data via API and Scraping.\")\n                return\n\n        repo_data = repo_response.json()\n\n        # Hybrid Intelligence: Scrape data that API hides\n        try:\n            full_url = f\"https://github.com/{owner}/{repo_name}\"\n            scraped_intel = scrape_repo_info(full_url)\n            if scraped_intel:\n                repo_data['used_by'] = scraped_intel.get('used_by')\n                repo_data['is_sponsored'] = scraped_intel.get('is_sponsored')\n                repo_data['topics'] = scraped_intel.get('topics', [])\n                repo_data['social_preview'] = scraped_intel.get('social_preview')\n        except Exception:\n            pass\n\n        # OSINT Upgrade: Fetch deep metadata\n        try:\n            # Languages\n            lang_resp = get_repo_languages(owner, repo_name, github_token)\n            if lang_resp.status_code == 200:\n                repo_data['osint_languages'] = lang_resp.json()\n            \n            # Community Profile\n            comm_resp = get_community_profile(owner, repo_name, github_token)\n            if comm_resp.status_code == 200:\n                repo_data['osint_community'] = comm_resp.json()\n            \n            # Latest Release\n            rel_resp = get_latest_release(owner, repo_name, github_token)\n            if rel_resp.status_code == 200:\n                repo_data['osint_release'] = rel_resp.json()\n        except Exception:\n            pass\n\n        # Add traffic analytics (requires push access)\n        traffic_data = {}\n        try:\n            # Clones data\n            clones_response = github_request(\"GET\", f\"https://api.github.com/repos/{owner}/{repo_name}/traffic/clones\", github_token)\n            if clones_response.status_code == 200:\n                traffic_data['clones'] = clones_response.json()\n\n            # Views data\n            views_response = github_request(\"GET\", f\"https://api.github.com/repos/{owner}/{repo_name}/traffic/views\", github_token)\n            if views_response.status_code == 200:\n                traffic_data['views'] = views_response.json()\n\n            # Referrers data\n            referrers_response = github_request(\"GET\", f\"https://api.github.com/repos/{owner}/{repo_name}/traffic/popular/referrers\", github_token)\n            if referrers_response.status_code == 200:\n                traffic_data['referrers'] = referrers_response.json()\n\n            if traffic_data:\n                repo_data['traffic'] = traffic_data\n        except Exception as e:\n            # Silently fail for traffic data if permissions are missing, or log warning\n            pass\n\n        # Add health metrics\n        health_metrics = get_repo_health_metrics(owner, repo_name, github_token)\n        repo_data['health'] = health_metrics\n        \n        # Display comprehensive report\n        display_repo_info(repo_data)\n        \n        if 'traffic' in repo_data and repo_data['traffic']:\n            display_traffic_trends(repo_data['traffic'])\n\n    except Exception as e:\n        print_error(f\"An unexpected error occurred: {e}\")"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"get_detailed_repo_info\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "1eb3727820d9",
        "name": "get_project_directory_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 14,
        "endLine": 48,
        "lineCount": 35,
        "parameters": [
          "config",
          "args"
        ],
        "calls": [
          "get_project_directory_input",
          "input",
          "repository",
          "lower"
        ],
        "calledBy": [
          "44f568d20b70"
        ],
        "complexity": 17,
        "isExported": false,
        "isAsync": false,
        "docstring": "Gets user input for the project upload details.",
        "body": "\ndef get_project_directory_input(config, args=None):\n    \"\"\"Gets user input for the project upload details.\"\"\"\n    if args and args.path:\n        project_path = args.path\n    else:\n        project_path = input(\"Enter the full path to your project directory: \")\n    \n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter the desired name for your GitHub repository: \")\n    \n    if args and args.description is not None:\n        repo_description = args.description\n    else:\n        default_desc = config[\"github\"][\"default_description\"]\n        repo_description = input(f\"Enter a description for your repository (default: {default_desc}): \")\n        if not repo_description:\n            repo_description = default_desc\n    \n    if args and args.private is not None:\n        is_private = args.private\n    else:\n        default_private = config[\"github\"][\"default_private\"]\n        is_private_input = input(f\"Make the repository private? (y/n, default: {'y' if default_private else 'n'}): \").lower()\n        if is_private_input in ['y', 'yes']:\n            is_private = True\n        elif is_private_input in ['n', 'no']:\n            is_private = False\n        else:\n            is_private = default_private\n\n    return project_path, repo_name, repo_description, is_private\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"get_project_directory_input\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "8cdb7133190e",
        "name": "get_single_file_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 143,
        "endLine": 204,
        "lineCount": 62,
        "parameters": [
          "config",
          "args"
        ],
        "calls": [
          "get_single_file_input",
          "input",
          "print_info",
          "print_header",
          "getcwd",
          "listdir",
          "isfile",
          "print_error",
          "interactively",
          "repository",
          "message"
        ],
        "calledBy": [
          "b9152e2e05f3"
        ],
        "complexity": 21,
        "isExported": false,
        "isAsync": false,
        "docstring": "Gets user input for the file upload details.",
        "body": "\ndef get_single_file_input(config, args=None):\n    \"\"\"Gets user input for the file upload details.\"\"\"\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter the name of the target GitHub repository: \")\n\n    if args and args.file:\n        local_file_path = args.file\n        print_info(f\"Selected file: {local_file_path}\")\n    else:\n        print_header(\"Select a file to upload\")\n        local_file_path = None\n        try:\n            current_directory = os.getcwd()\n            print_info(f\"Listing files in: {current_directory}\")\n            \n            files = [item for item in os.listdir('.') if os.path.isfile(item)]\n\n            if not files:\n                print_info(\"No files found in the current directory.\")\n            else:\n                for i, filename in enumerate(files):\n                    print(f\"{i + 1}: {filename}\")\n                \n                print(\"\\nEnter the number of the file to upload, or type a different path manually.\")\n                choice = input(\"> \")\n\n                try:\n                    file_index = int(choice) - 1\n                    if 0 <= file_index < len(files):\n                        local_file_path = files[file_index]\n                        print_info(f\"You selected: {local_file_path}\")\n                    else:\n                        print_error(\"Invalid number.\")\n                except ValueError:\n                    local_file_path = choice\n                    print_info(f\"You entered path: {local_file_path}\")\n\n        except Exception as e:\n            print_error(f\"Could not list files interactively ({e}).\")\n\n    if not local_file_path:\n        print_info(\"Please provide the file path manually.\")\n        local_file_path = input(\"Enter the full local path of the file to upload: \")\n\n    if args and args.path:\n        repo_file_path = args.path\n    else:\n        repo_file_path = input(\"Enter the path for the file in the repository (e.g., folder/file.txt): \")\n\n    if args and args.message:\n        commit_message = args.message\n    else:\n        default_msg = config[\"defaults\"][\"commit_message\"]\n        commit_message = input(f\"Enter the commit message (default: {default_msg}): \")\n        if not commit_message:\n            commit_message = default_msg\n\n    return repo_name, local_file_path, repo_file_path, commit_message\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"get_single_file_input\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "b065ed988f67",
        "name": "get_batch_files_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 277,
        "endLine": 318,
        "lineCount": 42,
        "parameters": [
          "config",
          "args"
        ],
        "calls": [
          "get_batch_files_input",
          "strip",
          "split",
          "print_header",
          "input",
          "lower",
          "listdir",
          "isfile",
          "print_error",
          "repository",
          "message"
        ],
        "calledBy": [
          "8aecc87cfbd7"
        ],
        "complexity": 22,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get files for batch upload.",
        "body": "\ndef get_batch_files_input(config, args=None):\n    \"\"\"Get files for batch upload.\"\"\"\n    if args and args.files:\n        files = [f.strip() for f in args.files.split(',') if f.strip()]\n    else:\n        print_header(\"Select files for batch upload\")\n        print(\"Enter file paths separated by commas, or 'all' for all files in directory:\")\n        files_input = input(\"> \").strip()\n        \n        if files_input.lower() == 'all':\n            files = [item for item in os.listdir('.') if os.path.isfile(item)]\n        else:\n            files = [f.strip() for f in files_input.split(',') if f.strip()]\n    \n    if not files:\n        print_error(\"No files specified.\")\n        return None, None, None, None\n    \n    repo_name = None\n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter the name of the target GitHub repository: \")\n    \n    repo_base_path = \"\"\n    if args and args.path:\n        repo_base_path = args.path\n    else:\n        repo_base_path = input(\"Enter base path in repository (optional, e.g., src/): \")\n    \n    default_msg = config[\"defaults\"][\"commit_message\"]\n    commit_message = \"\"\n    if args and args.message:\n        commit_message = args.message\n    else:\n        commit_message = input(f\"Enter the commit message (default: {default_msg}): \")\n        if not commit_message:\n            commit_message = default_msg\n    \n    return files, repo_name, repo_base_path, commit_message\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"get_batch_files_input\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "985fa21cb145",
        "name": "get_multi_repo_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 381,
        "endLine": 408,
        "lineCount": 28,
        "parameters": [
          "config",
          "args"
        ],
        "calls": [
          "get_multi_repo_input",
          "strip",
          "split",
          "input",
          "message"
        ],
        "calledBy": [
          "44098917418d"
        ],
        "complexity": 13,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get multi-repository input.",
        "body": "\ndef get_multi_repo_input(config, args=None):\n    \"\"\"Get multi-repository input.\"\"\"\n    if args and args.multi_repo:\n        repo_names = [name.strip() for name in args.multi_repo.split(\",\")]\n    else:\n        repo_input = input(\"Enter repository names separated by commas: \")\n        repo_names = [name.strip() for name in repo_input.split(\",\")]\n    \n    if args and args.file:\n        file_path = args.file\n    else:\n        file_path = input(\"Enter local file to upload: \")\n    \n    if args and args.path:\n        repo_file_path = args.path\n    else:\n        repo_file_path = input(\"Enter repository file path: \")\n    \n    if args and args.message:\n        commit_message = args.message\n    else:\n        default_msg = config[\"defaults\"][\"commit_message\"]\n        msg_input = input(f\"Enter commit message (default: {default_msg}): \")\n        commit_message = msg_input if msg_input else default_msg\n    \n    return repo_names, file_path, repo_file_path, commit_message\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"get_multi_repo_input\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "44098917418d",
        "name": "update_multiple_repos",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 408,
        "endLine": 468,
        "lineCount": 61,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "update_multiple_repos",
          "print_info",
          "get_multi_repo_input",
          "print_header",
          "check_is_sensitive",
          "print_warning",
          "input",
          "lower",
          "exists",
          "print_error",
          "open",
          "read",
          "get_file_info",
          "json",
          "get",
          "update_file",
          "print_success"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 14,
        "isExported": false,
        "isAsync": false,
        "docstring": "Update the same file across multiple repositories with styled output.",
        "body": "\ndef update_multiple_repos(github_username, github_token, config, args=None):\n    \"\"\"Update the same file across multiple repositories with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        repo_names, file_path, repo_file_path, commit_message = get_multi_repo_input(config, args)\n        print_info(f\"Would update {file_path} in {len(repo_names)} repositories.\")\n        return\n\n    print_header(\"Multi-Repository Update\")\n    repo_names, file_path, repo_file_path, commit_message = get_multi_repo_input(config, args)\n    \n    # Security check\n    if check_is_sensitive(file_path):\n        print_warning(f\"'{file_path}' appears to be a sensitive file.\")\n        confirm = input(\"Are you sure you want to update this file across multiple repositories? (y/n): \").lower()\n        if confirm != 'y':\n            print_info(\"Multi-repo update cancelled.\")\n            return\n\n    # Filter out any empty repository names that might result from trailing commas\n    repo_names = [name for name in repo_names if name]\n\n    if not os.path.exists(file_path):\n        print_error(f\"File '{file_path}' not found.\")\n        return\n    \n    print_info(f\"Updating {file_path} in {len(repo_names)} repositories...\")\n    \n    try:\n        with open(file_path, \"rb\") as f:\n            file_content = f.read()\n    except Exception as e:\n        print_error(f\"Error reading file: {e}\")\n        return\n    \n    success_count = 0\n    for repo_name in repo_names:\n        try:\n            # Check if file exists to get SHA\n            response = get_file_info(github_username, repo_name, repo_file_path, github_token)\n            sha = None\n            if response.status_code == 200:\n                sha = response.json().get('sha')\n            \n            # Update file\n            update_response = update_file(\n                github_username, repo_name, repo_file_path,\n                file_content, github_token, commit_message, sha\n            )\n            \n            if update_response.status_code in [200, 201]:\n                print_success(f\"Updated {repo_file_path} in {repo_name}\")\n                success_count += 1\n            else:\n                print_error(f\"Failed to update {repo_file_path} in {repo_name}: {update_response.status_code}\")\n        except Exception as e:\n            print_error(f\"Error updating {repo_name}: {e}\")\n    \n    print_success(f\"Multi-repository update complete: {success_count}/{len(repo_names)} successful.\")\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"update_multiple_repos\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "09ae5dd659db",
        "name": "get_template_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
        "startLine": 77,
        "endLine": 116,
        "lineCount": 40,
        "parameters": [
          "config",
          "args"
        ],
        "calls": [
          "get_template_input",
          "keys",
          "input",
          "split",
          "strip",
          "get_github_username"
        ],
        "calledBy": [
          "3831ab37da60"
        ],
        "complexity": 15,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get template input from user or arguments.",
        "body": "\ndef get_template_input(config, args=None):\n    \"\"\"Get template input from user or arguments.\"\"\"\n    if args and args.template:\n        template_name = args.template\n    else:\n        print(\"\\n--- Available Templates ---\")\n        for template in DEFAULT_TEMPLATES.keys():\n            print(f\"- {template}\")\n        template_name = input(\"Enter template name: \")\n    \n    if template_name not in DEFAULT_TEMPLATES:\n        print(f\"Template '{template_name}' not found.\")\n        return None, None, None, None\n    \n    if args and args.repo:\n        repo_name = args.repo\n    else:\n        repo_name = input(\"Enter repository name: \")\n    \n    # Get variables\n    variables = {}\n    if args and args.variables:\n        # Parse variables from command line\n        var_pairs = args.variables.split(\",\")\n        for pair in var_pairs:\n            if \"=\" in pair:\n                key, value = pair.split(\"=\", 1)\n                variables[key.strip()] = value.strip()\n    \n    # Default variables\n    if \"PROJECT_NAME\" not in variables:\n        variables[\"PROJECT_NAME\"] = repo_name\n    if \"DESCRIPTION\" not in variables:\n        variables[\"DESCRIPTION\"] = \"Project created with PyGitUp template\"\n    if \"AUTHOR\" not in variables:\n        variables[\"AUTHOR\"] = get_github_username(config)\n    \n    return template_name, repo_name, variables, DEFAULT_TEMPLATES[template_name]\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"get_template_input\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "3831ab37da60",
        "name": "create_project_from_template",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
        "startLine": 116,
        "endLine": 166,
        "lineCount": 51,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "create_project_from_template",
          "get_template_input",
          "create_repo",
          "get",
          "items",
          "replace",
          "update_file",
          "encode"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 11,
        "isExported": false,
        "isAsync": false,
        "docstring": "Create a new project from a template.",
        "body": "\ndef create_project_from_template(github_username, github_token, config, args=None):\n    \"\"\"Create a new project from a template.\"\"\"\n    if args and args.dry_run:\n        print(\"*** Dry Run Mode: No changes will be made. ***\")\n        template_name, repo_name, variables, template = get_template_input(config, args)\n        print(f\"Would create project '{repo_name}' from template '{template_name}'.\")\n        return\n\n    template_name, repo_name, variables, template = get_template_input(config, args)\n    \n    if not template_name:\n        return\n    \n    print(f\"Creating project '{repo_name}' from template '{template_name}'...\")\n    \n    # Create repository first\n    response = create_repo(\n        github_username, repo_name, github_token,\n        description=variables.get(\"DESCRIPTION\", \"\"),\n        private=args.private if args and hasattr(args, 'private') else False\n    )\n    \n    if response.status_code not in [201, 200]:\n        print(f\"Error creating repository: {response.status_code} - {response.text}\")\n        return\n    \n    print(f\"Repository '{repo_name}' created successfully.\")\n    \n    # Create files from template\n    success_count = 0\n    for file_name, file_content in template[\"files\"].items():\n        # Replace variables in file content\n        for var_name, var_value in variables.items():\n            file_content = file_content.replace(f\"{{{{{var_name}}}}}\", var_value)\n        \n        # Upload file\n        file_response = update_file(\n            github_username, repo_name, file_name,\n            file_content.encode('utf-8'), github_token,\n            f\"Initial commit: {file_name}\"\n        )\n        \n        if file_response.status_code in [201, 200]:\n            print(f\"Created file: {file_name}\")\n            success_count += 1\n        else:\n            print(f\"Error creating file {file_name}: {file_response.status_code}\")\n    \n    print(f\"Template project created with {success_count} files.\")\n    print(f\"View your repository at: https://github.com/{github_username}/{repo_name}\")"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"create_project_from_template\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "75c3cb0106cd",
        "name": "get_git_diff",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
        "startLine": 6,
        "endLine": 17,
        "lineCount": 12,
        "parameters": [],
        "calls": [
          "get_git_diff",
          "run",
          "strip"
        ],
        "calledBy": [
          "d51b6e299e0d"
        ],
        "complexity": 4,
        "isExported": false,
        "isAsync": false,
        "docstring": "Extract the staged git diff.",
        "body": "\ndef get_git_diff():\n    \"\"\"Extract the staged git diff.\"\"\"\n    try:\n        # Check if there are staged changes\n        result = subprocess.run([\"git\", \"diff\", \"--cached\"], capture_output=True, text=True, check=True)\n        if not result.stdout.strip():\n            return None\n        return result.stdout\n    except subprocess.CalledProcessError:\n        return None\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"get_git_diff\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "d4cc0e31330b",
        "name": "process_offline_queue",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
        "startLine": 71,
        "endLine": 145,
        "lineCount": 75,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "process_offline_queue",
          "print_info",
          "exists",
          "open",
          "load",
          "print_error",
          "print_header",
          "read",
          "update_file",
          "now",
          "isoformat",
          "print_success",
          "dump"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 21,
        "isExported": false,
        "isAsync": false,
        "docstring": "Process queued commits when online with styled output.",
        "body": "\ndef process_offline_queue(github_username, github_token, config, args=None):\n    \"\"\"Process queued commits when online with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        print_info(\"Would process the offline commit queue.\")\n        return\n\n    queue_file = config[\"scheduling\"][\"offline_queue_file\"]\n    \n    if not os.path.exists(queue_file):\n        # Silently return if no queue file exists, unless manually triggered\n        if args and args.mode == \"process-queue\":\n            print_info(\"No offline queue found.\")\n        return\n    \n    try:\n        with open(queue_file, 'r') as f:\n            queue = json.load(f)\n    except Exception as e:\n        print_error(f\"Error loading queue: {e}\")\n        return\n    \n    if not queue:\n        if args and args.mode == \"process-queue\":\n            print_info(\"Offline queue is empty.\")\n        return\n    \n    # Filter for queued entries\n    queued_entries = [e for e in queue if e[\"status\"] == \"queued\"]\n    if not queued_entries:\n        return\n\n    print_header(\"Processing Offline Queue\")\n    print_info(f\"Processing {len(queued_entries)} queued commits...\")\n    \n    processed = 0\n    for entry in queue:\n        if entry[\"status\"] == \"queued\":\n            try:\n                # Read file content\n                if not os.path.exists(entry[\"file\"]):\n                    print_error(f\"File not found: {entry['file']}. Skipping.\")\n                    entry[\"status\"] = \"failed\"\n                    entry[\"error\"] = \"File not found\"\n                    continue\n\n                with open(entry[\"file\"], \"rb\") as f:\n                    file_content = f.read()\n                \n                # Upload file\n                response = update_file(\n                    github_username, entry[\"repo\"], entry[\"file\"],\n                    file_content, github_token, entry[\"message\"]\n                )\n                \n                if response.status_code in [200, 201]:\n                    entry[\"status\"] = \"completed\"\n                    entry[\"processed_at\"] = datetime.now().isoformat()\n                    print_success(f\"Processed: {entry['message']}\")\n                    processed += 1\n                else:\n                    print_error(f\"Failed: {entry['message']} - {response.status_code}\")\n                    entry[\"error\"] = response.text\n            except Exception as e:\n                print_error(f\"Error processing: {entry['message']} - {e}\")\n                entry[\"error\"] = str(e)\n    \n    # Save updated queue\n    try:\n        with open(queue_file, 'w') as f:\n            json.dump(queue, f, indent=2)\n        print_success(f\"Processed {processed} commits from queue.\")\n    except Exception as e:\n        print_error(f\"Error saving updated queue: {e}\")"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"process_offline_queue\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "8957cebef9b3",
        "name": "run_advanced_security_scan",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "startLine": 54,
        "endLine": 88,
        "lineCount": 35,
        "parameters": [
          "username",
          "repo_name",
          "token"
        ],
        "calls": [
          "run_advanced_security_scan",
          "print_info",
          "get_dependabot_alerts",
          "json",
          "print_error",
          "print_success",
          "get_secret_scanning_alerts",
          "print_warning"
        ],
        "calledBy": [
          "2fbf4b070b23"
        ],
        "complexity": 16,
        "isExported": false,
        "isAsync": false,
        "docstring": "Deep vulnerability scanning using GitHub's security APIs.",
        "body": "\ndef run_advanced_security_scan(username, repo_name, token):\n    \"\"\"Deep vulnerability scanning using GitHub's security APIs.\"\"\"\n    print_info(f\"Fetching GitHub Security Alerts for {repo_name}...\")\n    \n    try:\n        # Dependabot\n        dep_resp = get_dependabot_alerts(username, repo_name, token)\n        if dep_resp.status_code == 200:\n            alerts = dep_resp.json()\n            open_alerts = [a for a in alerts if a['state'] == 'open']\n            if open_alerts:\n                print_error(f\"Found {len(open_alerts)} OPEN Dependabot vulnerabilities!\")\n                for a in open_alerts[:3]:\n                    print(f\" - {a['security_advisory']['summary']} ({a['security_advisory']['severity']})\")\n            else:\n                print_success(\"No open Dependabot alerts found.\")\n        \n        # Secret Scanning\n        sec_resp = get_secret_scanning_alerts(username, repo_name, token)\n        if sec_resp.status_code == 200:\n            secrets = sec_resp.json()\n            open_secrets = [s for s in secrets if s['state'] == 'open']\n            if open_secrets:\n                print_error(f\"ALERT: {len(open_secrets)} LEAKED SECRETS detected in repo history!\")\n                for s in open_secrets:\n                    print(f\" - Type: {s['secret_type']} at {s['html_url']}\")\n            else:\n                print_success(\"No leaked secrets detected.\")\n        elif sec_resp.status_code == 404:\n            print_info(\"Secret scanning is not enabled or not supported for this repo.\")\n\n    except Exception as e:\n        print_warning(f\"Advanced security scan failed: {e}\")\n"
      },
      "type": "function",
      "confidence": 0.9000000000000001,
      "reason": "Function \"run_advanced_security_scan\" is very likely dead code: not exported."
    },
    {
      "item": {
        "id": "2b972eff3796",
        "name": "set_active_profile",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "startLine": 94,
        "endLine": 96,
        "lineCount": 3,
        "parameters": [
          "profile_name"
        ],
        "calls": [],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "body": "\n\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"set_active_profile\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "4c6a9058fc9b",
        "name": "get_github_token",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "startLine": 178,
        "endLine": 180,
        "lineCount": 3,
        "parameters": [
          "config"
        ],
        "calls": [],
        "calledBy": [
          "cad67e0dcece",
          "918666a425f8",
          "86b1d0cf1c48"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "body": "\n\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_github_token\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "a647d0933dd8",
        "name": "get_github_username",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "startLine": 222,
        "endLine": 224,
        "lineCount": 3,
        "parameters": [
          "config"
        ],
        "calls": [],
        "calledBy": [
          "cad67e0dcece",
          "a4a0df0df6d3",
          "f12bbe815d45",
          "09ae5dd659db"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "body": "\n\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_github_username\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "ae53fa12588e",
        "name": "get_github_headers",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 4,
        "endLine": 11,
        "lineCount": 8,
        "parameters": [
          "token"
        ],
        "calls": [
          "get_github_headers"
        ],
        "calledBy": [
          "04ec89b8dcdb"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Create standard GitHub API headers.",
        "body": "\ndef get_github_headers(token):\n    \"\"\"Create standard GitHub API headers.\"\"\"\n    return {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_github_headers\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "729bde7aebfc",
        "name": "get_repo_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 43,
        "endLine": 48,
        "lineCount": 6,
        "parameters": [
          "username",
          "repo_name",
          "token"
        ],
        "calls": [
          "get_repo_info",
          "github_request"
        ],
        "calledBy": [
          "cd26c0773f45",
          "f5e6adf207a0",
          "4ac56e6829e2"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get repository information.",
        "body": "\ndef get_repo_info(username, repo_name, token):\n    \"\"\"Get repository information.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}\"\n    return github_request(\"GET\", url, token)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_repo_info\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "59cce6cbf9ef",
        "name": "create_repo",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 48,
        "endLine": 58,
        "lineCount": 11,
        "parameters": [
          "username",
          "repo_name",
          "token",
          "description",
          "private"
        ],
        "calls": [
          "create_repo",
          "github_request"
        ],
        "calledBy": [
          "ea310d7744bd",
          "4ac56e6829e2",
          "3831ab37da60"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Create a new GitHub repository.",
        "body": "\ndef create_repo(username, repo_name, token, description=\"\", private=False):\n    \"\"\"Create a new GitHub repository.\"\"\"\n    url = \"https://api.github.com/user/repos\"\n    data = {\n        \"name\": repo_name,\n        \"description\": description,\n        \"private\": private\n    }\n    return github_request(\"POST\", url, token, json=data)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"create_repo\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "f288fcba775c",
        "name": "get_file_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 58,
        "endLine": 63,
        "lineCount": 6,
        "parameters": [
          "username",
          "repo_name",
          "file_path",
          "token"
        ],
        "calls": [
          "get_file_info",
          "github_request"
        ],
        "calledBy": [
          "b9152e2e05f3",
          "8aecc87cfbd7",
          "44098917418d"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get information about a file in a repository.",
        "body": "\ndef get_file_info(username, repo_name, file_path, token):\n    \"\"\"Get information about a file in a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/contents/{file_path}\"\n    return github_request(\"GET\", url, token)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_file_info\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "a05438a21c94",
        "name": "update_file",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 63,
        "endLine": 75,
        "lineCount": 13,
        "parameters": [
          "username",
          "repo_name",
          "file_path",
          "content",
          "token",
          "message",
          "sha"
        ],
        "calls": [
          "update_file",
          "b64encode",
          "decode",
          "github_request"
        ],
        "calledBy": [
          "56eb7f277de9",
          "b9152e2e05f3",
          "8aecc87cfbd7",
          "44098917418d",
          "3831ab37da60",
          "d4cc0e31330b"
        ],
        "complexity": 3,
        "isExported": false,
        "isAsync": false,
        "docstring": "Update or create a file in a repository.",
        "body": "\ndef update_file(username, repo_name, file_path, content, token, message, sha=None):\n    \"\"\"Update or create a file in a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/contents/{file_path}\"\n    encoded_content = base64.b64encode(content).decode('utf-8')\n    data = {\n        \"message\": message,\n        \"content\": encoded_content\n    }\n    if sha:\n        data[\"sha\"] = sha\n    return github_request(\"PUT\", url, token, json=data)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"update_file\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "ed46502e03e4",
        "name": "get_commit_history",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 75,
        "endLine": 83,
        "lineCount": 9,
        "parameters": [
          "username",
          "repo_name",
          "token",
          "path"
        ],
        "calls": [
          "get_commit_history",
          "github_request"
        ],
        "calledBy": [
          "51e6ef2a0fbb",
          "ed9e81d9ba4e",
          "6dcebe2d9f75"
        ],
        "complexity": 4,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get commit history for a repository or specific file.",
        "body": "\ndef get_commit_history(username, repo_name, token, path=None):\n    \"\"\"Get commit history for a repository or specific file.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/commits\"\n    params = {}\n    if path:\n        params[\"path\"] = path\n    return github_request(\"GET\", url, token, params=params)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_commit_history\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "9f5b6b9d7027",
        "name": "create_release",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 83,
        "endLine": 95,
        "lineCount": 13,
        "parameters": [
          "username",
          "repo_name",
          "token",
          "tag_name",
          "name",
          "body"
        ],
        "calls": [
          "create_release",
          "github_request"
        ],
        "calledBy": [
          "ea6606b7620d"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Create a new GitHub release.",
        "body": "\ndef create_release(username, repo_name, token, tag_name, name, body=\"\"):\n    \"\"\"Create a new GitHub release.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/releases\"\n    data = {\n        \"tag_name\": tag_name,\n        \"name\": name,\n        \"body\": body,\n        \"draft\": False,\n        \"prerelease\": False\n    }\n    return github_request(\"POST\", url, token, json=data)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"create_release\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "304c2f42440f",
        "name": "create_issue",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 95,
        "endLine": 106,
        "lineCount": 12,
        "parameters": [
          "username",
          "repo_name",
          "token",
          "title",
          "body",
          "assignees"
        ],
        "calls": [
          "create_issue",
          "github_request"
        ],
        "calledBy": [
          "65c5d1c696bf"
        ],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Create a new GitHub issue.",
        "body": "\ndef create_issue(username, repo_name, token, title, body=\"\", assignees=None):\n    \"\"\"Create a new GitHub issue.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/issues\"\n    data = {\n        \"title\": title,\n        \"body\": body\n    }\n    if assignees:\n        data[\"assignees\"] = assignees\n    return github_request(\"POST\", url, token, json=data)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"create_issue\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "0be2041124b1",
        "name": "get_pull_requests",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 106,
        "endLine": 112,
        "lineCount": 7,
        "parameters": [
          "username",
          "repo_name",
          "token",
          "state"
        ],
        "calls": [
          "get_pull_requests",
          "github_request"
        ],
        "calledBy": [],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get pull requests for a repository.",
        "body": "\ndef get_pull_requests(username, repo_name, token, state=\"open\"):\n    \"\"\"Get pull requests for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/pulls\"\n    params = {\"state\": state}\n    return github_request(\"GET\", url, token, params=params)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_pull_requests\" may be dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "2940e06f8c6f",
        "name": "create_pull_request",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 112,
        "endLine": 123,
        "lineCount": 12,
        "parameters": [
          "username",
          "repo_name",
          "token",
          "title",
          "head",
          "base",
          "body"
        ],
        "calls": [
          "create_pull_request",
          "github_request"
        ],
        "calledBy": [
          "dd4bb98c5440"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Create a new pull request.",
        "body": "\ndef create_pull_request(username, repo_name, token, title, head, base, body=\"\"):\n    \"\"\"Create a new pull request.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/pulls\"\n    data = {\n        \"title\": title,\n        \"head\": head,\n        \"base\": base,\n        \"body\": body\n    }\n    return github_request(\"POST\", url, token, json=data)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"create_pull_request\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "e598644894fc",
        "name": "get_contributors",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 123,
        "endLine": 128,
        "lineCount": 6,
        "parameters": [
          "username",
          "repo_name",
          "token"
        ],
        "calls": [
          "get_contributors",
          "github_request"
        ],
        "calledBy": [
          "6dcebe2d9f75",
          "be40efbe3e80"
        ],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get contributors for a repository.",
        "body": "\ndef get_contributors(username, repo_name, token):\n    \"\"\"Get contributors for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/contributors\"\n    return github_request(\"GET\", url, token)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_contributors\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "1a4cd86312dd",
        "name": "get_issues",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 128,
        "endLine": 134,
        "lineCount": 7,
        "parameters": [
          "username",
          "repo_name",
          "token",
          "state"
        ],
        "calls": [
          "get_issues",
          "github_request"
        ],
        "calledBy": [
          "6dcebe2d9f75",
          "65c5d1c696bf",
          "be40efbe3e80"
        ],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get issues for a repository.",
        "body": "\ndef get_issues(username, repo_name, token, state=\"all\"):\n    \"\"\"Get issues for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/issues\"\n    params = {\"state\": state}\n    return github_request(\"GET\", url, token, params=params)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_issues\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "8af97186e8e2",
        "name": "get_repo_forks",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 134,
        "endLine": 139,
        "lineCount": 6,
        "parameters": [
          "owner",
          "repo",
          "token"
        ],
        "calls": [
          "get_repo_forks",
          "github_request"
        ],
        "calledBy": [
          "9ec31c3178f8"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Fetch all forks of a repository.",
        "body": "\ndef get_repo_forks(owner, repo, token):\n    \"\"\"Fetch all forks of a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{owner}/{repo}/forks\"\n    return github_request(\"GET\", url, token, params={\"per_page\": 100})\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_repo_forks\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "cc1f5fc47297",
        "name": "get_repo_languages",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 144,
        "endLine": 149,
        "lineCount": 6,
        "parameters": [
          "username",
          "repo_name",
          "token"
        ],
        "calls": [
          "get_repo_languages",
          "github_request"
        ],
        "calledBy": [
          "f5e6adf207a0"
        ],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get detailed language breakdown for a repository.",
        "body": "\ndef get_repo_languages(username, repo_name, token):\n    \"\"\"Get detailed language breakdown for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/languages\"\n    return github_request(\"GET\", url, token)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_repo_languages\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "851ca2aa04d6",
        "name": "get_community_profile",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 149,
        "endLine": 155,
        "lineCount": 7,
        "parameters": [
          "username",
          "repo_name",
          "token"
        ],
        "calls": [
          "get_community_profile",
          "metrics",
          "github_request"
        ],
        "calledBy": [
          "f5e6adf207a0"
        ],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get community health metrics (presence of README, LICENSE, etc).",
        "body": "\ndef get_community_profile(username, repo_name, token):\n    \"\"\"Get community health metrics (presence of README, LICENSE, etc).\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/community/profile\"\n    # This endpoint uses a different preview header for some data\n    return github_request(\"GET\", url, token)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_community_profile\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "7aba7221be60",
        "name": "get_latest_release",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 155,
        "endLine": 160,
        "lineCount": 6,
        "parameters": [
          "username",
          "repo_name",
          "token"
        ],
        "calls": [
          "get_latest_release",
          "github_request"
        ],
        "calledBy": [
          "f5e6adf207a0"
        ],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get the latest release for a repository.",
        "body": "\ndef get_latest_release(username, repo_name, token):\n    \"\"\"Get the latest release for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/releases/latest\"\n    return github_request(\"GET\", url, token)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_latest_release\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "2cc012b3cc34",
        "name": "get_repo_contents",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 160,
        "endLine": 165,
        "lineCount": 6,
        "parameters": [
          "username",
          "repo_name",
          "token",
          "path"
        ],
        "calls": [
          "get_repo_contents",
          "github_request"
        ],
        "calledBy": [
          "09b2167e8bce"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Get repository contents recursively.",
        "body": "\ndef get_repo_contents(username, repo_name, token, path=\"\"):\n    \"\"\"Get repository contents recursively.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/contents/{path}\"\n    return github_request(\"GET\", url, token)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_repo_contents\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "4b3f28ce9e27",
        "name": "get_user_repos",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 170,
        "endLine": 175,
        "lineCount": 6,
        "parameters": [
          "token"
        ],
        "calls": [
          "get_user_repos",
          "github_request"
        ],
        "calledBy": [
          "1f4213d37548"
        ],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "List all repositories for the authenticated user.",
        "body": "\ndef get_user_repos(token):\n    \"\"\"List all repositories for the authenticated user.\"\"\"\n    url = \"https://api.github.com/user/repos\"\n    return github_request(\"GET\", url, token, params={\"per_page\": 100})\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_user_repos\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "4350d6620c0f",
        "name": "update_repo_visibility",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 175,
        "endLine": 181,
        "lineCount": 7,
        "parameters": [
          "username",
          "repo_name",
          "token",
          "private"
        ],
        "calls": [
          "update_repo_visibility",
          "github_request"
        ],
        "calledBy": [
          "e638d8d1a537"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Update the visibility of a repository.",
        "body": "\ndef update_repo_visibility(username, repo_name, token, private):\n    \"\"\"Update the visibility of a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}\"\n    data = {\"private\": private}\n    return github_request(\"PATCH\", url, token, json=data)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"update_repo_visibility\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "6e8a9abe9285",
        "name": "delete_repo_api",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 181,
        "endLine": 186,
        "lineCount": 6,
        "parameters": [
          "username",
          "repo_name",
          "token"
        ],
        "calls": [
          "delete_repo_api",
          "github_request"
        ],
        "calledBy": [
          "9863eda17987"
        ],
        "complexity": 1,
        "isExported": false,
        "isAsync": false,
        "docstring": "Delete a GitHub repository.",
        "body": "\ndef delete_repo_api(username, repo_name, token):\n    \"\"\"Delete a GitHub repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}\"\n    return github_request(\"DELETE\", url, token)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"delete_repo_api\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "3007556417ad",
        "name": "get_workflow_run_logs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 188,
        "endLine": 193,
        "lineCount": 6,
        "parameters": [
          "username",
          "repo_name",
          "token",
          "run_id"
        ],
        "calls": [
          "get_workflow_run_logs",
          "github_request"
        ],
        "calledBy": [],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Download logs for a specific workflow run.",
        "body": "\ndef get_workflow_run_logs(username, repo_name, token, run_id):\n    \"\"\"Download logs for a specific workflow run.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/actions/runs/{run_id}/logs\"\n    return github_request(\"GET\", url, token)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_workflow_run_logs\" may be dead code: no detected callers, not exported."
    },
    {
      "item": {
        "id": "f16e5c44fb5b",
        "name": "get_dependabot_alerts",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 199,
        "endLine": 204,
        "lineCount": 6,
        "parameters": [
          "username",
          "repo_name",
          "token"
        ],
        "calls": [
          "get_dependabot_alerts",
          "github_request"
        ],
        "calledBy": [
          "8957cebef9b3"
        ],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Fetch Dependabot alerts for a repository.",
        "body": "\ndef get_dependabot_alerts(username, repo_name, token):\n    \"\"\"Fetch Dependabot alerts for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/dependabot/alerts\"\n    return github_request(\"GET\", url, token)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_dependabot_alerts\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "596d2eb4e17c",
        "name": "get_secret_scanning_alerts",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "startLine": 204,
        "endLine": 208,
        "lineCount": 5,
        "parameters": [
          "username",
          "repo_name",
          "token"
        ],
        "calls": [
          "get_secret_scanning_alerts",
          "github_request"
        ],
        "calledBy": [
          "8957cebef9b3"
        ],
        "complexity": 2,
        "isExported": false,
        "isAsync": false,
        "docstring": "Fetch Secret Scanning alerts for a repository.",
        "body": "\ndef get_secret_scanning_alerts(username, repo_name, token):\n    \"\"\"Fetch Secret Scanning alerts for a repository.\"\"\"\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/secret-scanning/alerts\"\n    return github_request(\"GET\", url, token)"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_secret_scanning_alerts\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "ea6606b7620d",
        "name": "create_release_tag",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
        "startLine": 96,
        "endLine": 131,
        "lineCount": 36,
        "parameters": [
          "github_username",
          "github_token",
          "config",
          "args"
        ],
        "calls": [
          "create_release_tag",
          "print_info",
          "get_release_input",
          "print_header",
          "isdir",
          "run",
          "print_success",
          "print_warning",
          "create_release",
          "json",
          "print_error"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 9,
        "isExported": false,
        "isAsync": false,
        "docstring": "Create a new GitHub release with styled output.",
        "body": "\ndef create_release_tag(github_username, github_token, config, args=None):\n    \"\"\"Create a new GitHub release with styled output.\"\"\"\n    if args and args.dry_run:\n        print_info(\"*** Dry Run Mode: No changes will be made. ***\")\n        repo_name, version, name, changelog = get_release_input(config, args, github_username, github_token)\n        print_info(f\"Would create release {version} for {repo_name}.\")\n        return\n\n    print_header(\"Create GitHub Release\")\n    repo_name, version, name, changelog = get_release_input(config, args, github_username, github_token)\n    \n    print_info(f\"Creating release {version} for {repo_name}...\")\n    \n    # 1. Automated Local Tagging\n    try:\n        # Check if we are in the target repo\n        if os.path.isdir(\".git\"):\n            print_info(\"Local Git repository detected. Synchronizing tags...\")\n            # Create tag\n            subprocess.run([\"git\", \"tag\", \"-a\", version, \"-m\", name], capture_output=True)\n            # Push tag\n            subprocess.run([\"git\", \"push\", \"origin\", version], capture_output=True)\n            print_success(f\"Local tag '{version}' pushed to origin.\")\n    except Exception as e:\n        print_warning(f\"Local tagging skipped/failed: {e}\")\n\n    # 2. GitHub API Release\n    response = create_release(github_username, repo_name, github_token, version, name, changelog)\n    \n    if response.status_code == 201:\n        release_data = response.json()\n        print_success(f\"Release created successfully!\")\n        print_info(f\"View release at: {release_data['html_url']}\")\n    else:\n        print_error(f\"Error creating release: {response.status_code} - {response.text}\")"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"create_release_tag\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "dead2b1f6009",
        "name": "get_git_author",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
        "startLine": 8,
        "endLine": 21,
        "lineCount": 14,
        "parameters": [
          "file_path",
          "line_num"
        ],
        "calls": [
          "get_git_author",
          "run",
          "splitlines",
          "startswith",
          "replace",
          "strip"
        ],
        "calledBy": [
          "65c5d1c696bf"
        ],
        "complexity": 5,
        "isExported": false,
        "isAsync": false,
        "docstring": "Extracts the author's email for a specific line using git blame.",
        "body": "\ndef get_git_author(file_path, line_num):\n    \"\"\"Extracts the author's email for a specific line using git blame.\"\"\"\n    try:\n        # porcelain format is easier to parse programmatically\n        cmd = [\"git\", \"blame\", \"-L\", f\"{line_num},{line_num}\", \"--porcelain\", file_path]\n        result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n        for line in result.stdout.splitlines():\n            if line.startswith(\"author-mail \"):\n                return line.replace(\"author-mail <\", \"\").replace(\">\", \"\").strip()\n    except Exception:\n        return None\n    return None\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_git_author\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "03393b735f64",
        "name": "get_code_context",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
        "startLine": 21,
        "endLine": 33,
        "lineCount": 13,
        "parameters": [
          "file_path",
          "line_num",
          "window"
        ],
        "calls": [
          "get_code_context",
          "open",
          "readlines",
          "max",
          "min",
          "join"
        ],
        "calledBy": [
          "65c5d1c696bf"
        ],
        "complexity": 3,
        "isExported": false,
        "isAsync": false,
        "docstring": "Grabs a few lines of code around the TODO for better issue context.",
        "body": "\ndef get_code_context(file_path, line_num, window=3):\n    \"\"\"Grabs a few lines of code around the TODO for better issue context.\"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            lines = f.readlines()\n            start = max(0, line_num - window - 1)\n            end = min(len(lines), line_num + window)\n            snippet = \"\".join(lines[start:end])\n            return f\"```python\\n{snippet}\\n```\"\n    except Exception:\n        return \"Context unavailable.\"\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"get_code_context\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "4ac56e6829e2",
        "name": "create_or_get_github_repository",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "startLine": 73,
        "endLine": 88,
        "lineCount": 16,
        "parameters": [
          "repo_name",
          "repo_description",
          "is_private",
          "github_username",
          "github_token"
        ],
        "calls": [
          "create_or_get_github_repository",
          "get_repo_info",
          "print_info",
          "json",
          "create_repo",
          "print_success",
          "print_error",
          "exit"
        ],
        "calledBy": [
          "44f568d20b70",
          "6b700cc8d9be"
        ],
        "complexity": 4,
        "isExported": false,
        "isAsync": false,
        "docstring": "Creates a new repository on GitHub or confirms an existing one.",
        "body": "\ndef create_or_get_github_repository(repo_name, repo_description, is_private, github_username, github_token):\n    \"\"\"Creates a new repository on GitHub or confirms an existing one.\"\"\"\n    response = get_repo_info(github_username, repo_name, github_token)\n    if response.status_code == 200:\n        print_info(f\"Repository '{repo_name}' already exists on GitHub. Using existing repository.\")\n        return response.json()\n    \n    response = create_repo(github_username, repo_name, github_token, description=repo_description, private=is_private)\n    if response.status_code == 201:\n        print_success(f\"Successfully created repository '{repo_name}' on GitHub.\")\n        return response.json()\n    else:\n        print_error(f\"Error creating repository: {response.status_code} - {response.text}\")\n        sys.exit(1)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"create_or_get_github_repository\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "2fbf4b070b23",
        "name": "run_audit",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "startLine": 34,
        "endLine": 54,
        "lineCount": 21,
        "parameters": [
          "github_username",
          "repo_name",
          "github_token"
        ],
        "calls": [
          "run_audit",
          "print_header",
          "print_info",
          "run",
          "print_success",
          "print_warning",
          "run_advanced_security_scan"
        ],
        "calledBy": [
          "cad67e0dcece"
        ],
        "complexity": 7,
        "isExported": false,
        "isAsync": false,
        "docstring": "Run a security audit on the project dependencies.",
        "body": "\ndef run_audit(github_username=None, repo_name=None, github_token=None):\n    \"\"\"Run a security audit on the project dependencies.\"\"\"\n    print_header(\"Security Audit\")\n    \n    # Local pip-audit\n    print_info(\"Running local pip-audit on current environment...\")\n    try:\n        result = subprocess.run([\"pip-audit\"], capture_output=True, text=True)\n        if result.returncode == 0:\n            print_success(\"No known local vulnerabilities found via pip-audit.\")\n        else:\n            print_warning(\"Local vulnerabilities detected:\")\n            print(result.stdout)\n    except FileNotFoundError:\n        print_warning(\"'pip-audit' not found. Skipping local scan.\")\n\n    # Remote GitHub Security scan if context provided\n    if github_username and repo_name and github_token:\n        run_advanced_security_scan(github_username, repo_name, github_token)\n"
      },
      "type": "function",
      "confidence": 0.8500000000000001,
      "reason": "Function \"run_audit\" may be dead code: not exported."
    },
    {
      "item": {
        "id": "321a2ce9fd8f",
        "name": "MyClass",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "startLine": 13,
        "endLine": 32,
        "methods": [
          "__init__",
          "my_method"
        ],
        "properties": [
          "name"
        ],
        "parents": [],
        "isExported": false
      },
      "type": "class",
      "confidence": 0.85,
      "reason": "Class \"MyClass\" appears unused. No instantiations, inheritance, or references found."
    },
    {
      "item": {
        "id": "321a2ce9fd8f",
        "name": "MyClass",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "startLine": 13,
        "endLine": 32,
        "methods": [
          "__init__",
          "my_method"
        ],
        "properties": [
          "name"
        ],
        "parents": [],
        "isExported": false
      },
      "type": "class",
      "confidence": 0.85,
      "reason": "Class \"MyClass\" appears unused. No instantiations, inheritance, or references found."
    },
    {
      "item": {
        "id": "d4bc0c0d59fb",
        "name": "AnotherClass",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "startLine": 40,
        "endLine": 46,
        "methods": [],
        "properties": [],
        "parents": [],
        "isExported": false
      },
      "type": "class",
      "confidence": 0.85,
      "reason": "Class \"AnotherClass\" appears unused. No instantiations, inheritance, or references found."
    },
    {
      "item": {
        "id": "d4bc0c0d59fb",
        "name": "AnotherClass",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "startLine": 40,
        "endLine": 46,
        "methods": [],
        "properties": [],
        "parents": [],
        "isExported": false
      },
      "type": "class",
      "confidence": 0.85,
      "reason": "Class \"AnotherClass\" appears unused. No instantiations, inheritance, or references found."
    },
    {
      "item": {
        "id": "da721a7f9c8c",
        "name": "Calculator",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
        "startLine": 30,
        "endLine": 51,
        "methods": [
          "__init__",
          "multiply"
        ],
        "properties": [],
        "parents": [],
        "isExported": false
      },
      "type": "class",
      "confidence": 0.85,
      "reason": "Class \"Calculator\" appears unused. No instantiations, inheritance, or references found."
    },
    {
      "item": {
        "id": "da721a7f9c8c",
        "name": "Calculator",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
        "startLine": 30,
        "endLine": 51,
        "methods": [
          "__init__",
          "multiply"
        ],
        "properties": [],
        "parents": [],
        "isExported": false
      },
      "type": "class",
      "confidence": 0.85,
      "reason": "Class \"Calculator\" appears unused. No instantiations, inheritance, or references found."
    },
    {
      "item": {
        "id": "a50d898502e6",
        "name": "TestPygitup",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "startLine": 17,
        "endLine": 205,
        "methods": [
          "test_create_parser",
          "test_load_config_default",
          "test_load_config_custom",
          "test_get_github_token_from_file",
          "test_get_github_token_from_env",
          "test_get_github_username_from_config",
          "test_get_github_username_from_env",
          "test_get_repo_info",
          "test_create_repo",
          "test_update_file",
          "test_generate_changelog"
        ],
        "properties": [],
        "parents": [
          "unittest.TestCase"
        ],
        "isExported": false
      },
      "type": "class",
      "confidence": 0.75,
      "reason": "Class \"TestPygitup\" appears unused. No instantiations, inheritance, or references found."
    },
    {
      "item": {
        "id": "a50d898502e6",
        "name": "TestPygitup",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "startLine": 17,
        "endLine": 205,
        "methods": [
          "test_create_parser",
          "test_load_config_default",
          "test_load_config_custom",
          "test_get_github_token_from_file",
          "test_get_github_token_from_env",
          "test_get_github_username_from_config",
          "test_get_github_username_from_env",
          "test_get_repo_info",
          "test_create_repo",
          "test_update_file",
          "test_generate_changelog"
        ],
        "properties": [],
        "parents": [
          "unittest.TestCase"
        ],
        "isExported": false
      },
      "type": "class",
      "confidence": 0.75,
      "reason": "Class \"TestPygitup\" appears unused. No instantiations, inheritance, or references found."
    }
  ],
  "temporalCoupling": [],
  "intentDrifts": [
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
      "originalIntent": "handle delete, release, overhaul",
      "currentBehavior": "implement reliability, global, crash",
      "driftScore": 1,
      "keyCommits": [
        {
          "hash": "90590f167a586698610e3a0a86a8f15794ba53da",
          "message": "Release 1.0.0: UI Overhaul, Delete Repo, Security Checks",
          "author": "frederickabrah",
          "date": "2026-01-31T21:09:13.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/core/args.py",
            "pygitup/github/api.py",
            "pygitup/github/gists.py",
            "pygitup/github/repo.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/offline.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
      "originalIntent": "fix overhaul, delete, security",
      "currentBehavior": "implement intelligence, transparency, upgrade",
      "driftScore": 1,
      "keyCommits": [
        {
          "hash": "90590f167a586698610e3a0a86a8f15794ba53da",
          "message": "Release 1.0.0: UI Overhaul, Delete Repo, Security Checks",
          "author": "frederickabrah",
          "date": "2026-01-31T21:09:13.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/core/args.py",
            "pygitup/github/api.py",
            "pygitup/github/gists.py",
            "pygitup/github/repo.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/offline.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "05b8895cc5f36220d2e7701c8fc38c18ae48d824",
          "message": "Fix: Restore missing security functions and complete logic overhaul",
          "author": "frederickabrah",
          "date": "2026-01-31T23:06:07.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/github/actions.py",
            "pygitup/github/api.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/scraper.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
      "originalIntent": "fix overhaul, delete, security",
      "currentBehavior": "implement option, gemini, powered",
      "driftScore": 0.9629629629629629,
      "keyCommits": [
        {
          "hash": "90590f167a586698610e3a0a86a8f15794ba53da",
          "message": "Release 1.0.0: UI Overhaul, Delete Repo, Security Checks",
          "author": "frederickabrah",
          "date": "2026-01-31T21:09:13.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/core/args.py",
            "pygitup/github/api.py",
            "pygitup/github/gists.py",
            "pygitup/github/repo.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/offline.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "05b8895cc5f36220d2e7701c8fc38c18ae48d824",
          "message": "Fix: Restore missing security functions and complete logic overhaul",
          "author": "frederickabrah",
          "date": "2026-01-31T23:06:07.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/github/actions.py",
            "pygitup/github/api.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/scraper.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/setup.py",
      "originalIntent": "fix overhaul, delete, security",
      "currentBehavior": "handle release, commit, engine",
      "driftScore": 0.9523809523809523,
      "keyCommits": [
        {
          "hash": "90590f167a586698610e3a0a86a8f15794ba53da",
          "message": "Release 1.0.0: UI Overhaul, Delete Repo, Security Checks",
          "author": "frederickabrah",
          "date": "2026-01-31T21:09:13.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/core/args.py",
            "pygitup/github/api.py",
            "pygitup/github/gists.py",
            "pygitup/github/repo.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/offline.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "05b8895cc5f36220d2e7701c8fc38c18ae48d824",
          "message": "Fix: Restore missing security functions and complete logic overhaul",
          "author": "frederickabrah",
          "date": "2026-01-31T23:06:07.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/github/actions.py",
            "pygitup/github/api.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/scraper.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "9bc5859ea99748161bafb13504663b9e79e9b1b7",
          "message": "Feature: Implement safe Auto-Update system (v1.3.0)",
          "author": "frederickabrah",
          "date": "2026-02-01T09:56:22.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "pygitup/main.py",
            "pygitup/utils/update.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "f257b86f569f5bcf29d6a729f0b5c81a541b08b1",
          "message": "Release: v1.4.0 - AI Commit Engine, OSINT Fork Intelligence, and Great Migration Porter",
          "author": "frederickabrah",
          "date": "2026-02-01T15:18:07.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "1b15ead68d679dc43181ff4887882a870ac15eb6",
          "message": "Release: v1.5.0 - Identity Switcher and TUI Roadmap",
          "author": "frederickabrah",
          "date": "2026-02-01T15:42:26.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/args.py",
      "originalIntent": "handle delete, release, overhaul",
      "currentBehavior": "implement cli, synchronize, all",
      "driftScore": 0.9444444444444444,
      "keyCommits": [
        {
          "hash": "90590f167a586698610e3a0a86a8f15794ba53da",
          "message": "Release 1.0.0: UI Overhaul, Delete Repo, Security Checks",
          "author": "frederickabrah",
          "date": "2026-01-31T21:09:13.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/core/args.py",
            "pygitup/github/api.py",
            "pygitup/github/gists.py",
            "pygitup/github/repo.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/offline.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
      "originalIntent": "fix delete, release",
      "currentBehavior": "implement intelligence, feature, high",
      "driftScore": 0.8974358974358975,
      "keyCommits": [
        {
          "hash": "90590f167a586698610e3a0a86a8f15794ba53da",
          "message": "Release 1.0.0: UI Overhaul, Delete Repo, Security Checks",
          "author": "frederickabrah",
          "date": "2026-01-31T21:09:13.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/core/args.py",
            "pygitup/github/api.py",
            "pygitup/github/gists.py",
            "pygitup/github/repo.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/offline.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "05b8895cc5f36220d2e7701c8fc38c18ae48d824",
          "message": "Fix: Restore missing security functions and complete logic overhaul",
          "author": "frederickabrah",
          "date": "2026-01-31T23:06:07.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/github/actions.py",
            "pygitup/github/api.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/scraper.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
      "originalIntent": "fix overhaul, delete, security",
      "currentBehavior": "implement intelligence, system, full",
      "driftScore": 0.8666666666666667,
      "keyCommits": [
        {
          "hash": "90590f167a586698610e3a0a86a8f15794ba53da",
          "message": "Release 1.0.0: UI Overhaul, Delete Repo, Security Checks",
          "author": "frederickabrah",
          "date": "2026-01-31T21:09:13.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/core/args.py",
            "pygitup/github/api.py",
            "pygitup/github/gists.py",
            "pygitup/github/repo.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/offline.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "05b8895cc5f36220d2e7701c8fc38c18ae48d824",
          "message": "Fix: Restore missing security functions and complete logic overhaul",
          "author": "frederickabrah",
          "date": "2026-01-31T23:06:07.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/github/actions.py",
            "pygitup/github/api.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/scraper.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/__init__.py",
      "originalIntent": "implement feature, safe, auto",
      "currentBehavior": "handle release, identity, switcher",
      "driftScore": 0.8620689655172413,
      "keyCommits": [
        {
          "hash": "9bc5859ea99748161bafb13504663b9e79e9b1b7",
          "message": "Feature: Implement safe Auto-Update system (v1.3.0)",
          "author": "frederickabrah",
          "date": "2026-02-01T09:56:22.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "pygitup/main.py",
            "pygitup/utils/update.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "f257b86f569f5bcf29d6a729f0b5c81a541b08b1",
          "message": "Release: v1.4.0 - AI Commit Engine, OSINT Fork Intelligence, and Great Migration Porter",
          "author": "frederickabrah",
          "date": "2026-02-01T15:18:07.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "1b15ead68d679dc43181ff4887882a870ac15eb6",
          "message": "Release: v1.5.0 - Identity Switcher and TUI Roadmap",
          "author": "frederickabrah",
          "date": "2026-02-01T15:42:26.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "60f68f1747311b71441c542b8a8bb853983563b9",
          "message": "Release: v1.6.0 - AI Release Architect and Path-Aware Auto-Updates",
          "author": "frederickabrah",
          "date": "2026-02-01T15:55:14.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/__init__.py",
      "originalIntent": "implement feature, safe, auto",
      "currentBehavior": "handle release, identity, switcher",
      "driftScore": 0.8620689655172413,
      "keyCommits": [
        {
          "hash": "9bc5859ea99748161bafb13504663b9e79e9b1b7",
          "message": "Feature: Implement safe Auto-Update system (v1.3.0)",
          "author": "frederickabrah",
          "date": "2026-02-01T09:56:22.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "pygitup/main.py",
            "pygitup/utils/update.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "f257b86f569f5bcf29d6a729f0b5c81a541b08b1",
          "message": "Release: v1.4.0 - AI Commit Engine, OSINT Fork Intelligence, and Great Migration Porter",
          "author": "frederickabrah",
          "date": "2026-02-01T15:18:07.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "1b15ead68d679dc43181ff4887882a870ac15eb6",
          "message": "Release: v1.5.0 - Identity Switcher and TUI Roadmap",
          "author": "frederickabrah",
          "date": "2026-02-01T15:42:26.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "60f68f1747311b71441c542b8a8bb853983563b9",
          "message": "Release: v1.6.0 - AI Release Architect and Path-Aware Auto-Updates",
          "author": "frederickabrah",
          "date": "2026-02-01T15:55:14.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/__init__.py",
      "originalIntent": "implement feature, safe, auto",
      "currentBehavior": "handle release, identity, switcher",
      "driftScore": 0.8620689655172413,
      "keyCommits": [
        {
          "hash": "9bc5859ea99748161bafb13504663b9e79e9b1b7",
          "message": "Feature: Implement safe Auto-Update system (v1.3.0)",
          "author": "frederickabrah",
          "date": "2026-02-01T09:56:22.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "pygitup/main.py",
            "pygitup/utils/update.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "f257b86f569f5bcf29d6a729f0b5c81a541b08b1",
          "message": "Release: v1.4.0 - AI Commit Engine, OSINT Fork Intelligence, and Great Migration Porter",
          "author": "frederickabrah",
          "date": "2026-02-01T15:18:07.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "1b15ead68d679dc43181ff4887882a870ac15eb6",
          "message": "Release: v1.5.0 - Identity Switcher and TUI Roadmap",
          "author": "frederickabrah",
          "date": "2026-02-01T15:42:26.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "60f68f1747311b71441c542b8a8bb853983563b9",
          "message": "Release: v1.6.0 - AI Release Architect and Path-Aware Auto-Updates",
          "author": "frederickabrah",
          "date": "2026-02-01T15:55:14.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/__init__.py",
      "originalIntent": "implement feature, safe, auto",
      "currentBehavior": "handle release, identity, switcher",
      "driftScore": 0.8620689655172413,
      "keyCommits": [
        {
          "hash": "9bc5859ea99748161bafb13504663b9e79e9b1b7",
          "message": "Feature: Implement safe Auto-Update system (v1.3.0)",
          "author": "frederickabrah",
          "date": "2026-02-01T09:56:22.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "pygitup/main.py",
            "pygitup/utils/update.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "f257b86f569f5bcf29d6a729f0b5c81a541b08b1",
          "message": "Release: v1.4.0 - AI Commit Engine, OSINT Fork Intelligence, and Great Migration Porter",
          "author": "frederickabrah",
          "date": "2026-02-01T15:18:07.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "1b15ead68d679dc43181ff4887882a870ac15eb6",
          "message": "Release: v1.5.0 - Identity Switcher and TUI Roadmap",
          "author": "frederickabrah",
          "date": "2026-02-01T15:42:26.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "60f68f1747311b71441c542b8a8bb853983563b9",
          "message": "Release: v1.6.0 - AI Release Architect and Path-Aware Auto-Updates",
          "author": "frederickabrah",
          "date": "2026-02-01T15:55:14.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/__init__.py",
      "originalIntent": "implement feature, safe, auto",
      "currentBehavior": "handle release, identity, switcher",
      "driftScore": 0.8620689655172413,
      "keyCommits": [
        {
          "hash": "9bc5859ea99748161bafb13504663b9e79e9b1b7",
          "message": "Feature: Implement safe Auto-Update system (v1.3.0)",
          "author": "frederickabrah",
          "date": "2026-02-01T09:56:22.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "pygitup/main.py",
            "pygitup/utils/update.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "f257b86f569f5bcf29d6a729f0b5c81a541b08b1",
          "message": "Release: v1.4.0 - AI Commit Engine, OSINT Fork Intelligence, and Great Migration Porter",
          "author": "frederickabrah",
          "date": "2026-02-01T15:18:07.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "1b15ead68d679dc43181ff4887882a870ac15eb6",
          "message": "Release: v1.5.0 - Identity Switcher and TUI Roadmap",
          "author": "frederickabrah",
          "date": "2026-02-01T15:42:26.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "60f68f1747311b71441c542b8a8bb853983563b9",
          "message": "Release: v1.6.0 - AI Release Architect and Path-Aware Auto-Updates",
          "author": "frederickabrah",
          "date": "2026-02-01T15:55:14.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/__init__.py",
      "originalIntent": "implement feature, safe, auto",
      "currentBehavior": "handle release, identity, switcher",
      "driftScore": 0.8620689655172413,
      "keyCommits": [
        {
          "hash": "9bc5859ea99748161bafb13504663b9e79e9b1b7",
          "message": "Feature: Implement safe Auto-Update system (v1.3.0)",
          "author": "frederickabrah",
          "date": "2026-02-01T09:56:22.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "pygitup/main.py",
            "pygitup/utils/update.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "f257b86f569f5bcf29d6a729f0b5c81a541b08b1",
          "message": "Release: v1.4.0 - AI Commit Engine, OSINT Fork Intelligence, and Great Migration Porter",
          "author": "frederickabrah",
          "date": "2026-02-01T15:18:07.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "1b15ead68d679dc43181ff4887882a870ac15eb6",
          "message": "Release: v1.5.0 - Identity Switcher and TUI Roadmap",
          "author": "frederickabrah",
          "date": "2026-02-01T15:42:26.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "60f68f1747311b71441c542b8a8bb853983563b9",
          "message": "Release: v1.6.0 - AI Release Architect and Path-Aware Auto-Updates",
          "author": "frederickabrah",
          "date": "2026-02-01T15:55:14.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
      "originalIntent": "implement system, full, manual",
      "currentBehavior": "implement option, gemini, powered",
      "driftScore": 0.8461538461538461,
      "keyCommits": [
        {
          "hash": "7d73d96ae2e3569a242fb1d90447c5e20880341c",
          "message": "System: Full manual audit complete. Synchronized UI, logic, and identity resolution across all 27 features.",
          "author": "frederickabrah",
          "date": "2026-02-01T09:53:48.000Z",
          "filesChanged": [
            "pygitup/core/args.py",
            "pygitup/core/config.py",
            "pygitup/git/branch.py",
            "pygitup/git/cherry_pick.py",
            "pygitup/git/push.py",
            "pygitup/git/stash.py",
            "pygitup/git/tag.py",
            "pygitup/github/api.py",
            "pygitup/github/gists.py",
            "pygitup/github/pull_requests.py",
            "pygitup/github/releases.py",
            "pygitup/github/repo.py",
            "pygitup/github/repo_info.py",
            "pygitup/github/webhooks.py",
            "pygitup/project/docs.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/analytics.py",
            "pygitup/utils/offline.py",
            "pygitup/utils/ui.py",
            "todo.md"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "69c3cafae931314f073d023d629c3704d453b082",
          "message": "AI: Implement Gemini-powered Semantic Commit Engine (Option 30)",
          "author": "frederickabrah",
          "date": "2026-02-01T15:16:06.000Z",
          "filesChanged": [
            "pygitup/core/args.py",
            "pygitup/core/config.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/utils/ai.py",
            "pygitup/utils/ui.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "dafb4a06d4a6c26c400bb1f1cabfd10d228dd780",
          "message": "Identity: Implement Multi-Account Switcher and Profile Management (Option 31)",
          "author": "frederickabrah",
          "date": "2026-02-01T15:23:33.000Z",
          "filesChanged": [
            "pygitup/core/config.py",
            "pygitup/main.py",
            "pygitup/utils/ui.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    },
    {
      "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
      "originalIntent": "fix overhaul, delete",
      "currentBehavior": "implement option, gemini, powered",
      "driftScore": 0.8378378378378378,
      "keyCommits": [
        {
          "hash": "90590f167a586698610e3a0a86a8f15794ba53da",
          "message": "Release 1.0.0: UI Overhaul, Delete Repo, Security Checks",
          "author": "frederickabrah",
          "date": "2026-01-31T21:09:13.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/core/args.py",
            "pygitup/github/api.py",
            "pygitup/github/gists.py",
            "pygitup/github/repo.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/offline.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "05b8895cc5f36220d2e7701c8fc38c18ae48d824",
          "message": "Fix: Restore missing security functions and complete logic overhaul",
          "author": "frederickabrah",
          "date": "2026-01-31T23:06:07.000Z",
          "filesChanged": [
            "README.md",
            "pygitup/github/actions.py",
            "pygitup/github/api.py",
            "pygitup/github/repo_info.py",
            "pygitup/main.py",
            "pygitup/project/project_ops.py",
            "pygitup/utils/scraper.py",
            "pygitup/utils/security.py",
            "pygitup/utils/ui.py",
            "requirements.txt",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        },
        {
          "hash": "9bc5859ea99748161bafb13504663b9e79e9b1b7",
          "message": "Feature: Implement safe Auto-Update system (v1.3.0)",
          "author": "frederickabrah",
          "date": "2026-02-01T09:56:22.000Z",
          "filesChanged": [
            "pygitup/__init__.py",
            "pygitup/main.py",
            "pygitup/utils/update.py",
            "setup.py"
          ],
          "additions": 0,
          "deletions": 0
        }
      ]
    }
  ],
  "authorStats": [],
  "architectureHistory": [
    {
      "timestamp": "2026-02-01T16:08:25.000Z",
      "commitHash": "4949670c58d6c12c3ecd1819a5ccfc078613bf2a",
      "modules": 0,
      "functions": 0,
      "classes": 0,
      "avgComplexity": 0,
      "circularDeps": 0,
      "techDebtScore": 0
    }
  ],
  "techDebtScore": 185.5,
  "healthScore": 0,
  "qualityMetrics": {
    "maintainabilityIndex": 67.78889346597666,
    "cyclomaticComplexity": 11.951219512195122,
    "halsteadMetrics": {
      "vocabulary": 1390,
      "length": 6658,
      "calculatedLength": 13123.015732162545,
      "volume": 69515.30691795317,
      "difficulty": 352.5,
      "effort": 24504145.688578494,
      "timeToImplement": 1361341.4271432497,
      "bugs": 23.17176897265106
    },
    "couplingMetrics": {
      "averageAfferentCoupling": 0.024390243902439025,
      "averageEfferentCoupling": 4.073170731707317,
      "instability": 0.9940476190476191,
      "abstractness": 0,
      "distanceFromMainSequence": 0.005952380952380931
    },
    "cohesionMetrics": {
      "lackOfCohesionOfMethods": 0.18181818181818182,
      "couplingBetweenObjects": 0.25,
      "responseForClass": 3.75
    },
    "duplicationMetrics": {
      "linesOfCode": 4984,
      "duplicatedLines": 94,
      "duplicationRate": 0.01886035313001605,
      "duplicatedBlocks": 0
    },
    "namingMetrics": {
      "functionNamingScore": 0.9416058394160584,
      "variableNamingScore": 0,
      "classNamingScore": 1,
      "avgNameLength": 17.49645390070922,
      "clarityScore": 0.9432624113475178
    },
    "documentationMetrics": {
      "commentToCodeRatio": 0.025280898876404494,
      "documentedFunctions": 110,
      "undocumentedFunctions": 27,
      "docCoverage": 0.8029197080291971,
      "commentQualityScore": 80.2919708029197
    },
    "overallQualityScore": 59,
    "qualityGates": []
  },
  "testCoverage": {
    "totalFiles": 41,
    "testedFiles": 0,
    "untestedFiles": 41,
    "coveragePercentage": 0,
    "functionCoverage": [
      {
        "functionName": "main",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 71,
        "lines": 213
      },
      {
        "functionName": "__init__",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 7
      },
      {
        "functionName": "my_method",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 9
      },
      {
        "functionName": "my_function",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 9
      },
      {
        "functionName": "test_extract_python_docs_module_docstring",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 5
      },
      {
        "functionName": "test_extract_python_docs_functions",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 3,
        "lines": 10
      },
      {
        "functionName": "test_extract_python_docs_classes",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 10,
        "lines": 26
      },
      {
        "functionName": "test_create_parser",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 4
      },
      {
        "functionName": "test_load_config_default",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 6
      },
      {
        "functionName": "test_load_config_custom",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 29
      },
      {
        "functionName": "test_get_github_token_from_file",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 17
      },
      {
        "functionName": "test_get_github_token_from_env",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 16
      },
      {
        "functionName": "test_get_github_username_from_config",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 10
      },
      {
        "functionName": "test_get_github_username_from_env",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 16
      },
      {
        "functionName": "test_get_repo_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 20
      },
      {
        "functionName": "test_create_repo",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 21
      },
      {
        "functionName": "test_update_file",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 23
      },
      {
        "functionName": "test_generate_changelog",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 27
      },
      {
        "functionName": "hello_world",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 13
      },
      {
        "functionName": "add_numbers",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 14
      },
      {
        "functionName": "__init__",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 2
      },
      {
        "functionName": "multiply",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 2
      },
      {
        "functionName": "create_parser",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/args.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 7
      },
      {
        "functionName": "get_config_dir",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 3,
        "lines": 21
      },
      {
        "functionName": "get_active_profile_path",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 3
      },
      {
        "functionName": "set_active_profile",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 3
      },
      {
        "functionName": "list_profiles",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 3
      },
      {
        "functionName": "load_config",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 3
      },
      {
        "functionName": "get_github_token",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 3
      },
      {
        "functionName": "get_github_username",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 3
      },
      {
        "functionName": "configuration_wizard",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 3
      },
      {
        "functionName": "manage_branches",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/branch.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 18,
        "lines": 54
      },
      {
        "functionName": "cherry_pick_commit",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/cherry_pick.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 5,
        "lines": 24
      },
      {
        "functionName": "smart_push",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/push.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 20,
        "lines": 72
      },
      {
        "functionName": "manage_stashes",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/stash.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 19,
        "lines": 52
      },
      {
        "functionName": "manage_tags",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/tag.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 22,
        "lines": 60
      },
      {
        "functionName": "manage_actions",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/actions.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 26,
        "lines": 81
      },
      {
        "functionName": "get_github_headers",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 8
      },
      {
        "functionName": "github_request",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 8,
        "lines": 26
      },
      {
        "functionName": "graphql_request",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 8
      },
      {
        "functionName": "get_repo_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 6
      },
      {
        "functionName": "create_repo",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 11
      },
      {
        "functionName": "get_file_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 6
      },
      {
        "functionName": "update_file",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 3,
        "lines": 13
      },
      {
        "functionName": "get_commit_history",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 4,
        "lines": 9
      },
      {
        "functionName": "create_release",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 13
      },
      {
        "functionName": "create_issue",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 12
      },
      {
        "functionName": "get_pull_requests",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 7
      },
      {
        "functionName": "create_pull_request",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 12
      },
      {
        "functionName": "get_contributors",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 6
      },
      {
        "functionName": "get_issues",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 7
      },
      {
        "functionName": "get_repo_forks",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 6
      },
      {
        "functionName": "compare_commits",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 6
      },
      {
        "functionName": "get_repo_languages",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 6
      },
      {
        "functionName": "get_community_profile",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 7
      },
      {
        "functionName": "get_latest_release",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 6
      },
      {
        "functionName": "get_repo_contents",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 6
      },
      {
        "functionName": "search_user_by_email",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 6
      },
      {
        "functionName": "get_user_repos",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 6
      },
      {
        "functionName": "update_repo_visibility",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 7
      },
      {
        "functionName": "delete_repo_api",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 6
      },
      {
        "functionName": "get_workflow_run_logs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 6
      },
      {
        "functionName": "toggle_workflow_api",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 4,
        "lines": 7
      },
      {
        "functionName": "get_dependabot_alerts",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 6
      },
      {
        "functionName": "get_secret_scanning_alerts",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 5
      },
      {
        "functionName": "manage_gists",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 32,
        "lines": 80
      },
      {
        "functionName": "manage_pull_requests",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 23,
        "lines": 64
      },
      {
        "functionName": "request_code_review",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 28,
        "lines": 74
      },
      {
        "functionName": "open_editor",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 17
      },
      {
        "functionName": "get_release_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 20,
        "lines": 56
      },
      {
        "functionName": "generate_changelog",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 5,
        "lines": 19
      },
      {
        "functionName": "create_release_tag",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 9,
        "lines": 36
      },
      {
        "functionName": "manage_repo_visibility",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 23,
        "lines": 57
      },
      {
        "functionName": "delete_repository",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 11,
        "lines": 38
      },
      {
        "functionName": "get_fork_intelligence",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 16,
        "lines": 56
      },
      {
        "functionName": "parse_github_url",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 5,
        "lines": 15
      },
      {
        "functionName": "get_repo_health_metrics",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 13,
        "lines": 48
      },
      {
        "functionName": "get_detailed_repo_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 30,
        "lines": 105
      },
      {
        "functionName": "manage_webhooks",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/webhooks.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 33,
        "lines": 83
      },
      {
        "functionName": "extract_python_docs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 18,
        "lines": 54
      },
      {
        "functionName": "extract_javascript_docs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 4,
        "lines": 28
      },
      {
        "functionName": "extract_go_docs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 3,
        "lines": 18
      },
      {
        "functionName": "extract_cpp_docs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 5,
        "lines": 28
      },
      {
        "functionName": "extract_java_docs",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 18
      },
      {
        "functionName": "generate_documentation",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 14,
        "lines": 38
      },
      {
        "functionName": "get_git_author",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 5,
        "lines": 14
      },
      {
        "functionName": "get_code_context",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 3,
        "lines": 13
      },
      {
        "functionName": "scan_todos",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 39,
        "lines": 97
      },
      {
        "functionName": "get_project_directory_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 17,
        "lines": 35
      },
      {
        "functionName": "initialize_git_repository",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 6,
        "lines": 26
      },
      {
        "functionName": "create_or_get_github_repository",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 4,
        "lines": 16
      },
      {
        "functionName": "push_to_github",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 8,
        "lines": 25
      },
      {
        "functionName": "upload_project_directory",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 7,
        "lines": 32
      },
      {
        "functionName": "get_single_file_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 21,
        "lines": 62
      },
      {
        "functionName": "upload_single_file",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 23,
        "lines": 74
      },
      {
        "functionName": "get_batch_files_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 22,
        "lines": 42
      },
      {
        "functionName": "upload_batch_files",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 17,
        "lines": 64
      },
      {
        "functionName": "get_multi_repo_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 13,
        "lines": 28
      },
      {
        "functionName": "update_multiple_repos",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 14,
        "lines": 61
      },
      {
        "functionName": "migrate_repository",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 15,
        "lines": 35
      },
      {
        "functionName": "manage_bulk_repositories",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 8,
        "lines": 38
      },
      {
        "functionName": "main",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 4
      },
      {
        "functionName": "get_template_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 15,
        "lines": 40
      },
      {
        "functionName": "create_project_from_template",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 11,
        "lines": 51
      },
      {
        "functionName": "get_git_diff",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 4,
        "lines": 12
      },
      {
        "functionName": "generate_ai_commit_message",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 11,
        "lines": 48
      },
      {
        "functionName": "generate_ai_release_notes",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 8,
        "lines": 41
      },
      {
        "functionName": "ai_commit_workflow",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 7,
        "lines": 43
      },
      {
        "functionName": "calculate_resolution_time",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 6,
        "lines": 16
      },
      {
        "functionName": "predict_growth",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 4,
        "lines": 14
      },
      {
        "functionName": "export_report",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 5,
        "lines": 18
      },
      {
        "functionName": "generate_analytics",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 10,
        "lines": 69
      },
      {
        "functionName": "show_banner",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/banner.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 6,
        "lines": 20
      },
      {
        "functionName": "queue_offline_commit",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 18,
        "lines": 63
      },
      {
        "functionName": "process_offline_queue",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 21,
        "lines": 75
      },
      {
        "functionName": "scrape_repo_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/scraper.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 41,
        "lines": 108
      },
      {
        "functionName": "calculate_entropy",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 4,
        "lines": 12
      },
      {
        "functionName": "run_audit",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 7,
        "lines": 21
      },
      {
        "functionName": "run_advanced_security_scan",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 16,
        "lines": 35
      },
      {
        "functionName": "check_is_sensitive",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 17,
        "lines": 31
      },
      {
        "functionName": "audit_files_and_prompt",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 12,
        "lines": 19
      },
      {
        "functionName": "scan_directory_for_sensitive_files",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 8,
        "lines": 23
      },
      {
        "functionName": "print_success",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 5
      },
      {
        "functionName": "print_error",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 5
      },
      {
        "functionName": "print_warning",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 5
      },
      {
        "functionName": "print_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 5
      },
      {
        "functionName": "print_header",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 1,
        "lines": 5
      },
      {
        "functionName": "show_spinner",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 2,
        "lines": 10
      },
      {
        "functionName": "display_menu",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 4,
        "lines": 29
      },
      {
        "functionName": "display_repo_info",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 44,
        "lines": 119
      },
      {
        "functionName": "display_traffic_trends",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 9,
        "lines": 38
      },
      {
        "functionName": "is_newer",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 7,
        "lines": 14
      },
      {
        "functionName": "check_for_updates",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 9,
        "lines": 23
      },
      {
        "functionName": "perform_update",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 5,
        "lines": 33
      },
      {
        "functionName": "validate_repo_name",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 6,
        "lines": 17
      },
      {
        "functionName": "validate_file_path",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 5,
        "lines": 13
      },
      {
        "functionName": "sanitize_input",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
        "isTested": false,
        "testFiles": [],
        "complexity": 3,
        "lines": 9
      }
    ],
    "classCoverage": [
      {
        "className": "MyClass",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "isTested": false,
        "testFiles": [],
        "methodCoverage": 0
      },
      {
        "className": "AnotherClass",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "isTested": false,
        "testFiles": [],
        "methodCoverage": 100
      },
      {
        "className": "TestPygitup",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "methodCoverage": 0
      },
      {
        "className": "Calculator",
        "filePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
        "isTested": false,
        "testFiles": [],
        "methodCoverage": 0
      }
    ],
    "moduleCoverage": [
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 100,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/setup.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 100,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/__init__.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 100,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/main.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/tests/conftest.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 100,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_docs.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 0
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_main.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 0
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/tests/test_module.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 0
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/__init__.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 100,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/args.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/core/config.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/__init__.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 100,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/branch.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/cherry_pick.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/push.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/stash.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/git/tag.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/__init__.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 100,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/actions.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/api.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/gists.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/pull_requests.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/releases.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/repo_info.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/github/webhooks.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/__init__.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 100,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/docs.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/issues.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/project_ops.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/project/templates.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/__init__.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 100,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ai.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/analytics.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/banner.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/offline.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/scraper.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/security.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/ui.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/update.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      },
      {
        "modulePath": "/data/data/com.termux/files/home/PyGitUp/pygitup/utils/validation.py",
        "isTested": false,
        "testFiles": [],
        "functionCoverage": 0,
        "classCoverage": 100
      }
    ],
    "recommendations": [
      "Create tests for 41 untested modules including: pygitup.py, setup.py, __init__.py",
      "Prioritize tests for 37 high-complexity untested functions",
      "Current test coverage is 0.0%. Aim for 80%+ coverage."
    ]
  },
  "architectureCompliance": {
    "violations": [],
    "complianceScore": 100,
    "totalChecks": 0,
    "passedChecks": 0,
    "failedChecks": 0,
    "detailedReport": "# Architecture Compliance Report\n\n## Summary\n\n- **Compliance Score**: 100.0%\n- **Total Checks**: 0\n- **Passed**: 0\n- **Failed**: 0\n\n## No Violations Found\n\nCongratulations! The codebase complies with all architectural rules.\n\n---\nReport generated by CARE - Code Archaeologist & Refactor Engine\n"
  },
  "intentDriftPredictions": [],
  "architectureEvolution": {
    "riskScore": 0,
    "predictedChanges": [],
    "trendAnalysis": {
      "growthRate": 0,
      "complexityTrend": 0,
      "stability": 0,
      "riskFactors": []
    },
    "predictions": []
  }
}